use gl::types::GLchar;
use gl::types::GLint;
use gl::types::GLuint;
use std::ffi::CStr;
use std::ffi::CString;
use std::ptr;
use std::str;

pub struct Shader {
    pub sp: GLuint,
}

impl Shader {
    pub fn new(vertex_src: &str, geometry_src: Option<&str>, fragment_src: &str) -> Shader {
        unsafe {
            // compile vertex shader
            let vs = gl::CreateShader(gl::VERTEX_SHADER);
            let vcstr = CString::new(vertex_src.as_bytes()).unwrap();
            gl::ShaderSource(vs, 1, &vcstr.as_ptr(), ptr::null());
            gl::CompileShader(vs);
            let mut success = gl::FALSE as GLint;
            let mut info_log = Vec::with_capacity(512);
            info_log.set_len(512 - 1);
            gl::GetShaderiv(vs, gl::COMPILE_STATUS, &mut success);
            gl::GetShaderInfoLog(
                vs,
                512,
                ptr::null_mut(),
                info_log.as_mut_ptr() as *mut GLchar,
            );
            let c_str: &CStr = CStr::from_ptr(info_log.as_ptr());
            let str_slice: &str = c_str.to_str().unwrap();
            if str_slice.len() > 0 {
                println!("e: vertex shader:\n{}", str_slice);
            }
            if success != gl::TRUE as GLint {
                panic!("e: aborting.");
            }

            // compile geometry shader
            let mut gs = 0;
            match geometry_src {
                Some(src) => {
                    gs = gl::CreateShader(gl::GEOMETRY_SHADER);
                    let gcstr = CString::new(src.as_bytes()).unwrap();
                    gl::ShaderSource(gs, 1, &gcstr.as_ptr(), ptr::null());
                    gl::CompileShader(gs);
                    let mut success = gl::FALSE as GLint;
                    let mut info_log = Vec::with_capacity(512);
                    info_log.set_len(512 - 1);
                    gl::GetShaderiv(gs, gl::COMPILE_STATUS, &mut success);
                    gl::GetShaderInfoLog(
                        gs,
                        512,
                        ptr::null_mut(),
                        info_log.as_mut_ptr() as *mut GLchar,
                    );
                    let c_str: &CStr = CStr::from_ptr(info_log.as_ptr());
                    let str_slice: &str = c_str.to_str().unwrap();
                    if str_slice.len() > 0 {
                        println!("e: geometry shader:\n{}", str_slice);
                    }
                    if success != gl::TRUE as GLint {
                        panic!("e: aborting.");
                    }
                }
                None => {}
            }

            // compile fragment shader
            let fs = gl::CreateShader(gl::FRAGMENT_SHADER);
            let fcstr = CString::new(fragment_src.as_bytes()).unwrap();
            gl::ShaderSource(fs, 1, &fcstr.as_ptr(), ptr::null());
            gl::CompileShader(fs);
            gl::GetShaderiv(fs, gl::COMPILE_STATUS, &mut success);
            gl::GetShaderInfoLog(
                fs,
                512,
                ptr::null_mut(),
                info_log.as_mut_ptr() as *mut GLchar,
            );
            let c_str: &CStr = CStr::from_ptr(info_log.as_ptr());
            let str_slice: &str = c_str.to_str().unwrap();
            if str_slice.len() > 0 {
                println!("e: fragment shader:\n{}", str_slice);
            }
            if success != gl::TRUE as GLint {
                panic!("e: aborting.");
            }

            // link shaders
            let sp = gl::CreateProgram();
            gl::AttachShader(sp, vs);
            match geometry_src {
                Some(src) => {
                    gl::AttachShader(sp, gs);
                }
                None => {}
            }
            gl::AttachShader(sp, fs);
            gl::LinkProgram(sp);
            gl::GetProgramiv(sp, gl::LINK_STATUS, &mut success);
            gl::GetProgramInfoLog(
                sp,
                512,
                ptr::null_mut(),
                info_log.as_mut_ptr() as *mut GLchar,
            );
            let c_str: &CStr = CStr::from_ptr(info_log.as_ptr());
            let str_slice: &str = c_str.to_str().unwrap();
            if str_slice.len() > 0 {
                println!("e: shader program:\n{}", str_slice);
            }
            if success != gl::TRUE as GLint {
                panic!("e: aborting.");
            }

            // and delete references to the separate shaders
            gl::DeleteShader(vs);
            match geometry_src {
                Some(src) => {
                    gl::DeleteShader(gs);
                }
                None => {}
            }
            gl::DeleteShader(fs);

            Shader { sp: sp }
        }
    }

    pub fn bind(&self) {
        unsafe { gl::UseProgram(self.sp) };
    }

    pub fn unbind(&self) {
        unsafe { gl::UseProgram(0) };
    }
}

impl Drop for Shader {
    fn drop(&mut self) {
        unsafe { gl::DeleteProgram(self.sp) };
    }
}
