use image;
use image::DynamicImage;
use std::os::raw::c_void;
use std::str;

pub struct Texture2DArray {
    tex: u32,
    width: u32,
    height: u32,
}

impl Texture2DArray {
    pub fn new(count: u32, width: u32, height: u32) -> Texture2DArray {
        let mut tex: u32 = 0;
        unsafe {
            gl::GenTextures(1, &mut tex);
            gl::BindTexture(gl::TEXTURE_2D_ARRAY, tex);
            gl::TexImage3D(
                gl::TEXTURE_2D_ARRAY,
                0,
                gl::RGBA8 as i32,
                width as i32,
                height as i32,
                count as i32,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                0 as *const c_void,
            );
            gl::TexParameteri(gl::TEXTURE_2D_ARRAY, gl::TEXTURE_WRAP_S, gl::REPEAT as i32);
            gl::TexParameteri(gl::TEXTURE_2D_ARRAY, gl::TEXTURE_WRAP_T, gl::REPEAT as i32);
            gl::TexParameteri(
                gl::TEXTURE_2D_ARRAY,
                gl::TEXTURE_MIN_FILTER,
                gl::NEAREST as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_2D_ARRAY,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
        }

        Texture2DArray {
            tex: tex,
            width: width as u32,
            height: height as u32,
        }
    }

    pub fn load(&self, layer: u32, fname: &str) {
        //println!("e: loading texture {}",fname);
        let img = image::open(fname).expect("e: unable to load image");
        let img = match img {
            DynamicImage::ImageRgba8(img) => img,
            img => img.to_rgba(),
        };
        unsafe {
            gl::BindTexture(gl::TEXTURE_2D_ARRAY, self.tex);
            gl::TexSubImage3D(
                gl::TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                layer as i32,
                self.width as i32,
                self.height as i32,
                1,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                img.into_raw().as_ptr() as *const c_void,
            );
        }
    }

    #[allow(unused_variables)]
    pub fn bind(&self, n: u32) {
        unsafe {
            gl::BindTexture(gl::TEXTURE_2D_ARRAY, self.tex);
        }
    }
}
