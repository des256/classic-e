use std::ffi::c_void;
use std::mem;

pub mod fonts;
mod grid;
mod menubar;
//mod node;

pub use grid::Column;
pub use grid::Row;
//pub use menubar::MenuBar;
//pub use node::Node;
//pub use node::NodeBase;

#[cfg(target_os = "linux")]
use crate::canvas_linux::Canvas;
#[cfg(target_os = "windows")]
use crate::canvas_windows::Canvas;

// this should be replaced properly:
const STATIC: &str = "/home/desmond/e/static";

// All UI components are zoomed/panned rectangles in frames.
// A rectangle can be a cursor, background box, horizontal line, vertical line, text character or icon; transparent or solid, in various modes.
// The frames are defined in UBO/SSBO-like structures. They define origin, size, zoom, parent and visibility.
// Frames are used to simplify calculating coordinates and proper clipping.
// Each rectangle is defined as a single vertex: x,y,xs,ys; u,v,us,vs; r,g,b,a; f,m,l,d;
// The vertex shader does very little.
// The geometry shader generates the 4 actual corners of the rectangle, transforms and clips them through the frame tree, potentially discards the complete rectangle, and finally emits the vertices for two triangles.
// The fragment shader renders the rectangle in various modes, one being MSDF text.
// Whenever a refresh is wanted, the entire vertex array is redrawn. To navigate through the UI, change/update the UBO/SSBO. To add or remove information, edit the vertex array.

// this needs: Frames in uniform buffer, textures in array (of which some are font maps), vertices in vertex array
const UI_VERTEX_SHADER: &str = r#"
    #version 420 core

    layout(location = 0) in vec4 i_quad;
    layout(location = 1) in vec4 i_tex;
    layout(location = 2) in vec4 i_col;
    layout(location = 3) in uvec4 i_fmld;  // f = frame, m = mode, l = texture layer, d = depth

    out Quad {
        vec4 tex;
        vec4 col;
        uvec4 fmld;
    } vs_out;

    void main() {
        gl_Position = i_quad;
        vs_out.tex = i_tex;
        vs_out.col = i_col;
        vs_out.fmld = i_fmld;
    }
"#;

const UI_GEOMETRY_SHADER: &str = r#"
    #version 420 core

    struct Frame
    {
        vec2 pos;
        vec2 size;
        vec2 internal_offset;
        vec2 internal_scale;
        uint parent;
        uint flags;
    };

    layout(std140,binding = 0) uniform u_frames
    {
        Frame frames[340];
    };

    layout(points) in;
    layout(triangle_strip, max_vertices = 4) out;

    in Quad {
        vec4 tex;
        vec4 col;
        uvec4 fmld;
    } gs_in[];

    out Vertex {
        vec2 tex;
        vec4 col;
        vec4 clip;
        flat uvec3 mld;
    } gs_out;

    void main() {
        vec4 p = gl_in[0].gl_Position;      // quad coordinates and size
        uint f = gs_in[0].fmld.x;           // frame in which to render
        vec4 c = vec4(0,0,frames[f].size);  // start clipping rectangle with this frame
        uint flags = frames[f].flags & 3;   // start checking existance and visibility
        while(int(f) != 0)                  // while this is not the root...
        {
            p.xy *= frames[f].internal_scale;   // scale quad coordinates out of this frame
            p.zw *= frames[f].internal_scale;   // scale quad size out of this frame
            p.xy += frames[f].internal_offset;  // pan quad out of this frame
            p.xy -= frames[f].pos;              // move to parent origin
            f = frames[f].parent;               // switch to parent frame
            flags &= frames[f].flags & 3;       // update flags
            c.xy *= frames[f].internal_scale;   // scale clipping rectangle coordinates out of this frame
            c.zw *= frames[f].internal_scale;   // scale clipping rectangle size out of this frame
            c.xy += frames[f].internal_offset;  // pan clipping rectangle out of this frame
            c.zw += frames[f].internal_offset;
            c.x = max(c.x,0);                   // clip clipping rectangle to this frame
            c.y = max(c.y,0);
            c.z = min(c.z,frames[f].size.x);
            c.w = min(c.w,frames[f].size.y);
            c.xy += frames[f].pos;              // move to parent origin
            c.zw += frames[f].pos;              // move to parent origin
        }
        if((c.z > c.x) && (c.w > c.y) && ((flags & 3) == 3))  // if there is a clipping rectangle left, and the frame exists and is visible
        {
            p.xy *= frames[0].internal_scale;   // scale quad coordinates out of root
            p.zw *= frames[0].internal_scale;   // scale quad size out of root
            p.xy += frames[0].internal_offset;  // pan quad out of root

            // prepare clipping distances for per-pixel clipping
            vec4 c00 = vec4(p.x - c.x,p.y - c.y,c.z - p.x,c.w - p.y);
            vec4 cx0 = vec4(p.x + p.z - c.x,p.y - c.y,c.z - p.x - p.z,c.w - p.y);
            vec4 c0y = vec4(p.x - c.x,p.y + p.w - c.y,c.z - p.x,c.w - p.y - p.w);
            vec4 cxy = vec4(p.x + p.z - c.x,p.y + p.w - c.y,c.z - p.x - p.z,c.w - p.y - p.w);

            // normalize quad coordinates and size to 0..1
            p.xy /= frames[0].size;
            p.zw /= frames[0].size;

            // emit upper-left corner
            gl_Position = vec4(-1.0 + 2.0 * p.x,1.0 - 2.0 * p.y,0.0,1.0);
            gs_out.tex = vec2(gs_in[0].tex.x,gs_in[0].tex.y);
            gs_out.col = gs_in[0].col;
            gs_out.clip = c00;
            gs_out.mld = gs_in[0].fmld.yzw;
            EmitVertex();

            // emit upper-right corner
            gl_Position = vec4(-1.0 + 2.0 * (p.x + p.z),1.0 - 2.0 * p.y,0.0,1.0);
            gs_out.tex = vec2(gs_in[0].tex.x + gs_in[0].tex.z,gs_in[0].tex.y);
            gs_out.col = gs_in[0].col;
            gs_out.clip = cx0;
            gs_out.mld = gs_in[0].fmld.yzw;
            EmitVertex();

            // emit lower-left corner            
            gl_Position = vec4(-1.0 + 2.0 * p.x,1.0 - 2.0 * (p.y + p.w),0.0,1.0);
            gs_out.tex = vec2(gs_in[0].tex.x,gs_in[0].tex.y + gs_in[0].tex.w);
            gs_out.col = gs_in[0].col;
            gs_out.clip = c0y;
            gs_out.mld = gs_in[0].fmld.yzw;
            EmitVertex();
            
            // emit lower-right corner
            gl_Position = vec4(-1.0 + 2.0 * (p.x + p.z),1.0 - 2.0 * (p.y + p.w),0.0,1.0);
            gs_out.tex = vec2(gs_in[0].tex.x + gs_in[0].tex.z,gs_in[0].tex.y + gs_in[0].tex.w);
            gs_out.col = gs_in[0].col;
            gs_out.clip = cxy;
            gs_out.mld = gs_in[0].fmld.yzw;
            EmitVertex();

            EndPrimitive();
        }
    }
"#;

const UI_FRAGMENT_SHADER: &str = r#"
    #version 420 core

    in Vertex {
        vec2 tex;
        vec4 col;
        vec4 clip;
        flat uvec3 mld;
    } fs_in;

    out vec4 FragColor;

    uniform sampler2DArray sampler;
    
    float median(float r, float g, float b) {
        return max(min(r, g), min(max(r, g), b));
    }
    
    void main() {
        if(fs_in.clip.x < 0.0)
            discard;
        if(fs_in.clip.y < 0.0)
            discard;
        if(fs_in.clip.z < 0.0)
            discard;
        if(fs_in.clip.w < 0.0)
            discard;
        vec4 c = vec4(fs_in.col.b,fs_in.col.g,fs_in.col.r,fs_in.col.a);
        vec4 t = texture(sampler,vec3(fs_in.tex,fs_in.mld.y));
        switch(fs_in.mld.x)
        {
            case 0:
                discard;

            case 1:
                FragColor = c;
                break;

            case 2:
                FragColor = t;
                break;

            case 3:
                FragColor = c * t;
                break;

            case 4:
                FragColor = c + t;
                break;

            case 5:
                FragColor = c - t;
                break;

            case 6:
                FragColor = t - c;
                break;

            case 7:
                vec2 unit = (4.0 / textureSize(sampler,0)).xy;
                float dist = median(t.x,t.y,t.z) - 0.5;
                dist *= dot(unit,0.5 / fwidth(fs_in.tex));
                float cov = clamp(dist + 0.5,0.0,1.0);
                FragColor = vec4(c.x,c.y,c.z,c.w * cov);
                break;
        }
    }
"#;

#[repr(packed)]
pub struct Quad {
    pub x: f32,   // left coordinate of quad
    pub y: f32,   // top coordinate of quad
    pub xs: f32,  // width of quad
    pub ys: f32,  // height of quad
    pub u: f32,   // left texture coordinate
    pub v: f32,   // top texture coordinate
    pub us: f32,  // texture width
    pub vs: f32,  // texture height
    pub col: u32, // color
    pub f: u16,   // frame ID
    pub m: u16,   // rendering mode
    pub l: u16,   // texture array index
    pub d: u16,   // depth (TBD)
}
const QUAD_SIZE: i32 = 44;

#[repr(packed)]
#[derive(Copy, Clone)]
pub struct Frame {
    pub x: f32,         // left position in parent
    pub y: f32,         // right position in parent
    pub xs: f32,        // width -> clipping occurs at x = 0 and x = xs of parent frame
    pub ys: f32,        // height -> clipping occurs at y = 0 and y = ys of parent frame
    pub dx: f32,        // x offset of children, coordinates hosted by this view is shifted by dx
    pub dy: f32,        // y offset of children, coordinates hosted by this view is shifted by dy
    pub xx: f32,        // x scale of children, coordinates hosted by this view are stretched by xx
    pub yy: f32,        // y scale of children, coordinates hosted by this view are stretched by yy
    pub parent: u32,    // index of parent, or 0 if root
    pub flags: u32,     // flags, combination of FLAGS_*
    padding: [u32; 2],  // long story... OpenGL requires structures like this to be a multiple of 16 bytes
}
const FRAME_SIZE: i32 = 48;

const FRAME_EXISTS: u32 = 0x00000001;
const FRAME_VISIBLE: u32 = 0x00000002;
const FRAME_AUTOSIZE: u32 = 0x00000004;

const MAX_FRAMES: i32 = 340;

pub trait Widget {
    fn show(&mut self);
    fn hide(&mut self);
    fn move_resize(&mut self,x: f32,y: f32,xs: f32,ys: f32);
    fn pan_zoom(&mut self,dx: f32,dy: f32,xx: f32,yy: f32);
}

pub struct UI<'a> {
    canvas: &'a Canvas,                   // canvas on which this UI is running
    frames: [Frame; MAX_FRAMES as usize], // frame array
    ubo: u32,                             // uniform buffer object for frame array
    quads: Vec<Quad>,                     // vertex array
    vao: u32,                             // vertex array object for vertex array
    textures: crate::Texture2DArray,      // 2D texture array
    shader: crate::Shader,                // the shader
    pub psize: f32,                       // general zoom factor of the canvas
    root: Option<&'a Widget>,             // root widget reference
}

impl<'a> UI<'a> {
    pub fn new(canvas: &'a Canvas) -> UI<'a> {
        // start with root frame at index 0
        let frames: [Frame; MAX_FRAMES as usize] = [Frame {
            x: 0.0,
            y: 0.0,
            xs: canvas.width as f32,
            ys: canvas.height as f32,
            dx: 0.0,
            dy: 0.0,
            xx: 1.0,
            yy: 1.0,
            parent: 0,
            flags: FRAME_EXISTS | FRAME_VISIBLE | FRAME_AUTOSIZE,
            padding: [0,0],
        }; MAX_FRAMES as usize];
        // allocate textures
        let textures = crate::Texture2DArray::new(16, 512, 512);
        // load fonts
        textures.load(
            fonts::MONO.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::MONO.name),
        );
        textures.load(
            fonts::PIXEL.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::PIXEL.name),
        );
        textures.load(
            fonts::SANS.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::SANS.name),
        );
        textures.load(
            fonts::SANSI.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::SANSI.name),
        );
        textures.load(
            fonts::SERIF.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::SERIF.name),
        );
        textures.load(
            fonts::SERIFI.page as u32,
            &format!("{}/fonts/{}", STATIC, fonts::SERIFI.name),
        );
        // TODO: load icons
        // create the vertex array and uniform buffer objects
        let mut vao = 0;
        let mut ubo = 0;
        unsafe {
            gl::GenVertexArrays(1, &mut vao);
            gl::BindVertexArray(vao);
            let mut vbo = 0;
            gl::GenBuffers(1, &mut vbo);
            gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
            gl::BufferData(gl::ARRAY_BUFFER, 0, 0 as *const c_void, gl::DYNAMIC_DRAW);

            let quad_stride = mem::size_of::<Quad>() as i32;
            gl::VertexAttribPointer(0, 4, gl::FLOAT, gl::FALSE, quad_stride, 0 as *const c_void);
            gl::EnableVertexAttribArray(0);

            gl::VertexAttribPointer(1, 4, gl::FLOAT, gl::FALSE, quad_stride, 16 as *const c_void);
            gl::EnableVertexAttribArray(1);

            gl::VertexAttribPointer(
                2,
                4,
                gl::UNSIGNED_BYTE,
                gl::TRUE,
                quad_stride,
                32 as *const c_void,
            );
            gl::EnableVertexAttribArray(2);

            gl::VertexAttribIPointer(3, 4, gl::UNSIGNED_SHORT, quad_stride, 36 as *const c_void);
            gl::EnableVertexAttribArray(3);

            gl::GenBuffers(1, &mut ubo);
            gl::BindBuffer(gl::UNIFORM_BUFFER, ubo);
            gl::BufferData(
                gl::UNIFORM_BUFFER,
                (MAX_FRAMES * FRAME_SIZE) as isize,
                0 as *const c_void,
                gl::DYNAMIC_DRAW,
            );
        }
        // create the shader
        let shader = crate::Shader::new(
            UI_VERTEX_SHADER,
            Some(UI_GEOMETRY_SHADER),
            UI_FRAGMENT_SHADER,
        );
        UI {
            canvas: canvas,
            frames: frames,
            ubo: ubo,
            textures: textures,
            shader: shader,
            quads: Vec::new(),
            vao: vao,
            psize: 4.0,
            root: None,
        }
    }

    fn update_quads_gpu(&self) {
        // update vertex array to GPU after changes
        // TODO: optimize
        unsafe {
            gl::BindVertexArray(self.vao);
            gl::BufferData(
                gl::ARRAY_BUFFER,
                (self.quads.len() * (QUAD_SIZE as usize)) as isize,
                self.quads.as_ptr() as *const Quad as *const c_void,
                gl::DYNAMIC_DRAW,
            );
        }
    }

    fn update_frames_gpu(&self) {
        // update frame array to GPU after changes
        unsafe {
            gl::BindBuffer(gl::UNIFORM_BUFFER, self.ubo);
            gl::BufferSubData(
                gl::UNIFORM_BUFFER,
                0,
                (MAX_FRAMES * FRAME_SIZE) as isize,
                self.frames.as_ptr() as *const Frame as *const c_void,
            );
        }
    }

    pub fn register_root(&mut self,root: &'a Widget) {
        self.root = Some(root);
    }

    pub fn push(
        &mut self,
        x: f32,     // left
        y: f32,     // top
        xs: f32,    // width
        ys: f32,    // height
        u: f32,     // texture left
        v: f32,     // texture top
        us: f32,    // texture width
        vs: f32,    // texture height
        col: u32,   // color
        frame: u16, // frame ID
        mode: u16,  // render mode
        layer: u16, // source texture layer
        depth: u16, // depth (TBD)
    ) {
        // push quad onto the vertex array
        self.quads.push(Quad {
            x: x,
            y: y,
            xs: xs,
            ys: ys,
            u: u,
            v: v,
            us: us,
            vs: vs,
            col: col,
            f: frame,
            m: mode,
            l: layer,
            d: depth,
        });
        self.update_quads_gpu();
    }

    pub fn push_text(
        &mut self,
        frame: u16,                    // frame ID
        x: f32,                        // left coordinate
        y: f32,                        // top coordinate
        text: &str,                    // the text to render
        col: u32,                      // color
        font: &crate::ui::fonts::Font, // font to use
        size: f32,                     // font size
    ) {
        // push text characters onto vertex array
        let mut cx: f32 = x;
        let mut it = text.chars();
        // get first character
        let c = it.next().unwrap();
        // find character in font
        let mut cur: Option<&crate::ui::fonts::Char> = None;
        for cfc in font.chars {
            if cfc.point == c as i32 {
                cur = Some(cfc);
                break;
            }
        }
        loop {
            // if character is represented in the font, push character and move cursor
            match cur {
                Some(cfc) => {
                    self.push(
                        cx + cfc.dx * size,
                        y + cfc.dy * size,
                        cfc.w * size,
                        cfc.h * size,
                        cfc.u0,
                        cfc.v0,
                        cfc.us,
                        cfc.vs,
                        col,
                        frame,
                        7,
                        font.page as u16,
                        0,
                    );
                    cx += cfc.adv * size;
                }
                None => {}
            }
            // get next character
            let nc = it.next();
            match nc {
                None => {
                    break; // no next, so exit loop
                }
                Some(nc) => {
                    // find character in font
                    let mut next: Option<&crate::ui::fonts::Char> = None;
                    for nfc in font.chars {
                        if nfc.point == nc as i32 {
                            next = Some(nfc);
                            break;
                        }
                    }
                    // apply kerning, if available
                    match next {
                        Some(nfc) => match cur {
                            Some(cfc) => {
                                for kerning in font.kernings {
                                    if (kerning.a == cfc.point) && (kerning.b == nfc.point) {
                                        cx += kerning.n * size;
                                        break;
                                    }
                                }
                            }
                            None => {}
                        },
                        None => {}
                    }
                    cur = next;
                }
            }
        }
    }

    pub fn handle(&mut self) -> bool {
        // handle events from canvas
        self.canvas.handle(self)
    }
}

pub struct WidgetBase<'a> {
    ui: &'a mut UI<'a>,
    fid: u32,
}

impl<'a> WidgetBase<'a> {
    pub fn new(ui: &'a mut UI<'a>,x: f32,y: f32,xs: f32,ys: f32,dx: f32,dy: f32,xx: f32,yy: f32) -> WidgetBase<'a> {
        let mut found: bool = false;
        let mut fid: usize = 0;
        for i in 0..MAX_FRAMES {
            if(ui.frames[i as usize].flags & FRAME_EXISTS) != FRAME_EXISTS {
                found = true;
                fid = i as usize;
                break;
            }
        }
        if !found {
            panic!("e: Out of frames");
        }
        ui.frames[fid] = Frame {
            x: x,
            y: y,
            xs: xs,
            ys: ys,
            dx: dx,
            dy: dy,
            xx: xx,
            yy: yy,
            parent: 0,
            flags: FRAME_EXISTS | FRAME_VISIBLE,
            padding: [0,0],
        };
        ui.update_frames_gpu();
        WidgetBase {
            ui: ui,
            fid: fid as u32,
        }
    }
}

impl<'a> Drop for WidgetBase<'a> {
    fn drop(&mut self) {
        for i in 0..MAX_FRAMES {
            if ((self.ui.frames[i as usize].flags & FRAME_EXISTS) == FRAME_EXISTS)
                && (self.ui.frames[i as usize].parent == self.fid) {
                    self.ui.frames[i as usize].parent = 0;
                }
        }
        self.ui.frames[self.fid as usize].flags &= !FRAME_EXISTS;
        self.ui.update_frames_gpu();
    }
}

impl<'a> Widget for WidgetBase<'a> {
    fn show(&mut self) {
        self.ui.frames[self.fid as usize].flags |= FRAME_VISIBLE;
        self.ui.update_frames_gpu();
    }

    fn hide(&mut self) {
        self.ui.frames[self.fid as usize].flags &= !FRAME_VISIBLE;
        self.ui.update_frames_gpu();
    }

    fn move_resize(&mut self,x: f32,y: f32,xs: f32,ys: f32) {
        self.ui.frames[self.fid as usize].x = x;
        self.ui.frames[self.fid as usize].y = y;
        self.ui.frames[self.fid as usize].xs = xs;
        self.ui.frames[self.fid as usize].ys = ys;
        self.ui.update_frames_gpu();
    }

    fn pan_zoom(&mut self,dx: f32,dy: f32,xx: f32,yy: f32) {
        self.ui.frames[self.fid as usize].dx = dx;
        self.ui.frames[self.fid as usize].dy = dy;
        self.ui.frames[self.fid as usize].xx = xx;
        self.ui.frames[self.fid as usize].yy = yy;
        self.ui.update_frames_gpu();
    }
}

impl<'a> crate::Handler for UI<'a> {
    fn draw(&self) {
        // redraw entire UI
        self.textures.bind(0);
        self.shader.bind();
        unsafe {
            gl::Enable(gl::BLEND);
            gl::BlendEquationSeparate(gl::FUNC_ADD, gl::FUNC_ADD);
            gl::BlendFuncSeparate(
                gl::SRC_ALPHA,
                gl::ONE_MINUS_SRC_ALPHA,
                gl::ONE,
                gl::ONE_MINUS_SRC_ALPHA,
            );
            gl::BindBufferBase(gl::UNIFORM_BUFFER, 0, self.ubo);
            gl::BindVertexArray(self.vao);
            gl::DrawArrays(gl::POINTS, 0, self.quads.len() as i32);
            gl::Disable(gl::BLEND);
        }
        self.canvas.swap();
    }

    fn keypress(&mut self, k: i32) {
        // a key is pressed
        println!("keypress {}", k);
    }

    fn keyrelease(&mut self, k: i32) {
        // a key is released
        println!("keyrelease {}", k);
    }

    fn mousepress(&mut self, x: i32, y: i32, b: i32) {
        // a mouse button is pressed
        println!("mousepress {},{} {}", x, y, b);
    }

    fn mouserelease(&mut self, x: i32, y: i32, b: i32) {
        // a mouse button is released
        println!("mouserelease {},{} {}", x, y, b);
    }

    fn mousemove(&mut self, x: i32, y: i32) {
        // the mouse moved
        println!("mousemove {},{}", x, y);
    }

    fn mousewheel(&mut self, dx: i32, dy: i32) {
        // a mouse wheel axis changed
        println!("mousewheel {},{}", dx, dy);
    }

    fn resize(&mut self, x: i32, y: i32) {
        // the canvas is resized, so process down through 
    }
}
