/* automatically generated by rust-bindgen 0.56.0 */

pub const VULKAN_H_: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VULKAN_CORE_H_: u32 = 1;
pub const VK_VERSION_1_0: u32 = 1;
pub const VK_HEADER_VERSION: u32 = 131;
pub const VK_NULL_HANDLE: u32 = 0;
pub const VK_LOD_CLAMP_NONE: f64 = 1000.0;
pub const VK_REMAINING_MIP_LEVELS: i32 = -1;
pub const VK_REMAINING_ARRAY_LAYERS: i32 = -1;
pub const VK_WHOLE_SIZE: i32 = -1;
pub const VK_ATTACHMENT_UNUSED: i32 = -1;
pub const VK_TRUE: u32 = 1;
pub const VK_FALSE: u32 = 0;
pub const VK_QUEUE_FAMILY_IGNORED: i32 = -1;
pub const VK_SUBPASS_EXTERNAL: i32 = -1;
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
pub const VK_UUID_SIZE: u32 = 16;
pub const VK_MAX_MEMORY_TYPES: u32 = 32;
pub const VK_MAX_MEMORY_HEAPS: u32 = 16;
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256;
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256;
pub const VK_VERSION_1_1: u32 = 1;
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32;
pub const VK_LUID_SIZE: u32 = 8;
pub const VK_QUEUE_FAMILY_EXTERNAL: i32 = -2;
pub const VK_VERSION_1_2: u32 = 1;
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256;
pub const VK_KHR_surface: u32 = 1;
pub const VK_KHR_SURFACE_SPEC_VERSION: u32 = 25;
pub const VK_KHR_SURFACE_EXTENSION_NAME: &'static [u8; 15usize] = b"VK_KHR_surface\0";
pub const VK_KHR_swapchain: u32 = 1;
pub const VK_KHR_SWAPCHAIN_SPEC_VERSION: u32 = 70;
pub const VK_KHR_SWAPCHAIN_EXTENSION_NAME: &'static [u8; 17usize] = b"VK_KHR_swapchain\0";
pub const VK_KHR_display: u32 = 1;
pub const VK_KHR_DISPLAY_SPEC_VERSION: u32 = 23;
pub const VK_KHR_DISPLAY_EXTENSION_NAME: &'static [u8; 15usize] = b"VK_KHR_display\0";
pub const VK_KHR_display_swapchain: u32 = 1;
pub const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION: u32 = 10;
pub const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_display_swapchain\0";
pub const VK_KHR_sampler_mirror_clamp_to_edge: u32 = 1;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION: u32 = 3;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_KHR_sampler_mirror_clamp_to_edge\0";
pub const VK_KHR_multiview: u32 = 1;
pub const VK_KHR_MULTIVIEW_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MULTIVIEW_EXTENSION_NAME: &'static [u8; 17usize] = b"VK_KHR_multiview\0";
pub const VK_KHR_get_physical_device_properties2: u32 = 1;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION: u32 = 2;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: &'static [u8; 39usize] =
    b"VK_KHR_get_physical_device_properties2\0";
pub const VK_KHR_device_group: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_SPEC_VERSION: u32 = 4;
pub const VK_KHR_DEVICE_GROUP_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_device_group\0";
pub const VK_KHR_shader_draw_parameters: u32 = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_KHR_shader_draw_parameters\0";
pub const VK_KHR_maintenance1: u32 = 1;
pub const VK_KHR_MAINTENANCE1_SPEC_VERSION: u32 = 2;
pub const VK_KHR_MAINTENANCE1_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_maintenance1\0";
pub const VK_KHR_device_group_creation: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_device_group_creation\0";
pub const VK_MAX_DEVICE_GROUP_SIZE_KHR: u32 = 32;
pub const VK_KHR_external_memory_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_KHR_external_memory_capabilities\0";
pub const VK_LUID_SIZE_KHR: u32 = 8;
pub const VK_KHR_external_memory: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_KHR_external_memory\0";
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR: i32 = -2;
pub const VK_KHR_external_memory_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_external_memory_fd\0";
pub const VK_KHR_external_semaphore_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: &'static [u8; 39usize] =
    b"VK_KHR_external_semaphore_capabilities\0";
pub const VK_KHR_external_semaphore: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_external_semaphore\0";
pub const VK_KHR_external_semaphore_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_external_semaphore_fd\0";
pub const VK_KHR_push_descriptor: u32 = 1;
pub const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION: u32 = 2;
pub const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_KHR_push_descriptor\0";
pub const VK_KHR_shader_float16_int8: u32 = 1;
pub const VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_shader_float16_int8\0";
pub const VK_KHR_16bit_storage: u32 = 1;
pub const VK_KHR_16BIT_STORAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_16BIT_STORAGE_EXTENSION_NAME: &'static [u8; 21usize] = b"VK_KHR_16bit_storage\0";
pub const VK_KHR_incremental_present: u32 = 1;
pub const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_incremental_present\0";
pub const VK_KHR_descriptor_update_template: u32 = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_KHR_descriptor_update_template\0";
pub const VK_KHR_imageless_framebuffer: u32 = 1;
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION: u32 = 1;
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_imageless_framebuffer\0";
pub const VK_KHR_create_renderpass2: u32 = 1;
pub const VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_create_renderpass2\0";
pub const VK_KHR_shared_presentable_image: u32 = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_KHR_shared_presentable_image\0";
pub const VK_KHR_external_fence_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_KHR_external_fence_capabilities\0";
pub const VK_KHR_external_fence: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME: &'static [u8; 22usize] = b"VK_KHR_external_fence\0";
pub const VK_KHR_external_fence_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_external_fence_fd\0";
pub const VK_KHR_performance_query: u32 = 1;
pub const VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_performance_query\0";
pub const VK_KHR_maintenance2: u32 = 1;
pub const VK_KHR_MAINTENANCE2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE2_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_maintenance2\0";
pub const VK_KHR_get_surface_capabilities2: u32 = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_KHR_get_surface_capabilities2\0";
pub const VK_KHR_variable_pointers: u32 = 1;
pub const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_variable_pointers\0";
pub const VK_KHR_get_display_properties2: u32 = 1;
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME: &'static [u8; 31usize] =
    b"VK_KHR_get_display_properties2\0";
pub const VK_KHR_dedicated_allocation: u32 = 1;
pub const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION: u32 = 3;
pub const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_KHR_dedicated_allocation\0";
pub const VK_KHR_storage_buffer_storage_class: u32 = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_KHR_storage_buffer_storage_class\0";
pub const VK_KHR_relaxed_block_layout: u32 = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_KHR_relaxed_block_layout\0";
pub const VK_KHR_get_memory_requirements2: u32 = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_KHR_get_memory_requirements2\0";
pub const VK_KHR_image_format_list: u32 = 1;
pub const VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION: u32 = 1;
pub const VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_image_format_list\0";
pub const VK_KHR_sampler_ycbcr_conversion: u32 = 1;
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION: u32 = 14;
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_KHR_sampler_ycbcr_conversion\0";
pub const VK_KHR_bind_memory2: u32 = 1;
pub const VK_KHR_BIND_MEMORY_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_BIND_MEMORY_2_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_bind_memory2\0";
pub const VK_KHR_maintenance3: u32 = 1;
pub const VK_KHR_MAINTENANCE3_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE3_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_maintenance3\0";
pub const VK_KHR_draw_indirect_count: u32 = 1;
pub const VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_draw_indirect_count\0";
pub const VK_KHR_shader_subgroup_extended_types: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_KHR_shader_subgroup_extended_types\0";
pub const VK_KHR_8bit_storage: u32 = 1;
pub const VK_KHR_8BIT_STORAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_8BIT_STORAGE_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_8bit_storage\0";
pub const VK_KHR_shader_atomic_int64: u32 = 1;
pub const VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_shader_atomic_int64\0";
pub const VK_KHR_shader_clock: u32 = 1;
pub const VK_KHR_SHADER_CLOCK_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_CLOCK_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_KHR_shader_clock\0";
pub const VK_KHR_driver_properties: u32 = 1;
pub const VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_driver_properties\0";
pub const VK_MAX_DRIVER_NAME_SIZE_KHR: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE_KHR: u32 = 256;
pub const VK_KHR_shader_float_controls: u32 = 1;
pub const VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION: u32 = 4;
pub const VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_shader_float_controls\0";
pub const VK_KHR_depth_stencil_resolve: u32 = 1;
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_depth_stencil_resolve\0";
pub const VK_KHR_swapchain_mutable_format: u32 = 1;
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_KHR_swapchain_mutable_format\0";
pub const VK_KHR_timeline_semaphore: u32 = 1;
pub const VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION: u32 = 2;
pub const VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_timeline_semaphore\0";
pub const VK_KHR_vulkan_memory_model: u32 = 1;
pub const VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION: u32 = 3;
pub const VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_vulkan_memory_model\0";
pub const VK_KHR_spirv_1_4: u32 = 1;
pub const VK_KHR_SPIRV_1_4_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SPIRV_1_4_EXTENSION_NAME: &'static [u8; 17usize] = b"VK_KHR_spirv_1_4\0";
pub const VK_KHR_surface_protected_capabilities: u32 = 1;
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_KHR_surface_protected_capabilities\0";
pub const VK_KHR_separate_depth_stencil_layouts: u32 = 1;
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_KHR_separate_depth_stencil_layouts\0";
pub const VK_KHR_uniform_buffer_standard_layout: u32 = 1;
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_KHR_uniform_buffer_standard_layout\0";
pub const VK_KHR_buffer_device_address: u32 = 1;
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_KHR_buffer_device_address\0";
pub const VK_KHR_pipeline_executable_properties: u32 = 1;
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_KHR_pipeline_executable_properties\0";
pub const VK_EXT_debug_report: u32 = 1;
pub const VK_EXT_DEBUG_REPORT_SPEC_VERSION: u32 = 9;
pub const VK_EXT_DEBUG_REPORT_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_debug_report\0";
pub const VK_NV_glsl_shader: u32 = 1;
pub const VK_NV_GLSL_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_NV_GLSL_SHADER_EXTENSION_NAME: &'static [u8; 18usize] = b"VK_NV_glsl_shader\0";
pub const VK_EXT_depth_range_unrestricted: u32 = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_EXT_depth_range_unrestricted\0";
pub const VK_IMG_filter_cubic: u32 = 1;
pub const VK_IMG_FILTER_CUBIC_SPEC_VERSION: u32 = 1;
pub const VK_IMG_FILTER_CUBIC_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_IMG_filter_cubic\0";
pub const VK_AMD_rasterization_order: u32 = 1;
pub const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_AMD_rasterization_order\0";
pub const VK_AMD_shader_trinary_minmax: u32 = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_AMD_shader_trinary_minmax\0";
pub const VK_AMD_shader_explicit_vertex_parameter: u32 = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME: &'static [u8; 40usize] =
    b"VK_AMD_shader_explicit_vertex_parameter\0";
pub const VK_EXT_debug_marker: u32 = 1;
pub const VK_EXT_DEBUG_MARKER_SPEC_VERSION: u32 = 4;
pub const VK_EXT_DEBUG_MARKER_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_debug_marker\0";
pub const VK_AMD_gcn_shader: u32 = 1;
pub const VK_AMD_GCN_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_GCN_SHADER_EXTENSION_NAME: &'static [u8; 18usize] = b"VK_AMD_gcn_shader\0";
pub const VK_NV_dedicated_allocation: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_NV_dedicated_allocation\0";
pub const VK_EXT_transform_feedback: u32 = 1;
pub const VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_EXT_transform_feedback\0";
pub const VK_NVX_image_view_handle: u32 = 1;
pub const VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION: u32 = 1;
pub const VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_NVX_image_view_handle\0";
pub const VK_AMD_draw_indirect_count: u32 = 1;
pub const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION: u32 = 2;
pub const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_AMD_draw_indirect_count\0";
pub const VK_AMD_negative_viewport_height: u32 = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION: u32 = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_AMD_negative_viewport_height\0";
pub const VK_AMD_gpu_shader_half_float: u32 = 1;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION: u32 = 2;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_AMD_gpu_shader_half_float\0";
pub const VK_AMD_shader_ballot: u32 = 1;
pub const VK_AMD_SHADER_BALLOT_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_BALLOT_EXTENSION_NAME: &'static [u8; 21usize] = b"VK_AMD_shader_ballot\0";
pub const VK_AMD_texture_gather_bias_lod: u32 = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION: u32 = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME: &'static [u8; 31usize] =
    b"VK_AMD_texture_gather_bias_lod\0";
pub const VK_AMD_shader_info: u32 = 1;
pub const VK_AMD_SHADER_INFO_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_INFO_EXTENSION_NAME: &'static [u8; 19usize] = b"VK_AMD_shader_info\0";
pub const VK_AMD_shader_image_load_store_lod: u32 = 1;
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_AMD_shader_image_load_store_lod\0";
pub const VK_NV_corner_sampled_image: u32 = 1;
pub const VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION: u32 = 2;
pub const VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_NV_corner_sampled_image\0";
pub const VK_IMG_format_pvrtc: u32 = 1;
pub const VK_IMG_FORMAT_PVRTC_SPEC_VERSION: u32 = 1;
pub const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_IMG_format_pvrtc\0";
pub const VK_NV_external_memory_capabilities: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_NV_external_memory_capabilities\0";
pub const VK_NV_external_memory: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME: &'static [u8; 22usize] = b"VK_NV_external_memory\0";
pub const VK_EXT_validation_flags: u32 = 1;
pub const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_validation_flags\0";
pub const VK_EXT_shader_subgroup_ballot: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_EXT_shader_subgroup_ballot\0";
pub const VK_EXT_shader_subgroup_vote: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_shader_subgroup_vote\0";
pub const VK_EXT_texture_compression_astc_hdr: u32 = 1;
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_EXT_texture_compression_astc_hdr\0";
pub const VK_EXT_astc_decode_mode: u32 = 1;
pub const VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_astc_decode_mode\0";
pub const VK_EXT_conditional_rendering: u32 = 1;
pub const VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION: u32 = 2;
pub const VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_conditional_rendering\0";
pub const VK_NVX_device_generated_commands: u32 = 1;
pub const VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION: u32 = 3;
pub const VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_NVX_device_generated_commands\0";
pub const VK_NV_clip_space_w_scaling: u32 = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION: u32 = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_NV_clip_space_w_scaling\0";
pub const VK_EXT_direct_mode_display: u32 = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_direct_mode_display\0";
pub const VK_EXT_display_surface_counter: u32 = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME: &'static [u8; 31usize] =
    b"VK_EXT_display_surface_counter\0";
pub const VK_EXT_display_control: u32 = 1;
pub const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_EXT_display_control\0";
pub const VK_GOOGLE_display_timing: u32 = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_GOOGLE_display_timing\0";
pub const VK_NV_sample_mask_override_coverage: u32 = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION: u32 = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_NV_sample_mask_override_coverage\0";
pub const VK_NV_geometry_shader_passthrough: u32 = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION: u32 = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_NV_geometry_shader_passthrough\0";
pub const VK_NV_viewport_array2: u32 = 1;
pub const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION: u32 = 1;
pub const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME: &'static [u8; 22usize] = b"VK_NV_viewport_array2\0";
pub const VK_NVX_multiview_per_view_attributes: u32 = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION: u32 = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: &'static [u8; 37usize] =
    b"VK_NVX_multiview_per_view_attributes\0";
pub const VK_NV_viewport_swizzle: u32 = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION: u32 = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_NV_viewport_swizzle\0";
pub const VK_EXT_discard_rectangles: u32 = 1;
pub const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_EXT_discard_rectangles\0";
pub const VK_EXT_conservative_rasterization: u32 = 1;
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_EXT_conservative_rasterization\0";
pub const VK_EXT_depth_clip_enable: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_EXT_depth_clip_enable\0";
pub const VK_EXT_swapchain_colorspace: u32 = 1;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION: u32 = 4;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_swapchain_colorspace\0";
pub const VK_EXT_hdr_metadata: u32 = 1;
pub const VK_EXT_HDR_METADATA_SPEC_VERSION: u32 = 2;
pub const VK_EXT_HDR_METADATA_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_hdr_metadata\0";
pub const VK_EXT_external_memory_dma_buf: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME: &'static [u8; 31usize] =
    b"VK_EXT_external_memory_dma_buf\0";
pub const VK_EXT_queue_family_foreign: u32 = 1;
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION: u32 = 1;
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_queue_family_foreign\0";
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: i32 = -3;
pub const VK_EXT_debug_utils: u32 = 1;
pub const VK_EXT_DEBUG_UTILS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEBUG_UTILS_EXTENSION_NAME: &'static [u8; 19usize] = b"VK_EXT_debug_utils\0";
pub const VK_EXT_sampler_filter_minmax: u32 = 1;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION: u32 = 2;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_sampler_filter_minmax\0";
pub const VK_AMD_gpu_shader_int16: u32 = 1;
pub const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION: u32 = 2;
pub const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_AMD_gpu_shader_int16\0";
pub const VK_AMD_mixed_attachment_samples: u32 = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION: u32 = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_AMD_mixed_attachment_samples\0";
pub const VK_AMD_shader_fragment_mask: u32 = 1;
pub const VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_AMD_shader_fragment_mask\0";
pub const VK_EXT_inline_uniform_block: u32 = 1;
pub const VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_inline_uniform_block\0";
pub const VK_EXT_shader_stencil_export: u32 = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_shader_stencil_export\0";
pub const VK_EXT_sample_locations: u32 = 1;
pub const VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_sample_locations\0";
pub const VK_EXT_blend_operation_advanced: u32 = 1;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION: u32 = 2;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_EXT_blend_operation_advanced\0";
pub const VK_NV_fragment_coverage_to_color: u32 = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_NV_fragment_coverage_to_color\0";
pub const VK_NV_framebuffer_mixed_samples: u32 = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_NV_framebuffer_mixed_samples\0";
pub const VK_NV_fill_rectangle: u32 = 1;
pub const VK_NV_FILL_RECTANGLE_SPEC_VERSION: u32 = 1;
pub const VK_NV_FILL_RECTANGLE_EXTENSION_NAME: &'static [u8; 21usize] = b"VK_NV_fill_rectangle\0";
pub const VK_NV_shader_sm_builtins: u32 = 1;
pub const VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION: u32 = 1;
pub const VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_NV_shader_sm_builtins\0";
pub const VK_EXT_post_depth_coverage: u32 = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_post_depth_coverage\0";
pub const VK_EXT_image_drm_format_modifier: u32 = 1;
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_EXT_image_drm_format_modifier\0";
pub const VK_EXT_validation_cache: u32 = 1;
pub const VK_EXT_VALIDATION_CACHE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_VALIDATION_CACHE_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_validation_cache\0";
pub const VK_EXT_descriptor_indexing: u32 = 1;
pub const VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION: u32 = 2;
pub const VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_descriptor_indexing\0";
pub const VK_EXT_shader_viewport_index_layer: u32 = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_EXT_shader_viewport_index_layer\0";
pub const VK_NV_shading_rate_image: u32 = 1;
pub const VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION: u32 = 3;
pub const VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_NV_shading_rate_image\0";
pub const VK_NV_ray_tracing: u32 = 1;
pub const VK_NV_RAY_TRACING_SPEC_VERSION: u32 = 3;
pub const VK_NV_RAY_TRACING_EXTENSION_NAME: &'static [u8; 18usize] = b"VK_NV_ray_tracing\0";
pub const VK_SHADER_UNUSED_NV: i32 = -1;
pub const VK_NV_representative_fragment_test: u32 = 1;
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION: u32 = 2;
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_NV_representative_fragment_test\0";
pub const VK_EXT_filter_cubic: u32 = 1;
pub const VK_EXT_FILTER_CUBIC_SPEC_VERSION: u32 = 3;
pub const VK_EXT_FILTER_CUBIC_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_filter_cubic\0";
pub const VK_EXT_global_priority: u32 = 1;
pub const VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION: u32 = 2;
pub const VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_EXT_global_priority\0";
pub const VK_EXT_external_memory_host: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_external_memory_host\0";
pub const VK_AMD_buffer_marker: u32 = 1;
pub const VK_AMD_BUFFER_MARKER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_BUFFER_MARKER_EXTENSION_NAME: &'static [u8; 21usize] = b"VK_AMD_buffer_marker\0";
pub const VK_AMD_pipeline_compiler_control: u32 = 1;
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_AMD_pipeline_compiler_control\0";
pub const VK_EXT_calibrated_timestamps: u32 = 1;
pub const VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_calibrated_timestamps\0";
pub const VK_AMD_shader_core_properties: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION: u32 = 2;
pub const VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_AMD_shader_core_properties\0";
pub const VK_AMD_memory_overallocation_behavior: u32 = 1;
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION: u32 = 1;
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: &'static [u8; 38usize] =
    b"VK_AMD_memory_overallocation_behavior\0";
pub const VK_EXT_vertex_attribute_divisor: u32 = 1;
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION: u32 = 3;
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME: &'static [u8; 32usize] =
    b"VK_EXT_vertex_attribute_divisor\0";
pub const VK_EXT_pipeline_creation_feedback: u32 = 1;
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_EXT_pipeline_creation_feedback\0";
pub const VK_NV_shader_subgroup_partitioned: u32 = 1;
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION: u32 = 1;
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_NV_shader_subgroup_partitioned\0";
pub const VK_NV_compute_shader_derivatives: u32 = 1;
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION: u32 = 1;
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_NV_compute_shader_derivatives\0";
pub const VK_NV_mesh_shader: u32 = 1;
pub const VK_NV_MESH_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_NV_MESH_SHADER_EXTENSION_NAME: &'static [u8; 18usize] = b"VK_NV_mesh_shader\0";
pub const VK_NV_fragment_shader_barycentric: u32 = 1;
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: &'static [u8; 34usize] =
    b"VK_NV_fragment_shader_barycentric\0";
pub const VK_NV_shader_image_footprint: u32 = 1;
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION: u32 = 2;
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_NV_shader_image_footprint\0";
pub const VK_NV_scissor_exclusive: u32 = 1;
pub const VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION: u32 = 1;
pub const VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_NV_scissor_exclusive\0";
pub const VK_NV_device_diagnostic_checkpoints: u32 = 1;
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION: u32 = 2;
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: &'static [u8; 36usize] =
    b"VK_NV_device_diagnostic_checkpoints\0";
pub const VK_INTEL_shader_integer_functions2: u32 = 1;
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION: u32 = 1;
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME: &'static [u8; 35usize] =
    b"VK_INTEL_shader_integer_functions2\0";
pub const VK_INTEL_performance_query: u32 = 1;
pub const VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_INTEL_performance_query\0";
pub const VK_EXT_pci_bus_info: u32 = 1;
pub const VK_EXT_PCI_BUS_INFO_SPEC_VERSION: u32 = 2;
pub const VK_EXT_PCI_BUS_INFO_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_pci_bus_info\0";
pub const VK_AMD_display_native_hdr: u32 = 1;
pub const VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION: u32 = 1;
pub const VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_AMD_display_native_hdr\0";
pub const VK_EXT_fragment_density_map: u32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION: u32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_fragment_density_map\0";
pub const VK_EXT_scalar_block_layout: u32 = 1;
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_scalar_block_layout\0";
pub const VK_GOOGLE_hlsl_functionality1: u32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_GOOGLE_hlsl_functionality1\0";
pub const VK_GOOGLE_decorate_string: u32 = 1;
pub const VK_GOOGLE_DECORATE_STRING_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_GOOGLE_decorate_string\0";
pub const VK_EXT_subgroup_size_control: u32 = 1;
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION: u32 = 2;
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_subgroup_size_control\0";
pub const VK_AMD_shader_core_properties2: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME: &'static [u8; 31usize] =
    b"VK_AMD_shader_core_properties2\0";
pub const VK_AMD_device_coherent_memory: u32 = 1;
pub const VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_AMD_device_coherent_memory\0";
pub const VK_EXT_memory_budget: u32 = 1;
pub const VK_EXT_MEMORY_BUDGET_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MEMORY_BUDGET_EXTENSION_NAME: &'static [u8; 21usize] = b"VK_EXT_memory_budget\0";
pub const VK_EXT_memory_priority: u32 = 1;
pub const VK_EXT_MEMORY_PRIORITY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_EXT_memory_priority\0";
pub const VK_NV_dedicated_allocation_image_aliasing: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME: &'static [u8; 42usize] =
    b"VK_NV_dedicated_allocation_image_aliasing\0";
pub const VK_EXT_buffer_device_address: u32 = 1;
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: &'static [u8; 29usize] =
    b"VK_EXT_buffer_device_address\0";
pub const VK_EXT_tooling_info: u32 = 1;
pub const VK_EXT_TOOLING_INFO_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TOOLING_INFO_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_EXT_tooling_info\0";
pub const VK_EXT_separate_stencil_usage: u32 = 1;
pub const VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_EXT_separate_stencil_usage\0";
pub const VK_EXT_validation_features: u32 = 1;
pub const VK_EXT_VALIDATION_FEATURES_SPEC_VERSION: u32 = 2;
pub const VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_validation_features\0";
pub const VK_NV_cooperative_matrix: u32 = 1;
pub const VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION: u32 = 1;
pub const VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_NV_cooperative_matrix\0";
pub const VK_NV_coverage_reduction_mode: u32 = 1;
pub const VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION: u32 = 1;
pub const VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_NV_coverage_reduction_mode\0";
pub const VK_EXT_fragment_shader_interlock: u32 = 1;
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME: &'static [u8; 33usize] =
    b"VK_EXT_fragment_shader_interlock\0";
pub const VK_EXT_ycbcr_image_arrays: u32 = 1;
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_EXT_ycbcr_image_arrays\0";
pub const VK_EXT_headless_surface: u32 = 1;
pub const VK_EXT_HEADLESS_SURFACE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_headless_surface\0";
pub const VK_EXT_line_rasterization: u32 = 1;
pub const VK_EXT_LINE_RASTERIZATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_EXT_line_rasterization\0";
pub const VK_EXT_host_query_reset: u32 = 1;
pub const VK_EXT_HOST_QUERY_RESET_SPEC_VERSION: u32 = 1;
pub const VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_host_query_reset\0";
pub const VK_EXT_index_type_uint8: u32 = 1;
pub const VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION: u32 = 1;
pub const VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_index_type_uint8\0";
pub const VK_EXT_shader_demote_to_helper_invocation: u32 = 1;
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME: &'static [u8; 42usize] =
    b"VK_EXT_shader_demote_to_helper_invocation\0";
pub const VK_EXT_texel_buffer_alignment: u32 = 1;
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME: &'static [u8; 30usize] =
    b"VK_EXT_texel_buffer_alignment\0";
pub const VK_GOOGLE_user_type: u32 = 1;
pub const VK_GOOGLE_USER_TYPE_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_USER_TYPE_EXTENSION_NAME: &'static [u8; 20usize] = b"VK_GOOGLE_user_type\0";
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const X_TCP_PORT: u32 = 6000;
pub const XCB_CONN_ERROR: u32 = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: u32 = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: u32 = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: u32 = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: u32 = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: u32 = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: u32 = 7;
pub const XCB_KEY_PRESS: u32 = 2;
pub const XCB_KEY_RELEASE: u32 = 3;
pub const XCB_BUTTON_PRESS: u32 = 4;
pub const XCB_BUTTON_RELEASE: u32 = 5;
pub const XCB_MOTION_NOTIFY: u32 = 6;
pub const XCB_ENTER_NOTIFY: u32 = 7;
pub const XCB_LEAVE_NOTIFY: u32 = 8;
pub const XCB_FOCUS_IN: u32 = 9;
pub const XCB_FOCUS_OUT: u32 = 10;
pub const XCB_KEYMAP_NOTIFY: u32 = 11;
pub const XCB_EXPOSE: u32 = 12;
pub const XCB_GRAPHICS_EXPOSURE: u32 = 13;
pub const XCB_NO_EXPOSURE: u32 = 14;
pub const XCB_VISIBILITY_NOTIFY: u32 = 15;
pub const XCB_CREATE_NOTIFY: u32 = 16;
pub const XCB_DESTROY_NOTIFY: u32 = 17;
pub const XCB_UNMAP_NOTIFY: u32 = 18;
pub const XCB_MAP_NOTIFY: u32 = 19;
pub const XCB_MAP_REQUEST: u32 = 20;
pub const XCB_REPARENT_NOTIFY: u32 = 21;
pub const XCB_CONFIGURE_NOTIFY: u32 = 22;
pub const XCB_CONFIGURE_REQUEST: u32 = 23;
pub const XCB_GRAVITY_NOTIFY: u32 = 24;
pub const XCB_RESIZE_REQUEST: u32 = 25;
pub const XCB_CIRCULATE_NOTIFY: u32 = 26;
pub const XCB_CIRCULATE_REQUEST: u32 = 27;
pub const XCB_PROPERTY_NOTIFY: u32 = 28;
pub const XCB_SELECTION_CLEAR: u32 = 29;
pub const XCB_SELECTION_REQUEST: u32 = 30;
pub const XCB_SELECTION_NOTIFY: u32 = 31;
pub const XCB_COLORMAP_NOTIFY: u32 = 32;
pub const XCB_CLIENT_MESSAGE: u32 = 33;
pub const XCB_MAPPING_NOTIFY: u32 = 34;
pub const XCB_GE_GENERIC: u32 = 35;
pub const XCB_REQUEST: u32 = 1;
pub const XCB_VALUE: u32 = 2;
pub const XCB_WINDOW: u32 = 3;
pub const XCB_PIXMAP: u32 = 4;
pub const XCB_ATOM: u32 = 5;
pub const XCB_CURSOR: u32 = 6;
pub const XCB_FONT: u32 = 7;
pub const XCB_MATCH: u32 = 8;
pub const XCB_DRAWABLE: u32 = 9;
pub const XCB_ACCESS: u32 = 10;
pub const XCB_ALLOC: u32 = 11;
pub const XCB_COLORMAP: u32 = 12;
pub const XCB_G_CONTEXT: u32 = 13;
pub const XCB_ID_CHOICE: u32 = 14;
pub const XCB_NAME: u32 = 15;
pub const XCB_LENGTH: u32 = 16;
pub const XCB_IMPLEMENTATION: u32 = 17;
pub const XCB_CREATE_WINDOW: u32 = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: u32 = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: u32 = 3;
pub const XCB_DESTROY_WINDOW: u32 = 4;
pub const XCB_DESTROY_SUBWINDOWS: u32 = 5;
pub const XCB_CHANGE_SAVE_SET: u32 = 6;
pub const XCB_REPARENT_WINDOW: u32 = 7;
pub const XCB_MAP_WINDOW: u32 = 8;
pub const XCB_MAP_SUBWINDOWS: u32 = 9;
pub const XCB_UNMAP_WINDOW: u32 = 10;
pub const XCB_UNMAP_SUBWINDOWS: u32 = 11;
pub const XCB_CONFIGURE_WINDOW: u32 = 12;
pub const XCB_CIRCULATE_WINDOW: u32 = 13;
pub const XCB_GET_GEOMETRY: u32 = 14;
pub const XCB_QUERY_TREE: u32 = 15;
pub const XCB_INTERN_ATOM: u32 = 16;
pub const XCB_GET_ATOM_NAME: u32 = 17;
pub const XCB_CHANGE_PROPERTY: u32 = 18;
pub const XCB_DELETE_PROPERTY: u32 = 19;
pub const XCB_GET_PROPERTY: u32 = 20;
pub const XCB_LIST_PROPERTIES: u32 = 21;
pub const XCB_SET_SELECTION_OWNER: u32 = 22;
pub const XCB_GET_SELECTION_OWNER: u32 = 23;
pub const XCB_CONVERT_SELECTION: u32 = 24;
pub const XCB_SEND_EVENT: u32 = 25;
pub const XCB_GRAB_POINTER: u32 = 26;
pub const XCB_UNGRAB_POINTER: u32 = 27;
pub const XCB_GRAB_BUTTON: u32 = 28;
pub const XCB_UNGRAB_BUTTON: u32 = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: u32 = 30;
pub const XCB_GRAB_KEYBOARD: u32 = 31;
pub const XCB_UNGRAB_KEYBOARD: u32 = 32;
pub const XCB_GRAB_KEY: u32 = 33;
pub const XCB_UNGRAB_KEY: u32 = 34;
pub const XCB_ALLOW_EVENTS: u32 = 35;
pub const XCB_GRAB_SERVER: u32 = 36;
pub const XCB_UNGRAB_SERVER: u32 = 37;
pub const XCB_QUERY_POINTER: u32 = 38;
pub const XCB_GET_MOTION_EVENTS: u32 = 39;
pub const XCB_TRANSLATE_COORDINATES: u32 = 40;
pub const XCB_WARP_POINTER: u32 = 41;
pub const XCB_SET_INPUT_FOCUS: u32 = 42;
pub const XCB_GET_INPUT_FOCUS: u32 = 43;
pub const XCB_QUERY_KEYMAP: u32 = 44;
pub const XCB_OPEN_FONT: u32 = 45;
pub const XCB_CLOSE_FONT: u32 = 46;
pub const XCB_QUERY_FONT: u32 = 47;
pub const XCB_QUERY_TEXT_EXTENTS: u32 = 48;
pub const XCB_LIST_FONTS: u32 = 49;
pub const XCB_LIST_FONTS_WITH_INFO: u32 = 50;
pub const XCB_SET_FONT_PATH: u32 = 51;
pub const XCB_GET_FONT_PATH: u32 = 52;
pub const XCB_CREATE_PIXMAP: u32 = 53;
pub const XCB_FREE_PIXMAP: u32 = 54;
pub const XCB_CREATE_GC: u32 = 55;
pub const XCB_CHANGE_GC: u32 = 56;
pub const XCB_COPY_GC: u32 = 57;
pub const XCB_SET_DASHES: u32 = 58;
pub const XCB_SET_CLIP_RECTANGLES: u32 = 59;
pub const XCB_FREE_GC: u32 = 60;
pub const XCB_CLEAR_AREA: u32 = 61;
pub const XCB_COPY_AREA: u32 = 62;
pub const XCB_COPY_PLANE: u32 = 63;
pub const XCB_POLY_POINT: u32 = 64;
pub const XCB_POLY_LINE: u32 = 65;
pub const XCB_POLY_SEGMENT: u32 = 66;
pub const XCB_POLY_RECTANGLE: u32 = 67;
pub const XCB_POLY_ARC: u32 = 68;
pub const XCB_FILL_POLY: u32 = 69;
pub const XCB_POLY_FILL_RECTANGLE: u32 = 70;
pub const XCB_POLY_FILL_ARC: u32 = 71;
pub const XCB_PUT_IMAGE: u32 = 72;
pub const XCB_GET_IMAGE: u32 = 73;
pub const XCB_POLY_TEXT_8: u32 = 74;
pub const XCB_POLY_TEXT_16: u32 = 75;
pub const XCB_IMAGE_TEXT_8: u32 = 76;
pub const XCB_IMAGE_TEXT_16: u32 = 77;
pub const XCB_CREATE_COLORMAP: u32 = 78;
pub const XCB_FREE_COLORMAP: u32 = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: u32 = 80;
pub const XCB_INSTALL_COLORMAP: u32 = 81;
pub const XCB_UNINSTALL_COLORMAP: u32 = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: u32 = 83;
pub const XCB_ALLOC_COLOR: u32 = 84;
pub const XCB_ALLOC_NAMED_COLOR: u32 = 85;
pub const XCB_ALLOC_COLOR_CELLS: u32 = 86;
pub const XCB_ALLOC_COLOR_PLANES: u32 = 87;
pub const XCB_FREE_COLORS: u32 = 88;
pub const XCB_STORE_COLORS: u32 = 89;
pub const XCB_STORE_NAMED_COLOR: u32 = 90;
pub const XCB_QUERY_COLORS: u32 = 91;
pub const XCB_LOOKUP_COLOR: u32 = 92;
pub const XCB_CREATE_CURSOR: u32 = 93;
pub const XCB_CREATE_GLYPH_CURSOR: u32 = 94;
pub const XCB_FREE_CURSOR: u32 = 95;
pub const XCB_RECOLOR_CURSOR: u32 = 96;
pub const XCB_QUERY_BEST_SIZE: u32 = 97;
pub const XCB_QUERY_EXTENSION: u32 = 98;
pub const XCB_LIST_EXTENSIONS: u32 = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: u32 = 100;
pub const XCB_GET_KEYBOARD_MAPPING: u32 = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: u32 = 102;
pub const XCB_GET_KEYBOARD_CONTROL: u32 = 103;
pub const XCB_BELL: u32 = 104;
pub const XCB_CHANGE_POINTER_CONTROL: u32 = 105;
pub const XCB_GET_POINTER_CONTROL: u32 = 106;
pub const XCB_SET_SCREEN_SAVER: u32 = 107;
pub const XCB_GET_SCREEN_SAVER: u32 = 108;
pub const XCB_CHANGE_HOSTS: u32 = 109;
pub const XCB_LIST_HOSTS: u32 = 110;
pub const XCB_SET_ACCESS_CONTROL: u32 = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: u32 = 112;
pub const XCB_KILL_CLIENT: u32 = 113;
pub const XCB_ROTATE_PROPERTIES: u32 = 114;
pub const XCB_FORCE_SCREEN_SAVER: u32 = 115;
pub const XCB_SET_POINTER_MAPPING: u32 = 116;
pub const XCB_GET_POINTER_MAPPING: u32 = 117;
pub const XCB_SET_MODIFIER_MAPPING: u32 = 118;
pub const XCB_GET_MODIFIER_MAPPING: u32 = 119;
pub const XCB_NO_OPERATION: u32 = 127;
pub const XCB_NONE: u32 = 0;
pub const XCB_COPY_FROM_PARENT: u32 = 0;
pub const XCB_CURRENT_TIME: u32 = 0;
pub const XCB_NO_SYMBOL: u32 = 0;
pub const VULKAN_XCB_H_: u32 = 1;
pub const VK_KHR_xcb_surface: u32 = 1;
pub const VK_KHR_XCB_SURFACE_SPEC_VERSION: u32 = 6;
pub const VK_KHR_XCB_SURFACE_EXTENSION_NAME: &'static [u8; 19usize] = b"VK_KHR_xcb_surface\0";
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type VkFlags = u32;
pub type VkBool32 = u32;
pub type VkDeviceSize = u64;
pub type VkSampleMask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueue_T {
    _unused: [u8; 0],
}
pub type VkQueue = *mut VkQueue_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphore_T {
    _unused: [u8; 0],
}
pub type VkSemaphore = *mut VkSemaphore_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFence_T {
    _unused: [u8; 0],
}
pub type VkFence = *mut VkFence_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemory_T {
    _unused: [u8; 0],
}
pub type VkDeviceMemory = *mut VkDeviceMemory_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkEvent_T {
    _unused: [u8; 0],
}
pub type VkEvent = *mut VkEvent_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPool_T {
    _unused: [u8; 0],
}
pub type VkQueryPool = *mut VkQueryPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferView_T {
    _unused: [u8; 0],
}
pub type VkBufferView = *mut VkBufferView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageView_T {
    _unused: [u8; 0],
}
pub type VkImageView = *mut VkImageView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModule_T {
    _unused: [u8; 0],
}
pub type VkShaderModule = *mut VkShaderModule_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCache_T {
    _unused: [u8; 0],
}
pub type VkPipelineCache = *mut VkPipelineCache_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLayout_T {
    _unused: [u8; 0],
}
pub type VkPipelineLayout = *mut VkPipelineLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPass_T {
    _unused: [u8; 0],
}
pub type VkRenderPass = *mut VkRenderPass_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipeline_T {
    _unused: [u8; 0],
}
pub type VkPipeline = *mut VkPipeline_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayout_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSetLayout = *mut VkDescriptorSetLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampler_T {
    _unused: [u8; 0],
}
pub type VkSampler = *mut VkSampler_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPool_T {
    _unused: [u8; 0],
}
pub type VkDescriptorPool = *mut VkDescriptorPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSet_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSet = *mut VkDescriptorSet_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebuffer_T {
    _unused: [u8; 0],
}
pub type VkFramebuffer = *mut VkFramebuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandPool_T {
    _unused: [u8; 0],
}
pub type VkCommandPool = *mut VkCommandPool_T;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_ONE:
    VkPipelineCacheHeaderVersion = 1;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE:
    VkPipelineCacheHeaderVersion = 1;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE:
    VkPipelineCacheHeaderVersion = 1;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE:
    VkPipelineCacheHeaderVersion = 1;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM:
    VkPipelineCacheHeaderVersion = 2147483647;
pub type VkPipelineCacheHeaderVersion = ::std::os::raw::c_uint;
pub const VkResult_VK_SUCCESS: VkResult = 0;
pub const VkResult_VK_NOT_READY: VkResult = 1;
pub const VkResult_VK_TIMEOUT: VkResult = 2;
pub const VkResult_VK_EVENT_SET: VkResult = 3;
pub const VkResult_VK_EVENT_RESET: VkResult = 4;
pub const VkResult_VK_INCOMPLETE: VkResult = 5;
pub const VkResult_VK_ERROR_OUT_OF_HOST_MEMORY: VkResult = -1;
pub const VkResult_VK_ERROR_OUT_OF_DEVICE_MEMORY: VkResult = -2;
pub const VkResult_VK_ERROR_INITIALIZATION_FAILED: VkResult = -3;
pub const VkResult_VK_ERROR_DEVICE_LOST: VkResult = -4;
pub const VkResult_VK_ERROR_MEMORY_MAP_FAILED: VkResult = -5;
pub const VkResult_VK_ERROR_LAYER_NOT_PRESENT: VkResult = -6;
pub const VkResult_VK_ERROR_EXTENSION_NOT_PRESENT: VkResult = -7;
pub const VkResult_VK_ERROR_FEATURE_NOT_PRESENT: VkResult = -8;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DRIVER: VkResult = -9;
pub const VkResult_VK_ERROR_TOO_MANY_OBJECTS: VkResult = -10;
pub const VkResult_VK_ERROR_FORMAT_NOT_SUPPORTED: VkResult = -11;
pub const VkResult_VK_ERROR_FRAGMENTED_POOL: VkResult = -12;
pub const VkResult_VK_ERROR_UNKNOWN: VkResult = -13;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION: VkResult = -1000161000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: VkResult = -1000257000;
pub const VkResult_VK_ERROR_SURFACE_LOST_KHR: VkResult = -1000000000;
pub const VkResult_VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: VkResult = -1000000001;
pub const VkResult_VK_SUBOPTIMAL_KHR: VkResult = 1000001003;
pub const VkResult_VK_ERROR_OUT_OF_DATE_KHR: VkResult = -1000001004;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: VkResult = -1000003001;
pub const VkResult_VK_ERROR_VALIDATION_FAILED_EXT: VkResult = -1000011001;
pub const VkResult_VK_ERROR_INVALID_SHADER_NV: VkResult = -1000012000;
pub const VkResult_VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: VkResult = -1000158000;
pub const VkResult_VK_ERROR_NOT_PERMITTED_EXT: VkResult = -1000174001;
pub const VkResult_VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: VkResult = -1000255000;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION_EXT: VkResult = -1000161000;
pub const VkResult_VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult = -1000257000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult = -1000257000;
pub const VkResult_VK_RESULT_BEGIN_RANGE: VkResult = -13;
pub const VkResult_VK_RESULT_END_RANGE: VkResult = 5;
pub const VkResult_VK_RESULT_RANGE_SIZE: VkResult = 19;
pub const VkResult_VK_RESULT_MAX_ENUM: VkResult = 2147483647;
pub type VkResult = ::std::os::raw::c_int;
pub const VkStructureType_VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType = 0;
pub const VkStructureType_VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType = 1;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType = 2;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType = 3;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType = 4;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType = 5;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType = 6;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType = 7;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType = 8;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType = 9;
pub const VkStructureType_VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType = 10;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType = 11;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType = 12;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType = 13;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType = 14;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType = 15;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType = 16;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType = 17;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType = 18;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
    VkStructureType = 19;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
    VkStructureType = 20;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
    VkStructureType = 21;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType =
    22;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
    VkStructureType = 23;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
    VkStructureType = 24;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
    VkStructureType = 25;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
    VkStructureType = 26;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType =
    27;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType = 28;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType = 29;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType = 30;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType = 31;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType = 32;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType = 33;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType = 34;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType = 35;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType = 36;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType = 37;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType = 38;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType = 39;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType = 40;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType = 41;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType = 42;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType = 43;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType = 44;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType = 45;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType = 46;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType = 47;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType = 48;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType =
    1000094000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType = 1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType = 1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType =
    1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType = 1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType =
    1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType = 1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType =
    1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType = 1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType =
    1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType =
    1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType =
    1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType = 1000145000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
    VkStructureType = 1000145001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
    VkStructureType = 1000145002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType = 1000145003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType =
    1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType =
    1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
    VkStructureType = 1000156004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType =
    1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType =
    1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType =
    1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType = 1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType = 1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: VkStructureType =
    49;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: VkStructureType =
    50;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: VkStructureType =
    51;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: VkStructureType =
    52;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: VkStructureType = 1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: VkStructureType = 1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: VkStructureType = 1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: VkStructureType =
    1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: VkStructureType =
    1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: VkStructureType =
    1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: VkStructureType =
    1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: VkStructureType =
    1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000001000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType = 1000001001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType =
    1000060007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType =
    1000060008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType =
    1000060009;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType =
    1000060010;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType =
    1000060011;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
    VkStructureType = 1000060012;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType =
    1000002000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000002001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType = 1000003000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000004000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000005000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000006000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000008000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000009000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
    VkStructureType = 1000018000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000022000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000022001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType =
    1000022002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
    VkStructureType = 1000026000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
    VkStructureType = 1000026001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
    VkStructureType = 1000026002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
    VkStructureType = 1000028000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
    VkStructureType = 1000028001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
    VkStructureType = 1000028002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType =
    1000030000;
pub const VkStructureType_VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
    VkStructureType = 1000041000;
pub const VkStructureType_VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
    VkStructureType = 1000049000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
    VkStructureType = 1000050000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType =
    1000056000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType =
    1000056001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
    VkStructureType = 1000058000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType = 1000061000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType = 1000062000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT : VkStructureType = 1000066000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType =
    1000067000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
    VkStructureType = 1000067001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType =
    1000073002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType = 1000074000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType = 1000074001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType = 1000074002;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
    VkStructureType = 1000075000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078001;
pub const VkStructureType_VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType =
    1000078002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000078003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType =
    1000079000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType = 1000079001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
    VkStructureType = 1000080000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT : VkStructureType = 1000081000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
    VkStructureType = 1000081001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType =
    1000081002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType = 1000084000;
pub const VkStructureType_VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX: VkStructureType =
    1000086000;
pub const VkStructureType_VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX:
    VkStructureType = 1000086001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX: VkStructureType =
    1000086002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX:
    VkStructureType = 1000086003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX: VkStructureType =
    1000086004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX:
    VkStructureType = 1000086005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
    VkStructureType = 1000087000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType =
    1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType = 1000091000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType = 1000091001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType = 1000091002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType =
    1000091003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType = 1000092000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX : VkStructureType = 1000097000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
    VkStructureType = 1000098000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
    VkStructureType = 1000099000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000099001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT : VkStructureType = 1000101000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT : VkStructureType = 1000101001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
    VkStructureType = 1000102000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT : VkStructureType = 1000102001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType = 1000105000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
    VkStructureType = 1000111000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType = 1000115000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType = 1000115001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
    VkStructureType = 1000116000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
    VkStructureType = 1000116001;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
    VkStructureType = 1000116002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: VkStructureType =
    1000116003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: VkStructureType =
    1000116004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: VkStructureType = 1000116005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: VkStructureType =
    1000116006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType =
    1000119000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType =
    1000119001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType = 1000119002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType = 1000121000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType =
    1000121001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType =
    1000121002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType = 1000121003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType =
    1000121004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000122000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000123000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000128000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000128001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType = 1000128002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
    VkStructureType = 1000128003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType =
    1000128004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType =
    1000129000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
    VkStructureType = 1000129001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
    VkStructureType = 1000129002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType = 1000129005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
    VkStructureType = 1000138000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
    VkStructureType = 1000138001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
    VkStructureType = 1000138002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
    VkStructureType = 1000138003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType = 1000143000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
    VkStructureType = 1000143001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000143002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
    VkStructureType = 1000143003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType =
    1000143004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : VkStructureType = 1000148000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT : VkStructureType = 1000148001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000148002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
    VkStructureType = 1000149000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000152000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
    VkStructureType = 1000154000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
    VkStructureType = 1000154001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
    VkStructureType = 1000158000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: VkStructureType =
    1000158001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
    VkStructureType = 1000158002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
    VkStructureType = 1000158003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
    VkStructureType = 1000158004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
    VkStructureType = 1000158005;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType =
    1000160000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
    VkStructureType = 1000160001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV : VkStructureType = 1000164000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
    VkStructureType = 1000164001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
    VkStructureType = 1000164002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV : VkStructureType = 1000164005 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType =
    1000165000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType =
    1000165001;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType = 1000165003;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType = 1000165004;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType = 1000165005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
    VkStructureType = 1000165006;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
    VkStructureType = 1000165007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
    VkStructureType = 1000165008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
    VkStructureType = 1000165009;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
    VkStructureType = 1000165011;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType =
    1000165012;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV : VkStructureType = 1000166000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV : VkStructureType = 1000166001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
    VkStructureType = 1000170000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
    VkStructureType = 1000170001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
    VkStructureType = 1000174000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType =
    1000178000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType =
    1000178001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
    VkStructureType = 1000178002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
    VkStructureType = 1000181000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
    VkStructureType = 1000183000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType =
    1000184000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
    VkStructureType = 1000185000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
    VkStructureType = 1000189000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT : VkStructureType = 1000190000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000190001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : VkStructureType = 1000190002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType = 1000191000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000192000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV : VkStructureType = 1000201000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
    VkStructureType = 1000202000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
    VkStructureType = 1000202001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV : VkStructureType = 1000203000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
    VkStructureType = 1000204000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV : VkStructureType = 1000205000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
    VkStructureType = 1000205002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType = 1000206000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType =
    1000206001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL : VkStructureType = 1000209000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType =
    1000210000;
pub const VkStructureType_VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType =
    1000210001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType =
    1000210002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType =
    1000210003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType =
    1000210004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
    VkStructureType = 1000210005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
    VkStructureType = 1000212000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
    VkStructureType = 1000213000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
    VkStructureType = 1000213001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType =
    1000214000;
pub const VkStructureType_VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000217000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
    VkStructureType = 1000218000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
    VkStructureType = 1000218001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
    VkStructureType = 1000218002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
    VkStructureType = 1000225000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT : VkStructureType = 1000225001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
    VkStructureType = 1000225002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
    VkStructureType = 1000227000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
    VkStructureType = 1000229000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
    VkStructureType = 1000237000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
    VkStructureType = 1000238000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType =
    1000238001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType =
    1000239000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV : VkStructureType = 1000240000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType =
    1000244002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType =
    1000245000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType = 1000247000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
    VkStructureType = 1000249000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType =
    1000249001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
    VkStructureType = 1000249002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
    VkStructureType = 1000250000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000250001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
    VkStructureType = 1000250002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT : VkStructureType = 1000251000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
    VkStructureType = 1000252000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
    VkStructureType = 1000255000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
    VkStructureType = 1000255002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
    VkStructureType = 1000255001;
pub const VkStructureType_VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000256000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
    VkStructureType = 1000259000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000259001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
    VkStructureType = 1000259002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
    VkStructureType = 1000265000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR : VkStructureType = 1000269000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType = 1000269001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType =
    1000269002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType =
    1000269003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType =
    1000269004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
    VkStructureType = 1000269005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT : VkStructureType = 1000276000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
    VkStructureType = 1000281000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT : VkStructureType = 1000281001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR:
    VkStructureType = 1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR:
    VkStructureType = 1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType =
    1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR:
    VkStructureType = 1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR:
    VkStructureType = 1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType =
    1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR:
    VkStructureType = 1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR:
    VkStructureType = 1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = 1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
    VkStructureType = 1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType =
    1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType =
    1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType =
    1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR:
    VkStructureType = 1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType =
    1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType =
    1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
    VkStructureType = 1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR:
    VkStructureType = 1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR:
    VkStructureType = 1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR:
    VkStructureType = 1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR : VkStructureType = 1000156004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType =
    1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType =
    1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BEGIN_RANGE: VkStructureType = 0;
pub const VkStructureType_VK_STRUCTURE_TYPE_END_RANGE: VkStructureType = 48;
pub const VkStructureType_VK_STRUCTURE_TYPE_RANGE_SIZE: VkStructureType = 49;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAX_ENUM: VkStructureType = 2147483647;
pub type VkStructureType = ::std::os::raw::c_uint;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope = 0;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope = 1;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope = 2;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope = 3;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope = 4;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE: VkSystemAllocationScope =
    0;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE: VkSystemAllocationScope = 4;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE: VkSystemAllocationScope =
    5;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM: VkSystemAllocationScope =
    2147483647;
pub type VkSystemAllocationScope = ::std::os::raw::c_uint;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE:
    VkInternalAllocationType = 0;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE:
    VkInternalAllocationType = 0;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_END_RANGE: VkInternalAllocationType =
    0;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE:
    VkInternalAllocationType = 1;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM: VkInternalAllocationType =
    2147483647;
pub type VkInternalAllocationType = ::std::os::raw::c_uint;
pub const VkFormat_VK_FORMAT_UNDEFINED: VkFormat = 0;
pub const VkFormat_VK_FORMAT_R4G4_UNORM_PACK8: VkFormat = 1;
pub const VkFormat_VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat = 2;
pub const VkFormat_VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat = 3;
pub const VkFormat_VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat = 4;
pub const VkFormat_VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat = 5;
pub const VkFormat_VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat = 6;
pub const VkFormat_VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat = 7;
pub const VkFormat_VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat = 8;
pub const VkFormat_VK_FORMAT_R8_UNORM: VkFormat = 9;
pub const VkFormat_VK_FORMAT_R8_SNORM: VkFormat = 10;
pub const VkFormat_VK_FORMAT_R8_USCALED: VkFormat = 11;
pub const VkFormat_VK_FORMAT_R8_SSCALED: VkFormat = 12;
pub const VkFormat_VK_FORMAT_R8_UINT: VkFormat = 13;
pub const VkFormat_VK_FORMAT_R8_SINT: VkFormat = 14;
pub const VkFormat_VK_FORMAT_R8_SRGB: VkFormat = 15;
pub const VkFormat_VK_FORMAT_R8G8_UNORM: VkFormat = 16;
pub const VkFormat_VK_FORMAT_R8G8_SNORM: VkFormat = 17;
pub const VkFormat_VK_FORMAT_R8G8_USCALED: VkFormat = 18;
pub const VkFormat_VK_FORMAT_R8G8_SSCALED: VkFormat = 19;
pub const VkFormat_VK_FORMAT_R8G8_UINT: VkFormat = 20;
pub const VkFormat_VK_FORMAT_R8G8_SINT: VkFormat = 21;
pub const VkFormat_VK_FORMAT_R8G8_SRGB: VkFormat = 22;
pub const VkFormat_VK_FORMAT_R8G8B8_UNORM: VkFormat = 23;
pub const VkFormat_VK_FORMAT_R8G8B8_SNORM: VkFormat = 24;
pub const VkFormat_VK_FORMAT_R8G8B8_USCALED: VkFormat = 25;
pub const VkFormat_VK_FORMAT_R8G8B8_SSCALED: VkFormat = 26;
pub const VkFormat_VK_FORMAT_R8G8B8_UINT: VkFormat = 27;
pub const VkFormat_VK_FORMAT_R8G8B8_SINT: VkFormat = 28;
pub const VkFormat_VK_FORMAT_R8G8B8_SRGB: VkFormat = 29;
pub const VkFormat_VK_FORMAT_B8G8R8_UNORM: VkFormat = 30;
pub const VkFormat_VK_FORMAT_B8G8R8_SNORM: VkFormat = 31;
pub const VkFormat_VK_FORMAT_B8G8R8_USCALED: VkFormat = 32;
pub const VkFormat_VK_FORMAT_B8G8R8_SSCALED: VkFormat = 33;
pub const VkFormat_VK_FORMAT_B8G8R8_UINT: VkFormat = 34;
pub const VkFormat_VK_FORMAT_B8G8R8_SINT: VkFormat = 35;
pub const VkFormat_VK_FORMAT_B8G8R8_SRGB: VkFormat = 36;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UNORM: VkFormat = 37;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SNORM: VkFormat = 38;
pub const VkFormat_VK_FORMAT_R8G8B8A8_USCALED: VkFormat = 39;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SSCALED: VkFormat = 40;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UINT: VkFormat = 41;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SINT: VkFormat = 42;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SRGB: VkFormat = 43;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UNORM: VkFormat = 44;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SNORM: VkFormat = 45;
pub const VkFormat_VK_FORMAT_B8G8R8A8_USCALED: VkFormat = 46;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SSCALED: VkFormat = 47;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UINT: VkFormat = 48;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SINT: VkFormat = 49;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SRGB: VkFormat = 50;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat = 51;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat = 52;
pub const VkFormat_VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat = 53;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat = 54;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat = 55;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat = 56;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat = 57;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat = 58;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat = 59;
pub const VkFormat_VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat = 60;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat = 61;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat = 62;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat = 63;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat = 64;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat = 65;
pub const VkFormat_VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat = 66;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat = 67;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat = 68;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat = 69;
pub const VkFormat_VK_FORMAT_R16_UNORM: VkFormat = 70;
pub const VkFormat_VK_FORMAT_R16_SNORM: VkFormat = 71;
pub const VkFormat_VK_FORMAT_R16_USCALED: VkFormat = 72;
pub const VkFormat_VK_FORMAT_R16_SSCALED: VkFormat = 73;
pub const VkFormat_VK_FORMAT_R16_UINT: VkFormat = 74;
pub const VkFormat_VK_FORMAT_R16_SINT: VkFormat = 75;
pub const VkFormat_VK_FORMAT_R16_SFLOAT: VkFormat = 76;
pub const VkFormat_VK_FORMAT_R16G16_UNORM: VkFormat = 77;
pub const VkFormat_VK_FORMAT_R16G16_SNORM: VkFormat = 78;
pub const VkFormat_VK_FORMAT_R16G16_USCALED: VkFormat = 79;
pub const VkFormat_VK_FORMAT_R16G16_SSCALED: VkFormat = 80;
pub const VkFormat_VK_FORMAT_R16G16_UINT: VkFormat = 81;
pub const VkFormat_VK_FORMAT_R16G16_SINT: VkFormat = 82;
pub const VkFormat_VK_FORMAT_R16G16_SFLOAT: VkFormat = 83;
pub const VkFormat_VK_FORMAT_R16G16B16_UNORM: VkFormat = 84;
pub const VkFormat_VK_FORMAT_R16G16B16_SNORM: VkFormat = 85;
pub const VkFormat_VK_FORMAT_R16G16B16_USCALED: VkFormat = 86;
pub const VkFormat_VK_FORMAT_R16G16B16_SSCALED: VkFormat = 87;
pub const VkFormat_VK_FORMAT_R16G16B16_UINT: VkFormat = 88;
pub const VkFormat_VK_FORMAT_R16G16B16_SINT: VkFormat = 89;
pub const VkFormat_VK_FORMAT_R16G16B16_SFLOAT: VkFormat = 90;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UNORM: VkFormat = 91;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SNORM: VkFormat = 92;
pub const VkFormat_VK_FORMAT_R16G16B16A16_USCALED: VkFormat = 93;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SSCALED: VkFormat = 94;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UINT: VkFormat = 95;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SINT: VkFormat = 96;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat = 97;
pub const VkFormat_VK_FORMAT_R32_UINT: VkFormat = 98;
pub const VkFormat_VK_FORMAT_R32_SINT: VkFormat = 99;
pub const VkFormat_VK_FORMAT_R32_SFLOAT: VkFormat = 100;
pub const VkFormat_VK_FORMAT_R32G32_UINT: VkFormat = 101;
pub const VkFormat_VK_FORMAT_R32G32_SINT: VkFormat = 102;
pub const VkFormat_VK_FORMAT_R32G32_SFLOAT: VkFormat = 103;
pub const VkFormat_VK_FORMAT_R32G32B32_UINT: VkFormat = 104;
pub const VkFormat_VK_FORMAT_R32G32B32_SINT: VkFormat = 105;
pub const VkFormat_VK_FORMAT_R32G32B32_SFLOAT: VkFormat = 106;
pub const VkFormat_VK_FORMAT_R32G32B32A32_UINT: VkFormat = 107;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SINT: VkFormat = 108;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat = 109;
pub const VkFormat_VK_FORMAT_R64_UINT: VkFormat = 110;
pub const VkFormat_VK_FORMAT_R64_SINT: VkFormat = 111;
pub const VkFormat_VK_FORMAT_R64_SFLOAT: VkFormat = 112;
pub const VkFormat_VK_FORMAT_R64G64_UINT: VkFormat = 113;
pub const VkFormat_VK_FORMAT_R64G64_SINT: VkFormat = 114;
pub const VkFormat_VK_FORMAT_R64G64_SFLOAT: VkFormat = 115;
pub const VkFormat_VK_FORMAT_R64G64B64_UINT: VkFormat = 116;
pub const VkFormat_VK_FORMAT_R64G64B64_SINT: VkFormat = 117;
pub const VkFormat_VK_FORMAT_R64G64B64_SFLOAT: VkFormat = 118;
pub const VkFormat_VK_FORMAT_R64G64B64A64_UINT: VkFormat = 119;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SINT: VkFormat = 120;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat = 121;
pub const VkFormat_VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat = 122;
pub const VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat = 123;
pub const VkFormat_VK_FORMAT_D16_UNORM: VkFormat = 124;
pub const VkFormat_VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat = 125;
pub const VkFormat_VK_FORMAT_D32_SFLOAT: VkFormat = 126;
pub const VkFormat_VK_FORMAT_S8_UINT: VkFormat = 127;
pub const VkFormat_VK_FORMAT_D16_UNORM_S8_UINT: VkFormat = 128;
pub const VkFormat_VK_FORMAT_D24_UNORM_S8_UINT: VkFormat = 129;
pub const VkFormat_VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat = 130;
pub const VkFormat_VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat = 131;
pub const VkFormat_VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat = 132;
pub const VkFormat_VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat = 133;
pub const VkFormat_VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat = 134;
pub const VkFormat_VK_FORMAT_BC2_UNORM_BLOCK: VkFormat = 135;
pub const VkFormat_VK_FORMAT_BC2_SRGB_BLOCK: VkFormat = 136;
pub const VkFormat_VK_FORMAT_BC3_UNORM_BLOCK: VkFormat = 137;
pub const VkFormat_VK_FORMAT_BC3_SRGB_BLOCK: VkFormat = 138;
pub const VkFormat_VK_FORMAT_BC4_UNORM_BLOCK: VkFormat = 139;
pub const VkFormat_VK_FORMAT_BC4_SNORM_BLOCK: VkFormat = 140;
pub const VkFormat_VK_FORMAT_BC5_UNORM_BLOCK: VkFormat = 141;
pub const VkFormat_VK_FORMAT_BC5_SNORM_BLOCK: VkFormat = 142;
pub const VkFormat_VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat = 143;
pub const VkFormat_VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat = 144;
pub const VkFormat_VK_FORMAT_BC7_UNORM_BLOCK: VkFormat = 145;
pub const VkFormat_VK_FORMAT_BC7_SRGB_BLOCK: VkFormat = 146;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat = 147;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat = 148;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat = 149;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat = 150;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat = 151;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat = 152;
pub const VkFormat_VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat = 153;
pub const VkFormat_VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat = 154;
pub const VkFormat_VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat = 155;
pub const VkFormat_VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat = 156;
pub const VkFormat_VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat = 157;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat = 158;
pub const VkFormat_VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat = 159;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat = 160;
pub const VkFormat_VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat = 161;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat = 162;
pub const VkFormat_VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat = 163;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat = 164;
pub const VkFormat_VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat = 165;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat = 166;
pub const VkFormat_VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat = 167;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat = 168;
pub const VkFormat_VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat = 169;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat = 170;
pub const VkFormat_VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat = 171;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat = 172;
pub const VkFormat_VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat = 173;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat = 174;
pub const VkFormat_VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat = 175;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat = 176;
pub const VkFormat_VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat = 177;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat = 178;
pub const VkFormat_VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat = 179;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat = 180;
pub const VkFormat_VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat = 181;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat = 182;
pub const VkFormat_VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat = 183;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat = 184;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054000;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054001;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054002;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054003;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054004;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054005;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054006;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054007;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_BEGIN_RANGE: VkFormat = 0;
pub const VkFormat_VK_FORMAT_END_RANGE: VkFormat = 184;
pub const VkFormat_VK_FORMAT_RANGE_SIZE: VkFormat = 185;
pub const VkFormat_VK_FORMAT_MAX_ENUM: VkFormat = 2147483647;
pub type VkFormat = ::std::os::raw::c_uint;
pub const VkImageType_VK_IMAGE_TYPE_1D: VkImageType = 0;
pub const VkImageType_VK_IMAGE_TYPE_2D: VkImageType = 1;
pub const VkImageType_VK_IMAGE_TYPE_3D: VkImageType = 2;
pub const VkImageType_VK_IMAGE_TYPE_BEGIN_RANGE: VkImageType = 0;
pub const VkImageType_VK_IMAGE_TYPE_END_RANGE: VkImageType = 2;
pub const VkImageType_VK_IMAGE_TYPE_RANGE_SIZE: VkImageType = 3;
pub const VkImageType_VK_IMAGE_TYPE_MAX_ENUM: VkImageType = 2147483647;
pub type VkImageType = ::std::os::raw::c_uint;
pub const VkImageTiling_VK_IMAGE_TILING_OPTIMAL: VkImageTiling = 0;
pub const VkImageTiling_VK_IMAGE_TILING_LINEAR: VkImageTiling = 1;
pub const VkImageTiling_VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling = 1000158000;
pub const VkImageTiling_VK_IMAGE_TILING_BEGIN_RANGE: VkImageTiling = 0;
pub const VkImageTiling_VK_IMAGE_TILING_END_RANGE: VkImageTiling = 1;
pub const VkImageTiling_VK_IMAGE_TILING_RANGE_SIZE: VkImageTiling = 2;
pub const VkImageTiling_VK_IMAGE_TILING_MAX_ENUM: VkImageTiling = 2147483647;
pub type VkImageTiling = ::std::os::raw::c_uint;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType = 0;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType = 1;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType = 2;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType = 3;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType = 4;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE: VkPhysicalDeviceType = 0;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_END_RANGE: VkPhysicalDeviceType = 4;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE: VkPhysicalDeviceType = 5;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM: VkPhysicalDeviceType = 2147483647;
pub type VkPhysicalDeviceType = ::std::os::raw::c_uint;
pub const VkQueryType_VK_QUERY_TYPE_OCCLUSION: VkQueryType = 0;
pub const VkQueryType_VK_QUERY_TYPE_PIPELINE_STATISTICS: VkQueryType = 1;
pub const VkQueryType_VK_QUERY_TYPE_TIMESTAMP: VkQueryType = 2;
pub const VkQueryType_VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT: VkQueryType = 1000028004;
pub const VkQueryType_VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR: VkQueryType = 1000116000;
pub const VkQueryType_VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: VkQueryType =
    1000165000;
pub const VkQueryType_VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL: VkQueryType = 1000210000;
pub const VkQueryType_VK_QUERY_TYPE_BEGIN_RANGE: VkQueryType = 0;
pub const VkQueryType_VK_QUERY_TYPE_END_RANGE: VkQueryType = 2;
pub const VkQueryType_VK_QUERY_TYPE_RANGE_SIZE: VkQueryType = 3;
pub const VkQueryType_VK_QUERY_TYPE_MAX_ENUM: VkQueryType = 2147483647;
pub type VkQueryType = ::std::os::raw::c_uint;
pub const VkSharingMode_VK_SHARING_MODE_EXCLUSIVE: VkSharingMode = 0;
pub const VkSharingMode_VK_SHARING_MODE_CONCURRENT: VkSharingMode = 1;
pub const VkSharingMode_VK_SHARING_MODE_BEGIN_RANGE: VkSharingMode = 0;
pub const VkSharingMode_VK_SHARING_MODE_END_RANGE: VkSharingMode = 1;
pub const VkSharingMode_VK_SHARING_MODE_RANGE_SIZE: VkSharingMode = 2;
pub const VkSharingMode_VK_SHARING_MODE_MAX_ENUM: VkSharingMode = 2147483647;
pub type VkSharingMode = ::std::os::raw::c_uint;
pub const VkImageLayout_VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout = 0;
pub const VkImageLayout_VK_IMAGE_LAYOUT_GENERAL: VkImageLayout = 1;
pub const VkImageLayout_VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout = 2;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 3;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 4;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout = 5;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout = 6;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout = 7;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout = 8;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout =
    1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout =
    1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout = 1000001002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout = 1000111000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout =
    1000218000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR:
    VkImageLayout = 1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_BEGIN_RANGE: VkImageLayout = 0;
pub const VkImageLayout_VK_IMAGE_LAYOUT_END_RANGE: VkImageLayout = 8;
pub const VkImageLayout_VK_IMAGE_LAYOUT_RANGE_SIZE: VkImageLayout = 9;
pub const VkImageLayout_VK_IMAGE_LAYOUT_MAX_ENUM: VkImageLayout = 2147483647;
pub type VkImageLayout = ::std::os::raw::c_uint;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_1D: VkImageViewType = 0;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_2D: VkImageViewType = 1;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_3D: VkImageViewType = 2;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_CUBE: VkImageViewType = 3;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_1D_ARRAY: VkImageViewType = 4;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_2D_ARRAY: VkImageViewType = 5;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: VkImageViewType = 6;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_BEGIN_RANGE: VkImageViewType = 0;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_END_RANGE: VkImageViewType = 6;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_RANGE_SIZE: VkImageViewType = 7;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_MAX_ENUM: VkImageViewType = 2147483647;
pub type VkImageViewType = ::std::os::raw::c_uint;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_IDENTITY: VkComponentSwizzle = 0;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_ZERO: VkComponentSwizzle = 1;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_ONE: VkComponentSwizzle = 2;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_R: VkComponentSwizzle = 3;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_G: VkComponentSwizzle = 4;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_B: VkComponentSwizzle = 5;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_A: VkComponentSwizzle = 6;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_BEGIN_RANGE: VkComponentSwizzle = 0;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_END_RANGE: VkComponentSwizzle = 6;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_RANGE_SIZE: VkComponentSwizzle = 7;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_MAX_ENUM: VkComponentSwizzle = 2147483647;
pub type VkComponentSwizzle = ::std::os::raw::c_uint;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_VERTEX: VkVertexInputRate = 0;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_INSTANCE: VkVertexInputRate = 1;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_BEGIN_RANGE: VkVertexInputRate = 0;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_END_RANGE: VkVertexInputRate = 1;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_RANGE_SIZE: VkVertexInputRate = 2;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_MAX_ENUM: VkVertexInputRate = 2147483647;
pub type VkVertexInputRate = ::std::os::raw::c_uint;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_POINT_LIST: VkPrimitiveTopology = 0;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_LINE_LIST: VkPrimitiveTopology = 1;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: VkPrimitiveTopology = 2;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: VkPrimitiveTopology = 3;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: VkPrimitiveTopology = 4;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: VkPrimitiveTopology = 5;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: VkPrimitiveTopology =
    6;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology =
    7;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY:
    VkPrimitiveTopology = 8;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY:
    VkPrimitiveTopology = 9;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_PATCH_LIST: VkPrimitiveTopology = 10;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE: VkPrimitiveTopology = 0;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_END_RANGE: VkPrimitiveTopology = 10;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE: VkPrimitiveTopology = 11;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_MAX_ENUM: VkPrimitiveTopology = 2147483647;
pub type VkPrimitiveTopology = ::std::os::raw::c_uint;
pub const VkPolygonMode_VK_POLYGON_MODE_FILL: VkPolygonMode = 0;
pub const VkPolygonMode_VK_POLYGON_MODE_LINE: VkPolygonMode = 1;
pub const VkPolygonMode_VK_POLYGON_MODE_POINT: VkPolygonMode = 2;
pub const VkPolygonMode_VK_POLYGON_MODE_FILL_RECTANGLE_NV: VkPolygonMode = 1000153000;
pub const VkPolygonMode_VK_POLYGON_MODE_BEGIN_RANGE: VkPolygonMode = 0;
pub const VkPolygonMode_VK_POLYGON_MODE_END_RANGE: VkPolygonMode = 2;
pub const VkPolygonMode_VK_POLYGON_MODE_RANGE_SIZE: VkPolygonMode = 3;
pub const VkPolygonMode_VK_POLYGON_MODE_MAX_ENUM: VkPolygonMode = 2147483647;
pub type VkPolygonMode = ::std::os::raw::c_uint;
pub const VkFrontFace_VK_FRONT_FACE_COUNTER_CLOCKWISE: VkFrontFace = 0;
pub const VkFrontFace_VK_FRONT_FACE_CLOCKWISE: VkFrontFace = 1;
pub const VkFrontFace_VK_FRONT_FACE_BEGIN_RANGE: VkFrontFace = 0;
pub const VkFrontFace_VK_FRONT_FACE_END_RANGE: VkFrontFace = 1;
pub const VkFrontFace_VK_FRONT_FACE_RANGE_SIZE: VkFrontFace = 2;
pub const VkFrontFace_VK_FRONT_FACE_MAX_ENUM: VkFrontFace = 2147483647;
pub type VkFrontFace = ::std::os::raw::c_uint;
pub const VkCompareOp_VK_COMPARE_OP_NEVER: VkCompareOp = 0;
pub const VkCompareOp_VK_COMPARE_OP_LESS: VkCompareOp = 1;
pub const VkCompareOp_VK_COMPARE_OP_EQUAL: VkCompareOp = 2;
pub const VkCompareOp_VK_COMPARE_OP_LESS_OR_EQUAL: VkCompareOp = 3;
pub const VkCompareOp_VK_COMPARE_OP_GREATER: VkCompareOp = 4;
pub const VkCompareOp_VK_COMPARE_OP_NOT_EQUAL: VkCompareOp = 5;
pub const VkCompareOp_VK_COMPARE_OP_GREATER_OR_EQUAL: VkCompareOp = 6;
pub const VkCompareOp_VK_COMPARE_OP_ALWAYS: VkCompareOp = 7;
pub const VkCompareOp_VK_COMPARE_OP_BEGIN_RANGE: VkCompareOp = 0;
pub const VkCompareOp_VK_COMPARE_OP_END_RANGE: VkCompareOp = 7;
pub const VkCompareOp_VK_COMPARE_OP_RANGE_SIZE: VkCompareOp = 8;
pub const VkCompareOp_VK_COMPARE_OP_MAX_ENUM: VkCompareOp = 2147483647;
pub type VkCompareOp = ::std::os::raw::c_uint;
pub const VkStencilOp_VK_STENCIL_OP_KEEP: VkStencilOp = 0;
pub const VkStencilOp_VK_STENCIL_OP_ZERO: VkStencilOp = 1;
pub const VkStencilOp_VK_STENCIL_OP_REPLACE: VkStencilOp = 2;
pub const VkStencilOp_VK_STENCIL_OP_INCREMENT_AND_CLAMP: VkStencilOp = 3;
pub const VkStencilOp_VK_STENCIL_OP_DECREMENT_AND_CLAMP: VkStencilOp = 4;
pub const VkStencilOp_VK_STENCIL_OP_INVERT: VkStencilOp = 5;
pub const VkStencilOp_VK_STENCIL_OP_INCREMENT_AND_WRAP: VkStencilOp = 6;
pub const VkStencilOp_VK_STENCIL_OP_DECREMENT_AND_WRAP: VkStencilOp = 7;
pub const VkStencilOp_VK_STENCIL_OP_BEGIN_RANGE: VkStencilOp = 0;
pub const VkStencilOp_VK_STENCIL_OP_END_RANGE: VkStencilOp = 7;
pub const VkStencilOp_VK_STENCIL_OP_RANGE_SIZE: VkStencilOp = 8;
pub const VkStencilOp_VK_STENCIL_OP_MAX_ENUM: VkStencilOp = 2147483647;
pub type VkStencilOp = ::std::os::raw::c_uint;
pub const VkLogicOp_VK_LOGIC_OP_CLEAR: VkLogicOp = 0;
pub const VkLogicOp_VK_LOGIC_OP_AND: VkLogicOp = 1;
pub const VkLogicOp_VK_LOGIC_OP_AND_REVERSE: VkLogicOp = 2;
pub const VkLogicOp_VK_LOGIC_OP_COPY: VkLogicOp = 3;
pub const VkLogicOp_VK_LOGIC_OP_AND_INVERTED: VkLogicOp = 4;
pub const VkLogicOp_VK_LOGIC_OP_NO_OP: VkLogicOp = 5;
pub const VkLogicOp_VK_LOGIC_OP_XOR: VkLogicOp = 6;
pub const VkLogicOp_VK_LOGIC_OP_OR: VkLogicOp = 7;
pub const VkLogicOp_VK_LOGIC_OP_NOR: VkLogicOp = 8;
pub const VkLogicOp_VK_LOGIC_OP_EQUIVALENT: VkLogicOp = 9;
pub const VkLogicOp_VK_LOGIC_OP_INVERT: VkLogicOp = 10;
pub const VkLogicOp_VK_LOGIC_OP_OR_REVERSE: VkLogicOp = 11;
pub const VkLogicOp_VK_LOGIC_OP_COPY_INVERTED: VkLogicOp = 12;
pub const VkLogicOp_VK_LOGIC_OP_OR_INVERTED: VkLogicOp = 13;
pub const VkLogicOp_VK_LOGIC_OP_NAND: VkLogicOp = 14;
pub const VkLogicOp_VK_LOGIC_OP_SET: VkLogicOp = 15;
pub const VkLogicOp_VK_LOGIC_OP_BEGIN_RANGE: VkLogicOp = 0;
pub const VkLogicOp_VK_LOGIC_OP_END_RANGE: VkLogicOp = 15;
pub const VkLogicOp_VK_LOGIC_OP_RANGE_SIZE: VkLogicOp = 16;
pub const VkLogicOp_VK_LOGIC_OP_MAX_ENUM: VkLogicOp = 2147483647;
pub type VkLogicOp = ::std::os::raw::c_uint;
pub const VkBlendFactor_VK_BLEND_FACTOR_ZERO: VkBlendFactor = 0;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE: VkBlendFactor = 1;
pub const VkBlendFactor_VK_BLEND_FACTOR_SRC_COLOR: VkBlendFactor = 2;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: VkBlendFactor = 3;
pub const VkBlendFactor_VK_BLEND_FACTOR_DST_COLOR: VkBlendFactor = 4;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR: VkBlendFactor = 5;
pub const VkBlendFactor_VK_BLEND_FACTOR_SRC_ALPHA: VkBlendFactor = 6;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: VkBlendFactor = 7;
pub const VkBlendFactor_VK_BLEND_FACTOR_DST_ALPHA: VkBlendFactor = 8;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: VkBlendFactor = 9;
pub const VkBlendFactor_VK_BLEND_FACTOR_CONSTANT_COLOR: VkBlendFactor = 10;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: VkBlendFactor = 11;
pub const VkBlendFactor_VK_BLEND_FACTOR_CONSTANT_ALPHA: VkBlendFactor = 12;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: VkBlendFactor = 13;
pub const VkBlendFactor_VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: VkBlendFactor = 14;
pub const VkBlendFactor_VK_BLEND_FACTOR_SRC1_COLOR: VkBlendFactor = 15;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: VkBlendFactor = 16;
pub const VkBlendFactor_VK_BLEND_FACTOR_SRC1_ALPHA: VkBlendFactor = 17;
pub const VkBlendFactor_VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: VkBlendFactor = 18;
pub const VkBlendFactor_VK_BLEND_FACTOR_BEGIN_RANGE: VkBlendFactor = 0;
pub const VkBlendFactor_VK_BLEND_FACTOR_END_RANGE: VkBlendFactor = 18;
pub const VkBlendFactor_VK_BLEND_FACTOR_RANGE_SIZE: VkBlendFactor = 19;
pub const VkBlendFactor_VK_BLEND_FACTOR_MAX_ENUM: VkBlendFactor = 2147483647;
pub type VkBlendFactor = ::std::os::raw::c_uint;
pub const VkBlendOp_VK_BLEND_OP_ADD: VkBlendOp = 0;
pub const VkBlendOp_VK_BLEND_OP_SUBTRACT: VkBlendOp = 1;
pub const VkBlendOp_VK_BLEND_OP_REVERSE_SUBTRACT: VkBlendOp = 2;
pub const VkBlendOp_VK_BLEND_OP_MIN: VkBlendOp = 3;
pub const VkBlendOp_VK_BLEND_OP_MAX: VkBlendOp = 4;
pub const VkBlendOp_VK_BLEND_OP_ZERO_EXT: VkBlendOp = 1000148000;
pub const VkBlendOp_VK_BLEND_OP_SRC_EXT: VkBlendOp = 1000148001;
pub const VkBlendOp_VK_BLEND_OP_DST_EXT: VkBlendOp = 1000148002;
pub const VkBlendOp_VK_BLEND_OP_SRC_OVER_EXT: VkBlendOp = 1000148003;
pub const VkBlendOp_VK_BLEND_OP_DST_OVER_EXT: VkBlendOp = 1000148004;
pub const VkBlendOp_VK_BLEND_OP_SRC_IN_EXT: VkBlendOp = 1000148005;
pub const VkBlendOp_VK_BLEND_OP_DST_IN_EXT: VkBlendOp = 1000148006;
pub const VkBlendOp_VK_BLEND_OP_SRC_OUT_EXT: VkBlendOp = 1000148007;
pub const VkBlendOp_VK_BLEND_OP_DST_OUT_EXT: VkBlendOp = 1000148008;
pub const VkBlendOp_VK_BLEND_OP_SRC_ATOP_EXT: VkBlendOp = 1000148009;
pub const VkBlendOp_VK_BLEND_OP_DST_ATOP_EXT: VkBlendOp = 1000148010;
pub const VkBlendOp_VK_BLEND_OP_XOR_EXT: VkBlendOp = 1000148011;
pub const VkBlendOp_VK_BLEND_OP_MULTIPLY_EXT: VkBlendOp = 1000148012;
pub const VkBlendOp_VK_BLEND_OP_SCREEN_EXT: VkBlendOp = 1000148013;
pub const VkBlendOp_VK_BLEND_OP_OVERLAY_EXT: VkBlendOp = 1000148014;
pub const VkBlendOp_VK_BLEND_OP_DARKEN_EXT: VkBlendOp = 1000148015;
pub const VkBlendOp_VK_BLEND_OP_LIGHTEN_EXT: VkBlendOp = 1000148016;
pub const VkBlendOp_VK_BLEND_OP_COLORDODGE_EXT: VkBlendOp = 1000148017;
pub const VkBlendOp_VK_BLEND_OP_COLORBURN_EXT: VkBlendOp = 1000148018;
pub const VkBlendOp_VK_BLEND_OP_HARDLIGHT_EXT: VkBlendOp = 1000148019;
pub const VkBlendOp_VK_BLEND_OP_SOFTLIGHT_EXT: VkBlendOp = 1000148020;
pub const VkBlendOp_VK_BLEND_OP_DIFFERENCE_EXT: VkBlendOp = 1000148021;
pub const VkBlendOp_VK_BLEND_OP_EXCLUSION_EXT: VkBlendOp = 1000148022;
pub const VkBlendOp_VK_BLEND_OP_INVERT_EXT: VkBlendOp = 1000148023;
pub const VkBlendOp_VK_BLEND_OP_INVERT_RGB_EXT: VkBlendOp = 1000148024;
pub const VkBlendOp_VK_BLEND_OP_LINEARDODGE_EXT: VkBlendOp = 1000148025;
pub const VkBlendOp_VK_BLEND_OP_LINEARBURN_EXT: VkBlendOp = 1000148026;
pub const VkBlendOp_VK_BLEND_OP_VIVIDLIGHT_EXT: VkBlendOp = 1000148027;
pub const VkBlendOp_VK_BLEND_OP_LINEARLIGHT_EXT: VkBlendOp = 1000148028;
pub const VkBlendOp_VK_BLEND_OP_PINLIGHT_EXT: VkBlendOp = 1000148029;
pub const VkBlendOp_VK_BLEND_OP_HARDMIX_EXT: VkBlendOp = 1000148030;
pub const VkBlendOp_VK_BLEND_OP_HSL_HUE_EXT: VkBlendOp = 1000148031;
pub const VkBlendOp_VK_BLEND_OP_HSL_SATURATION_EXT: VkBlendOp = 1000148032;
pub const VkBlendOp_VK_BLEND_OP_HSL_COLOR_EXT: VkBlendOp = 1000148033;
pub const VkBlendOp_VK_BLEND_OP_HSL_LUMINOSITY_EXT: VkBlendOp = 1000148034;
pub const VkBlendOp_VK_BLEND_OP_PLUS_EXT: VkBlendOp = 1000148035;
pub const VkBlendOp_VK_BLEND_OP_PLUS_CLAMPED_EXT: VkBlendOp = 1000148036;
pub const VkBlendOp_VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT: VkBlendOp = 1000148037;
pub const VkBlendOp_VK_BLEND_OP_PLUS_DARKER_EXT: VkBlendOp = 1000148038;
pub const VkBlendOp_VK_BLEND_OP_MINUS_EXT: VkBlendOp = 1000148039;
pub const VkBlendOp_VK_BLEND_OP_MINUS_CLAMPED_EXT: VkBlendOp = 1000148040;
pub const VkBlendOp_VK_BLEND_OP_CONTRAST_EXT: VkBlendOp = 1000148041;
pub const VkBlendOp_VK_BLEND_OP_INVERT_OVG_EXT: VkBlendOp = 1000148042;
pub const VkBlendOp_VK_BLEND_OP_RED_EXT: VkBlendOp = 1000148043;
pub const VkBlendOp_VK_BLEND_OP_GREEN_EXT: VkBlendOp = 1000148044;
pub const VkBlendOp_VK_BLEND_OP_BLUE_EXT: VkBlendOp = 1000148045;
pub const VkBlendOp_VK_BLEND_OP_BEGIN_RANGE: VkBlendOp = 0;
pub const VkBlendOp_VK_BLEND_OP_END_RANGE: VkBlendOp = 4;
pub const VkBlendOp_VK_BLEND_OP_RANGE_SIZE: VkBlendOp = 5;
pub const VkBlendOp_VK_BLEND_OP_MAX_ENUM: VkBlendOp = 2147483647;
pub type VkBlendOp = ::std::os::raw::c_uint;
pub const VkDynamicState_VK_DYNAMIC_STATE_VIEWPORT: VkDynamicState = 0;
pub const VkDynamicState_VK_DYNAMIC_STATE_SCISSOR: VkDynamicState = 1;
pub const VkDynamicState_VK_DYNAMIC_STATE_LINE_WIDTH: VkDynamicState = 2;
pub const VkDynamicState_VK_DYNAMIC_STATE_DEPTH_BIAS: VkDynamicState = 3;
pub const VkDynamicState_VK_DYNAMIC_STATE_BLEND_CONSTANTS: VkDynamicState = 4;
pub const VkDynamicState_VK_DYNAMIC_STATE_DEPTH_BOUNDS: VkDynamicState = 5;
pub const VkDynamicState_VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: VkDynamicState = 6;
pub const VkDynamicState_VK_DYNAMIC_STATE_STENCIL_WRITE_MASK: VkDynamicState = 7;
pub const VkDynamicState_VK_DYNAMIC_STATE_STENCIL_REFERENCE: VkDynamicState = 8;
pub const VkDynamicState_VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV: VkDynamicState = 1000087000;
pub const VkDynamicState_VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT: VkDynamicState = 1000099000;
pub const VkDynamicState_VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT: VkDynamicState = 1000143000;
pub const VkDynamicState_VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV: VkDynamicState =
    1000164004;
pub const VkDynamicState_VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV: VkDynamicState =
    1000164006;
pub const VkDynamicState_VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV: VkDynamicState = 1000205001;
pub const VkDynamicState_VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState = 1000259000;
pub const VkDynamicState_VK_DYNAMIC_STATE_BEGIN_RANGE: VkDynamicState = 0;
pub const VkDynamicState_VK_DYNAMIC_STATE_END_RANGE: VkDynamicState = 8;
pub const VkDynamicState_VK_DYNAMIC_STATE_RANGE_SIZE: VkDynamicState = 9;
pub const VkDynamicState_VK_DYNAMIC_STATE_MAX_ENUM: VkDynamicState = 2147483647;
pub type VkDynamicState = ::std::os::raw::c_uint;
pub const VkFilter_VK_FILTER_NEAREST: VkFilter = 0;
pub const VkFilter_VK_FILTER_LINEAR: VkFilter = 1;
pub const VkFilter_VK_FILTER_CUBIC_IMG: VkFilter = 1000015000;
pub const VkFilter_VK_FILTER_CUBIC_EXT: VkFilter = 1000015000;
pub const VkFilter_VK_FILTER_BEGIN_RANGE: VkFilter = 0;
pub const VkFilter_VK_FILTER_END_RANGE: VkFilter = 1;
pub const VkFilter_VK_FILTER_RANGE_SIZE: VkFilter = 2;
pub const VkFilter_VK_FILTER_MAX_ENUM: VkFilter = 2147483647;
pub type VkFilter = ::std::os::raw::c_uint;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_NEAREST: VkSamplerMipmapMode = 0;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_LINEAR: VkSamplerMipmapMode = 1;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE: VkSamplerMipmapMode = 0;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_END_RANGE: VkSamplerMipmapMode = 1;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE: VkSamplerMipmapMode = 2;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_MAX_ENUM: VkSamplerMipmapMode = 2147483647;
pub type VkSamplerMipmapMode = ::std::os::raw::c_uint;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_REPEAT: VkSamplerAddressMode = 0;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: VkSamplerAddressMode = 1;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: VkSamplerAddressMode = 2;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: VkSamplerAddressMode = 3;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: VkSamplerAddressMode =
    4;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR:
    VkSamplerAddressMode = 4;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE: VkSamplerAddressMode = 0;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_END_RANGE: VkSamplerAddressMode = 3;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE: VkSamplerAddressMode = 4;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_MAX_ENUM: VkSamplerAddressMode = 2147483647;
pub type VkSamplerAddressMode = ::std::os::raw::c_uint;
pub const VkBorderColor_VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: VkBorderColor = 0;
pub const VkBorderColor_VK_BORDER_COLOR_INT_TRANSPARENT_BLACK: VkBorderColor = 1;
pub const VkBorderColor_VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK: VkBorderColor = 2;
pub const VkBorderColor_VK_BORDER_COLOR_INT_OPAQUE_BLACK: VkBorderColor = 3;
pub const VkBorderColor_VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE: VkBorderColor = 4;
pub const VkBorderColor_VK_BORDER_COLOR_INT_OPAQUE_WHITE: VkBorderColor = 5;
pub const VkBorderColor_VK_BORDER_COLOR_BEGIN_RANGE: VkBorderColor = 0;
pub const VkBorderColor_VK_BORDER_COLOR_END_RANGE: VkBorderColor = 5;
pub const VkBorderColor_VK_BORDER_COLOR_RANGE_SIZE: VkBorderColor = 6;
pub const VkBorderColor_VK_BORDER_COLOR_MAX_ENUM: VkBorderColor = 2147483647;
pub type VkBorderColor = ::std::os::raw::c_uint;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_SAMPLER: VkDescriptorType = 0;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: VkDescriptorType = 1;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: VkDescriptorType = 2;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: VkDescriptorType = 3;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: VkDescriptorType = 4;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: VkDescriptorType = 5;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: VkDescriptorType = 6;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: VkDescriptorType = 7;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: VkDescriptorType = 8;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: VkDescriptorType = 9;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: VkDescriptorType = 10;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType =
    1000138000;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV: VkDescriptorType =
    1000165000;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_BEGIN_RANGE: VkDescriptorType = 0;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_END_RANGE: VkDescriptorType = 10;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_RANGE_SIZE: VkDescriptorType = 11;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_MAX_ENUM: VkDescriptorType = 2147483647;
pub type VkDescriptorType = ::std::os::raw::c_uint;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_LOAD: VkAttachmentLoadOp = 0;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_CLEAR: VkAttachmentLoadOp = 1;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_DONT_CARE: VkAttachmentLoadOp = 2;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE: VkAttachmentLoadOp = 0;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_END_RANGE: VkAttachmentLoadOp = 2;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_RANGE_SIZE: VkAttachmentLoadOp = 3;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_MAX_ENUM: VkAttachmentLoadOp = 2147483647;
pub type VkAttachmentLoadOp = ::std::os::raw::c_uint;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_STORE: VkAttachmentStoreOp = 0;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_DONT_CARE: VkAttachmentStoreOp = 1;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_BEGIN_RANGE: VkAttachmentStoreOp = 0;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_END_RANGE: VkAttachmentStoreOp = 1;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_RANGE_SIZE: VkAttachmentStoreOp = 2;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_MAX_ENUM: VkAttachmentStoreOp = 2147483647;
pub type VkAttachmentStoreOp = ::std::os::raw::c_uint;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_GRAPHICS: VkPipelineBindPoint = 0;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_COMPUTE: VkPipelineBindPoint = 1;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint =
    1000165000;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_BEGIN_RANGE: VkPipelineBindPoint = 0;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_END_RANGE: VkPipelineBindPoint = 1;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_RANGE_SIZE: VkPipelineBindPoint = 2;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_MAX_ENUM: VkPipelineBindPoint = 2147483647;
pub type VkPipelineBindPoint = ::std::os::raw::c_uint;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_PRIMARY: VkCommandBufferLevel = 0;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_SECONDARY: VkCommandBufferLevel = 1;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE: VkCommandBufferLevel = 0;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_END_RANGE: VkCommandBufferLevel = 1;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE: VkCommandBufferLevel = 2;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_MAX_ENUM: VkCommandBufferLevel = 2147483647;
pub type VkCommandBufferLevel = ::std::os::raw::c_uint;
pub const VkIndexType_VK_INDEX_TYPE_UINT16: VkIndexType = 0;
pub const VkIndexType_VK_INDEX_TYPE_UINT32: VkIndexType = 1;
pub const VkIndexType_VK_INDEX_TYPE_NONE_NV: VkIndexType = 1000165000;
pub const VkIndexType_VK_INDEX_TYPE_UINT8_EXT: VkIndexType = 1000265000;
pub const VkIndexType_VK_INDEX_TYPE_BEGIN_RANGE: VkIndexType = 0;
pub const VkIndexType_VK_INDEX_TYPE_END_RANGE: VkIndexType = 1;
pub const VkIndexType_VK_INDEX_TYPE_RANGE_SIZE: VkIndexType = 2;
pub const VkIndexType_VK_INDEX_TYPE_MAX_ENUM: VkIndexType = 2147483647;
pub type VkIndexType = ::std::os::raw::c_uint;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_INLINE: VkSubpassContents = 0;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: VkSubpassContents = 1;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_BEGIN_RANGE: VkSubpassContents = 0;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_END_RANGE: VkSubpassContents = 1;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_RANGE_SIZE: VkSubpassContents = 2;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_MAX_ENUM: VkSubpassContents = 2147483647;
pub type VkSubpassContents = ::std::os::raw::c_uint;
pub const VkObjectType_VK_OBJECT_TYPE_UNKNOWN: VkObjectType = 0;
pub const VkObjectType_VK_OBJECT_TYPE_INSTANCE: VkObjectType = 1;
pub const VkObjectType_VK_OBJECT_TYPE_PHYSICAL_DEVICE: VkObjectType = 2;
pub const VkObjectType_VK_OBJECT_TYPE_DEVICE: VkObjectType = 3;
pub const VkObjectType_VK_OBJECT_TYPE_QUEUE: VkObjectType = 4;
pub const VkObjectType_VK_OBJECT_TYPE_SEMAPHORE: VkObjectType = 5;
pub const VkObjectType_VK_OBJECT_TYPE_COMMAND_BUFFER: VkObjectType = 6;
pub const VkObjectType_VK_OBJECT_TYPE_FENCE: VkObjectType = 7;
pub const VkObjectType_VK_OBJECT_TYPE_DEVICE_MEMORY: VkObjectType = 8;
pub const VkObjectType_VK_OBJECT_TYPE_BUFFER: VkObjectType = 9;
pub const VkObjectType_VK_OBJECT_TYPE_IMAGE: VkObjectType = 10;
pub const VkObjectType_VK_OBJECT_TYPE_EVENT: VkObjectType = 11;
pub const VkObjectType_VK_OBJECT_TYPE_QUERY_POOL: VkObjectType = 12;
pub const VkObjectType_VK_OBJECT_TYPE_BUFFER_VIEW: VkObjectType = 13;
pub const VkObjectType_VK_OBJECT_TYPE_IMAGE_VIEW: VkObjectType = 14;
pub const VkObjectType_VK_OBJECT_TYPE_SHADER_MODULE: VkObjectType = 15;
pub const VkObjectType_VK_OBJECT_TYPE_PIPELINE_CACHE: VkObjectType = 16;
pub const VkObjectType_VK_OBJECT_TYPE_PIPELINE_LAYOUT: VkObjectType = 17;
pub const VkObjectType_VK_OBJECT_TYPE_RENDER_PASS: VkObjectType = 18;
pub const VkObjectType_VK_OBJECT_TYPE_PIPELINE: VkObjectType = 19;
pub const VkObjectType_VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: VkObjectType = 20;
pub const VkObjectType_VK_OBJECT_TYPE_SAMPLER: VkObjectType = 21;
pub const VkObjectType_VK_OBJECT_TYPE_DESCRIPTOR_POOL: VkObjectType = 22;
pub const VkObjectType_VK_OBJECT_TYPE_DESCRIPTOR_SET: VkObjectType = 23;
pub const VkObjectType_VK_OBJECT_TYPE_FRAMEBUFFER: VkObjectType = 24;
pub const VkObjectType_VK_OBJECT_TYPE_COMMAND_POOL: VkObjectType = 25;
pub const VkObjectType_VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: VkObjectType = 1000156000;
pub const VkObjectType_VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: VkObjectType = 1000085000;
pub const VkObjectType_VK_OBJECT_TYPE_SURFACE_KHR: VkObjectType = 1000000000;
pub const VkObjectType_VK_OBJECT_TYPE_SWAPCHAIN_KHR: VkObjectType = 1000001000;
pub const VkObjectType_VK_OBJECT_TYPE_DISPLAY_KHR: VkObjectType = 1000002000;
pub const VkObjectType_VK_OBJECT_TYPE_DISPLAY_MODE_KHR: VkObjectType = 1000002001;
pub const VkObjectType_VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT: VkObjectType = 1000011000;
pub const VkObjectType_VK_OBJECT_TYPE_OBJECT_TABLE_NVX: VkObjectType = 1000086000;
pub const VkObjectType_VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX: VkObjectType = 1000086001;
pub const VkObjectType_VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT: VkObjectType = 1000128000;
pub const VkObjectType_VK_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkObjectType = 1000160000;
pub const VkObjectType_VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV: VkObjectType = 1000165000;
pub const VkObjectType_VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL: VkObjectType = 1000210000;
pub const VkObjectType_VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType = 1000085000;
pub const VkObjectType_VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType = 1000156000;
pub const VkObjectType_VK_OBJECT_TYPE_BEGIN_RANGE: VkObjectType = 0;
pub const VkObjectType_VK_OBJECT_TYPE_END_RANGE: VkObjectType = 25;
pub const VkObjectType_VK_OBJECT_TYPE_RANGE_SIZE: VkObjectType = 26;
pub const VkObjectType_VK_OBJECT_TYPE_MAX_ENUM: VkObjectType = 2147483647;
pub type VkObjectType = ::std::os::raw::c_uint;
pub const VkVendorId_VK_VENDOR_ID_VIV: VkVendorId = 65537;
pub const VkVendorId_VK_VENDOR_ID_VSI: VkVendorId = 65538;
pub const VkVendorId_VK_VENDOR_ID_KAZAN: VkVendorId = 65539;
pub const VkVendorId_VK_VENDOR_ID_BEGIN_RANGE: VkVendorId = 65537;
pub const VkVendorId_VK_VENDOR_ID_END_RANGE: VkVendorId = 65539;
pub const VkVendorId_VK_VENDOR_ID_RANGE_SIZE: VkVendorId = 3;
pub const VkVendorId_VK_VENDOR_ID_MAX_ENUM: VkVendorId = 2147483647;
pub type VkVendorId = ::std::os::raw::c_uint;
pub type VkInstanceCreateFlags = VkFlags;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits = 1;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits = 2;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT:
    VkFormatFeatureFlagBits = 4;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT:
    VkFormatFeatureFlagBits = 8;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT:
    VkFormatFeatureFlagBits = 16;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT:
    VkFormatFeatureFlagBits = 32;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits = 64;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits =
    128;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT:
    VkFormatFeatureFlagBits = 256;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT:
    VkFormatFeatureFlagBits = 512;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_BLIT_SRC_BIT: VkFormatFeatureFlagBits = 1024;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_BLIT_DST_BIT: VkFormatFeatureFlagBits = 2048;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT:
    VkFormatFeatureFlagBits = 4096;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits =
    16384;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_TRANSFER_DST_BIT: VkFormatFeatureFlagBits =
    32768;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT:
    VkFormatFeatureFlagBits = 131072;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT : VkFormatFeatureFlagBits = 262144 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT : VkFormatFeatureFlagBits = 524288 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT : VkFormatFeatureFlagBits = 1048576 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT : VkFormatFeatureFlagBits = 2097152 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_DISJOINT_BIT: VkFormatFeatureFlagBits = 4194304;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT:
    VkFormatFeatureFlagBits = 8388608;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT:
    VkFormatFeatureFlagBits = 65536;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG:
    VkFormatFeatureFlagBits = 8192;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT:
    VkFormatFeatureFlagBits = 16777216;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits =
    16384;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits =
    32768;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT:
    VkFormatFeatureFlagBits = 65536;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR:
    VkFormatFeatureFlagBits = 131072;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR : VkFormatFeatureFlagBits = 262144 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR : VkFormatFeatureFlagBits = 524288 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR : VkFormatFeatureFlagBits = 1048576 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR : VkFormatFeatureFlagBits = 2097152 ;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits =
    4194304;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR:
    VkFormatFeatureFlagBits = 8388608;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT:
    VkFormatFeatureFlagBits = 8192;
pub const VkFormatFeatureFlagBits_VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM: VkFormatFeatureFlagBits =
    2147483647;
pub type VkFormatFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkFormatFeatureFlags = VkFlags;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_TRANSFER_SRC_BIT: VkImageUsageFlagBits = 1;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_TRANSFER_DST_BIT: VkImageUsageFlagBits = 2;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_SAMPLED_BIT: VkImageUsageFlagBits = 4;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_STORAGE_BIT: VkImageUsageFlagBits = 8;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: VkImageUsageFlagBits = 16;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: VkImageUsageFlagBits =
    32;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: VkImageUsageFlagBits = 64;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: VkImageUsageFlagBits = 128;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits = 256;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkImageUsageFlagBits =
    512;
pub const VkImageUsageFlagBits_VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM: VkImageUsageFlagBits = 2147483647;
pub type VkImageUsageFlagBits = ::std::os::raw::c_uint;
pub type VkImageUsageFlags = VkFlags;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SPARSE_BINDING_BIT: VkImageCreateFlagBits = 1;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: VkImageCreateFlagBits = 2;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: VkImageCreateFlagBits = 4;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: VkImageCreateFlagBits = 8;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: VkImageCreateFlagBits = 16;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_ALIAS_BIT: VkImageCreateFlagBits = 1024;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT:
    VkImageCreateFlagBits = 64;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: VkImageCreateFlagBits = 32;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT:
    VkImageCreateFlagBits = 128;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: VkImageCreateFlagBits = 256;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_PROTECTED_BIT: VkImageCreateFlagBits = 2048;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_DISJOINT_BIT: VkImageCreateFlagBits = 512;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: VkImageCreateFlagBits = 8192;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT:
    VkImageCreateFlagBits = 4096;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: VkImageCreateFlagBits = 16384;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR:
    VkImageCreateFlagBits = 64;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits =
    32;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR:
    VkImageCreateFlagBits = 128;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits = 256;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits = 512;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits = 1024;
pub const VkImageCreateFlagBits_VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM: VkImageCreateFlagBits =
    2147483647;
pub type VkImageCreateFlagBits = ::std::os::raw::c_uint;
pub type VkImageCreateFlags = VkFlags;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits = 1;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits = 2;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits = 4;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits = 8;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits = 16;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits = 32;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits = 64;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM: VkSampleCountFlagBits =
    2147483647;
pub type VkSampleCountFlagBits = ::std::os::raw::c_uint;
pub type VkSampleCountFlags = VkFlags;
pub const VkQueueFlagBits_VK_QUEUE_GRAPHICS_BIT: VkQueueFlagBits = 1;
pub const VkQueueFlagBits_VK_QUEUE_COMPUTE_BIT: VkQueueFlagBits = 2;
pub const VkQueueFlagBits_VK_QUEUE_TRANSFER_BIT: VkQueueFlagBits = 4;
pub const VkQueueFlagBits_VK_QUEUE_SPARSE_BINDING_BIT: VkQueueFlagBits = 8;
pub const VkQueueFlagBits_VK_QUEUE_PROTECTED_BIT: VkQueueFlagBits = 16;
pub const VkQueueFlagBits_VK_QUEUE_FLAG_BITS_MAX_ENUM: VkQueueFlagBits = 2147483647;
pub type VkQueueFlagBits = ::std::os::raw::c_uint;
pub type VkQueueFlags = VkFlags;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: VkMemoryPropertyFlagBits =
    1;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: VkMemoryPropertyFlagBits =
    2;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: VkMemoryPropertyFlagBits =
    4;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_HOST_CACHED_BIT: VkMemoryPropertyFlagBits = 8;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT:
    VkMemoryPropertyFlagBits = 16;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_PROTECTED_BIT: VkMemoryPropertyFlagBits = 32;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD:
    VkMemoryPropertyFlagBits = 64;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD:
    VkMemoryPropertyFlagBits = 128;
pub const VkMemoryPropertyFlagBits_VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM: VkMemoryPropertyFlagBits =
    2147483647;
pub type VkMemoryPropertyFlagBits = ::std::os::raw::c_uint;
pub type VkMemoryPropertyFlags = VkFlags;
pub const VkMemoryHeapFlagBits_VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: VkMemoryHeapFlagBits = 1;
pub const VkMemoryHeapFlagBits_VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: VkMemoryHeapFlagBits = 2;
pub const VkMemoryHeapFlagBits_VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits = 2;
pub const VkMemoryHeapFlagBits_VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM: VkMemoryHeapFlagBits = 2147483647;
pub type VkMemoryHeapFlagBits = ::std::os::raw::c_uint;
pub type VkMemoryHeapFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub const VkDeviceQueueCreateFlagBits_VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT:
    VkDeviceQueueCreateFlagBits = 1;
pub const VkDeviceQueueCreateFlagBits_VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM:
    VkDeviceQueueCreateFlagBits = 2147483647;
pub type VkDeviceQueueCreateFlagBits = ::std::os::raw::c_uint;
pub type VkDeviceQueueCreateFlags = VkFlags;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits = 1;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits = 2;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: VkPipelineStageFlagBits = 4;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: VkPipelineStageFlagBits = 8;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT:
    VkPipelineStageFlagBits = 16;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT:
    VkPipelineStageFlagBits = 32;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits =
    64;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits =
    128;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT:
    VkPipelineStageFlagBits = 256;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT:
    VkPipelineStageFlagBits = 512;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT:
    VkPipelineStageFlagBits = 1024;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits =
    2048;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TRANSFER_BIT: VkPipelineStageFlagBits = 4096;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits =
    8192;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_HOST_BIT: VkPipelineStageFlagBits = 16384;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits =
    32768;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: VkPipelineStageFlagBits =
    65536;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT:
    VkPipelineStageFlagBits = 16777216;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT:
    VkPipelineStageFlagBits = 262144;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX:
    VkPipelineStageFlagBits = 131072;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV:
    VkPipelineStageFlagBits = 4194304;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV:
    VkPipelineStageFlagBits = 2097152;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV:
    VkPipelineStageFlagBits = 33554432;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits =
    524288;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits =
    1048576;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT:
    VkPipelineStageFlagBits = 8388608;
pub const VkPipelineStageFlagBits_VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM: VkPipelineStageFlagBits =
    2147483647;
pub type VkPipelineStageFlagBits = ::std::os::raw::c_uint;
pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits = 1;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits = 2;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits = 4;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits = 8;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits = 128;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits = 256;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits = 512;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits =
    1024;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM: VkImageAspectFlagBits =
    2147483647;
pub type VkImageAspectFlagBits = ::std::os::raw::c_uint;
pub type VkImageAspectFlags = VkFlags;
pub const VkSparseImageFormatFlagBits_VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT:
    VkSparseImageFormatFlagBits = 1;
pub const VkSparseImageFormatFlagBits_VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT:
    VkSparseImageFormatFlagBits = 2;
pub const VkSparseImageFormatFlagBits_VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT:
    VkSparseImageFormatFlagBits = 4;
pub const VkSparseImageFormatFlagBits_VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM:
    VkSparseImageFormatFlagBits = 2147483647;
pub type VkSparseImageFormatFlagBits = ::std::os::raw::c_uint;
pub type VkSparseImageFormatFlags = VkFlags;
pub const VkSparseMemoryBindFlagBits_VK_SPARSE_MEMORY_BIND_METADATA_BIT:
    VkSparseMemoryBindFlagBits = 1;
pub const VkSparseMemoryBindFlagBits_VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM:
    VkSparseMemoryBindFlagBits = 2147483647;
pub type VkSparseMemoryBindFlagBits = ::std::os::raw::c_uint;
pub type VkSparseMemoryBindFlags = VkFlags;
pub const VkFenceCreateFlagBits_VK_FENCE_CREATE_SIGNALED_BIT: VkFenceCreateFlagBits = 1;
pub const VkFenceCreateFlagBits_VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM: VkFenceCreateFlagBits =
    2147483647;
pub type VkFenceCreateFlagBits = ::std::os::raw::c_uint;
pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT : VkQueryPipelineStatisticFlagBits = 1 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT : VkQueryPipelineStatisticFlagBits = 2 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT : VkQueryPipelineStatisticFlagBits = 4 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT : VkQueryPipelineStatisticFlagBits = 8 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT : VkQueryPipelineStatisticFlagBits = 16 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 32;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT:
    VkQueryPipelineStatisticFlagBits = 64;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT : VkQueryPipelineStatisticFlagBits = 128 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT : VkQueryPipelineStatisticFlagBits = 256 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT : VkQueryPipelineStatisticFlagBits = 512 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT : VkQueryPipelineStatisticFlagBits = 1024 ;
pub const VkQueryPipelineStatisticFlagBits_VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM:
    VkQueryPipelineStatisticFlagBits = 2147483647;
pub type VkQueryPipelineStatisticFlagBits = ::std::os::raw::c_uint;
pub type VkQueryPipelineStatisticFlags = VkFlags;
pub const VkQueryResultFlagBits_VK_QUERY_RESULT_64_BIT: VkQueryResultFlagBits = 1;
pub const VkQueryResultFlagBits_VK_QUERY_RESULT_WAIT_BIT: VkQueryResultFlagBits = 2;
pub const VkQueryResultFlagBits_VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: VkQueryResultFlagBits = 4;
pub const VkQueryResultFlagBits_VK_QUERY_RESULT_PARTIAL_BIT: VkQueryResultFlagBits = 8;
pub const VkQueryResultFlagBits_VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM: VkQueryResultFlagBits =
    2147483647;
pub type VkQueryResultFlagBits = ::std::os::raw::c_uint;
pub type VkQueryResultFlags = VkFlags;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_SPARSE_BINDING_BIT: VkBufferCreateFlagBits = 1;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: VkBufferCreateFlagBits = 2;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: VkBufferCreateFlagBits = 4;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_PROTECTED_BIT: VkBufferCreateFlagBits = 8;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT:
    VkBufferCreateFlagBits = 16;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT:
    VkBufferCreateFlagBits = 16;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR:
    VkBufferCreateFlagBits = 16;
pub const VkBufferCreateFlagBits_VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM: VkBufferCreateFlagBits =
    2147483647;
pub type VkBufferCreateFlagBits = ::std::os::raw::c_uint;
pub type VkBufferCreateFlags = VkFlags;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_TRANSFER_SRC_BIT: VkBufferUsageFlagBits = 1;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_TRANSFER_DST_BIT: VkBufferUsageFlagBits = 2;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits = 4;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits = 8;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: VkBufferUsageFlagBits = 16;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: VkBufferUsageFlagBits = 32;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_INDEX_BUFFER_BIT: VkBufferUsageFlagBits = 64;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: VkBufferUsageFlagBits = 128;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: VkBufferUsageFlagBits = 256;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: VkBufferUsageFlagBits =
    131072;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT:
    VkBufferUsageFlagBits = 2048;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT:
    VkBufferUsageFlagBits = 4096;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT:
    VkBufferUsageFlagBits = 512;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits = 1024;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT:
    VkBufferUsageFlagBits = 131072;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR:
    VkBufferUsageFlagBits = 131072;
pub const VkBufferUsageFlagBits_VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM: VkBufferUsageFlagBits =
    2147483647;
pub type VkBufferUsageFlagBits = ::std::os::raw::c_uint;
pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub const VkImageViewCreateFlagBits_VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT:
    VkImageViewCreateFlagBits = 1;
pub const VkImageViewCreateFlagBits_VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM:
    VkImageViewCreateFlagBits = 2147483647;
pub type VkImageViewCreateFlagBits = ::std::os::raw::c_uint;
pub type VkImageViewCreateFlags = VkFlags;
pub const VkShaderModuleCreateFlagBits_VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM:
    VkShaderModuleCreateFlagBits = 2147483647;
pub type VkShaderModuleCreateFlagBits = ::std::os::raw::c_uint;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT:
    VkPipelineCreateFlagBits = 1;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT:
    VkPipelineCreateFlagBits = 2;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DERIVATIVE_BIT: VkPipelineCreateFlagBits = 4;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT:
    VkPipelineCreateFlagBits = 8;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: VkPipelineCreateFlagBits =
    16;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV:
    VkPipelineCreateFlagBits = 32;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR:
    VkPipelineCreateFlagBits = 64;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR:
    VkPipelineCreateFlagBits = 128;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits = 16;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR:
    VkPipelineCreateFlagBits = 8;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits =
    16;
pub const VkPipelineCreateFlagBits_VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM: VkPipelineCreateFlagBits =
    2147483647;
pub type VkPipelineCreateFlagBits = ::std::os::raw::c_uint;
pub type VkPipelineCreateFlags = VkFlags;
pub const VkPipelineShaderStageCreateFlagBits_VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT : VkPipelineShaderStageCreateFlagBits = 1 ;
pub const VkPipelineShaderStageCreateFlagBits_VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT : VkPipelineShaderStageCreateFlagBits = 2 ;
pub const VkPipelineShaderStageCreateFlagBits_VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM:
    VkPipelineShaderStageCreateFlagBits = 2147483647;
pub type VkPipelineShaderStageCreateFlagBits = ::std::os::raw::c_uint;
pub type VkPipelineShaderStageCreateFlags = VkFlags;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_VERTEX_BIT: VkShaderStageFlagBits = 1;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: VkShaderStageFlagBits = 2;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: VkShaderStageFlagBits =
    4;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_GEOMETRY_BIT: VkShaderStageFlagBits = 8;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_FRAGMENT_BIT: VkShaderStageFlagBits = 16;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_COMPUTE_BIT: VkShaderStageFlagBits = 32;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_ALL_GRAPHICS: VkShaderStageFlagBits = 31;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_ALL: VkShaderStageFlagBits = 2147483647;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits = 256;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits = 512;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits = 1024;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits = 2048;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits = 4096;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits = 8192;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits = 64;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits = 128;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits =
    2147483647;
pub type VkShaderStageFlagBits = ::std::os::raw::c_uint;
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
pub const VkCullModeFlagBits_VK_CULL_MODE_NONE: VkCullModeFlagBits = 0;
pub const VkCullModeFlagBits_VK_CULL_MODE_FRONT_BIT: VkCullModeFlagBits = 1;
pub const VkCullModeFlagBits_VK_CULL_MODE_BACK_BIT: VkCullModeFlagBits = 2;
pub const VkCullModeFlagBits_VK_CULL_MODE_FRONT_AND_BACK: VkCullModeFlagBits = 3;
pub const VkCullModeFlagBits_VK_CULL_MODE_FLAG_BITS_MAX_ENUM: VkCullModeFlagBits = 2147483647;
pub type VkCullModeFlagBits = ::std::os::raw::c_uint;
pub type VkCullModeFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
pub const VkColorComponentFlagBits_VK_COLOR_COMPONENT_R_BIT: VkColorComponentFlagBits = 1;
pub const VkColorComponentFlagBits_VK_COLOR_COMPONENT_G_BIT: VkColorComponentFlagBits = 2;
pub const VkColorComponentFlagBits_VK_COLOR_COMPONENT_B_BIT: VkColorComponentFlagBits = 4;
pub const VkColorComponentFlagBits_VK_COLOR_COMPONENT_A_BIT: VkColorComponentFlagBits = 8;
pub const VkColorComponentFlagBits_VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM: VkColorComponentFlagBits =
    2147483647;
pub type VkColorComponentFlagBits = ::std::os::raw::c_uint;
pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub const VkSamplerCreateFlagBits_VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: VkSamplerCreateFlagBits = 1;
pub const VkSamplerCreateFlagBits_VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT:
    VkSamplerCreateFlagBits = 2;
pub const VkSamplerCreateFlagBits_VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM: VkSamplerCreateFlagBits =
    2147483647;
pub type VkSamplerCreateFlagBits = ::std::os::raw::c_uint;
pub type VkSamplerCreateFlags = VkFlags;
pub const VkDescriptorSetLayoutCreateFlagBits_VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT : VkDescriptorSetLayoutCreateFlagBits = 2 ;
pub const VkDescriptorSetLayoutCreateFlagBits_VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR : VkDescriptorSetLayoutCreateFlagBits = 1 ;
pub const VkDescriptorSetLayoutCreateFlagBits_VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT : VkDescriptorSetLayoutCreateFlagBits = 2 ;
pub const VkDescriptorSetLayoutCreateFlagBits_VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM:
    VkDescriptorSetLayoutCreateFlagBits = 2147483647;
pub type VkDescriptorSetLayoutCreateFlagBits = ::std::os::raw::c_uint;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
pub const VkDescriptorPoolCreateFlagBits_VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT:
    VkDescriptorPoolCreateFlagBits = 1;
pub const VkDescriptorPoolCreateFlagBits_VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT:
    VkDescriptorPoolCreateFlagBits = 2;
pub const VkDescriptorPoolCreateFlagBits_VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT:
    VkDescriptorPoolCreateFlagBits = 2;
pub const VkDescriptorPoolCreateFlagBits_VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM:
    VkDescriptorPoolCreateFlagBits = 2147483647;
pub type VkDescriptorPoolCreateFlagBits = ::std::os::raw::c_uint;
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub const VkFramebufferCreateFlagBits_VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT:
    VkFramebufferCreateFlagBits = 1;
pub const VkFramebufferCreateFlagBits_VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR:
    VkFramebufferCreateFlagBits = 1;
pub const VkFramebufferCreateFlagBits_VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM:
    VkFramebufferCreateFlagBits = 2147483647;
pub type VkFramebufferCreateFlagBits = ::std::os::raw::c_uint;
pub type VkFramebufferCreateFlags = VkFlags;
pub const VkRenderPassCreateFlagBits_VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM:
    VkRenderPassCreateFlagBits = 2147483647;
pub type VkRenderPassCreateFlagBits = ::std::os::raw::c_uint;
pub type VkRenderPassCreateFlags = VkFlags;
pub const VkAttachmentDescriptionFlagBits_VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT:
    VkAttachmentDescriptionFlagBits = 1;
pub const VkAttachmentDescriptionFlagBits_VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM:
    VkAttachmentDescriptionFlagBits = 2147483647;
pub type VkAttachmentDescriptionFlagBits = ::std::os::raw::c_uint;
pub type VkAttachmentDescriptionFlags = VkFlags;
pub const VkSubpassDescriptionFlagBits_VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX:
    VkSubpassDescriptionFlagBits = 1;
pub const VkSubpassDescriptionFlagBits_VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX:
    VkSubpassDescriptionFlagBits = 2;
pub const VkSubpassDescriptionFlagBits_VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM:
    VkSubpassDescriptionFlagBits = 2147483647;
pub type VkSubpassDescriptionFlagBits = ::std::os::raw::c_uint;
pub type VkSubpassDescriptionFlags = VkFlags;
pub const VkAccessFlagBits_VK_ACCESS_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits = 1;
pub const VkAccessFlagBits_VK_ACCESS_INDEX_READ_BIT: VkAccessFlagBits = 2;
pub const VkAccessFlagBits_VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits = 4;
pub const VkAccessFlagBits_VK_ACCESS_UNIFORM_READ_BIT: VkAccessFlagBits = 8;
pub const VkAccessFlagBits_VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits = 16;
pub const VkAccessFlagBits_VK_ACCESS_SHADER_READ_BIT: VkAccessFlagBits = 32;
pub const VkAccessFlagBits_VK_ACCESS_SHADER_WRITE_BIT: VkAccessFlagBits = 64;
pub const VkAccessFlagBits_VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits = 128;
pub const VkAccessFlagBits_VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits = 256;
pub const VkAccessFlagBits_VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits = 512;
pub const VkAccessFlagBits_VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits = 1024;
pub const VkAccessFlagBits_VK_ACCESS_TRANSFER_READ_BIT: VkAccessFlagBits = 2048;
pub const VkAccessFlagBits_VK_ACCESS_TRANSFER_WRITE_BIT: VkAccessFlagBits = 4096;
pub const VkAccessFlagBits_VK_ACCESS_HOST_READ_BIT: VkAccessFlagBits = 8192;
pub const VkAccessFlagBits_VK_ACCESS_HOST_WRITE_BIT: VkAccessFlagBits = 16384;
pub const VkAccessFlagBits_VK_ACCESS_MEMORY_READ_BIT: VkAccessFlagBits = 32768;
pub const VkAccessFlagBits_VK_ACCESS_MEMORY_WRITE_BIT: VkAccessFlagBits = 65536;
pub const VkAccessFlagBits_VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits = 33554432;
pub const VkAccessFlagBits_VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits =
    67108864;
pub const VkAccessFlagBits_VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits =
    134217728;
pub const VkAccessFlagBits_VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits = 1048576;
pub const VkAccessFlagBits_VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX: VkAccessFlagBits = 131072;
pub const VkAccessFlagBits_VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX: VkAccessFlagBits = 262144;
pub const VkAccessFlagBits_VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits =
    524288;
pub const VkAccessFlagBits_VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits = 8388608;
pub const VkAccessFlagBits_VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits = 2097152;
pub const VkAccessFlagBits_VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits =
    4194304;
pub const VkAccessFlagBits_VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits = 16777216;
pub const VkAccessFlagBits_VK_ACCESS_FLAG_BITS_MAX_ENUM: VkAccessFlagBits = 2147483647;
pub type VkAccessFlagBits = ::std::os::raw::c_uint;
pub type VkAccessFlags = VkFlags;
pub const VkDependencyFlagBits_VK_DEPENDENCY_BY_REGION_BIT: VkDependencyFlagBits = 1;
pub const VkDependencyFlagBits_VK_DEPENDENCY_DEVICE_GROUP_BIT: VkDependencyFlagBits = 4;
pub const VkDependencyFlagBits_VK_DEPENDENCY_VIEW_LOCAL_BIT: VkDependencyFlagBits = 2;
pub const VkDependencyFlagBits_VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits = 2;
pub const VkDependencyFlagBits_VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits = 4;
pub const VkDependencyFlagBits_VK_DEPENDENCY_FLAG_BITS_MAX_ENUM: VkDependencyFlagBits = 2147483647;
pub type VkDependencyFlagBits = ::std::os::raw::c_uint;
pub type VkDependencyFlags = VkFlags;
pub const VkCommandPoolCreateFlagBits_VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:
    VkCommandPoolCreateFlagBits = 1;
pub const VkCommandPoolCreateFlagBits_VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:
    VkCommandPoolCreateFlagBits = 2;
pub const VkCommandPoolCreateFlagBits_VK_COMMAND_POOL_CREATE_PROTECTED_BIT:
    VkCommandPoolCreateFlagBits = 4;
pub const VkCommandPoolCreateFlagBits_VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM:
    VkCommandPoolCreateFlagBits = 2147483647;
pub type VkCommandPoolCreateFlagBits = ::std::os::raw::c_uint;
pub type VkCommandPoolCreateFlags = VkFlags;
pub const VkCommandPoolResetFlagBits_VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT:
    VkCommandPoolResetFlagBits = 1;
pub const VkCommandPoolResetFlagBits_VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM:
    VkCommandPoolResetFlagBits = 2147483647;
pub type VkCommandPoolResetFlagBits = ::std::os::raw::c_uint;
pub type VkCommandPoolResetFlags = VkFlags;
pub const VkCommandBufferUsageFlagBits_VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:
    VkCommandBufferUsageFlagBits = 1;
pub const VkCommandBufferUsageFlagBits_VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:
    VkCommandBufferUsageFlagBits = 2;
pub const VkCommandBufferUsageFlagBits_VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:
    VkCommandBufferUsageFlagBits = 4;
pub const VkCommandBufferUsageFlagBits_VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM:
    VkCommandBufferUsageFlagBits = 2147483647;
pub type VkCommandBufferUsageFlagBits = ::std::os::raw::c_uint;
pub type VkCommandBufferUsageFlags = VkFlags;
pub const VkQueryControlFlagBits_VK_QUERY_CONTROL_PRECISE_BIT: VkQueryControlFlagBits = 1;
pub const VkQueryControlFlagBits_VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM: VkQueryControlFlagBits =
    2147483647;
pub type VkQueryControlFlagBits = ::std::os::raw::c_uint;
pub type VkQueryControlFlags = VkFlags;
pub const VkCommandBufferResetFlagBits_VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT:
    VkCommandBufferResetFlagBits = 1;
pub const VkCommandBufferResetFlagBits_VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM:
    VkCommandBufferResetFlagBits = 2147483647;
pub type VkCommandBufferResetFlagBits = ::std::os::raw::c_uint;
pub type VkCommandBufferResetFlags = VkFlags;
pub const VkStencilFaceFlagBits_VK_STENCIL_FACE_FRONT_BIT: VkStencilFaceFlagBits = 1;
pub const VkStencilFaceFlagBits_VK_STENCIL_FACE_BACK_BIT: VkStencilFaceFlagBits = 2;
pub const VkStencilFaceFlagBits_VK_STENCIL_FACE_FRONT_AND_BACK: VkStencilFaceFlagBits = 3;
pub const VkStencilFaceFlagBits_VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits = 3;
pub const VkStencilFaceFlagBits_VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM: VkStencilFaceFlagBits =
    2147483647;
pub type VkStencilFaceFlagBits = ::std::os::raw::c_uint;
pub type VkStencilFaceFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pApplicationName: *const ::std::os::raw::c_char,
    pub applicationVersion: u32,
    pub pEngineName: *const ::std::os::raw::c_char,
    pub engineVersion: u32,
    pub apiVersion: u32,
}
#[test]
fn bindgen_test_layout_VkApplicationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkApplicationInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkApplicationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkApplicationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkApplicationInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkApplicationInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkApplicationInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkApplicationInfo>())).pApplicationName as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(pApplicationName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkApplicationInfo>())).applicationVersion as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(applicationVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkApplicationInfo>())).pEngineName as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(pEngineName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkApplicationInfo>())).engineVersion as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(engineVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkApplicationInfo>())).apiVersion as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkApplicationInfo),
            "::",
            stringify!(apiVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkInstanceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkInstanceCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkInstanceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInstanceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkInstanceCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkInstanceCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkInstanceCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkInstanceCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInstanceCreateInfo>())).pApplicationInfo as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(pApplicationInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInstanceCreateInfo>())).enabledLayerCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(enabledLayerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInstanceCreateInfo>())).ppEnabledLayerNames as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(ppEnabledLayerNames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInstanceCreateInfo>())).enabledExtensionCount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(enabledExtensionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInstanceCreateInfo>())).ppEnabledExtensionNames as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInstanceCreateInfo),
            "::",
            stringify!(ppEnabledExtensionNames)
        )
    );
}
pub type PFN_vkAllocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: size_t,
        alignment: size_t,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkReallocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pOriginal: *mut ::std::os::raw::c_void,
        size: size_t,
        alignment: size_t,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkFreeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pMemory: *mut ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkInternalAllocationNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: size_t,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkInternalFreeNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: size_t,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[test]
fn bindgen_test_layout_VkAllocationCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<VkAllocationCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(VkAllocationCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAllocationCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAllocationCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAllocationCallbacks>())).pUserData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pUserData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAllocationCallbacks>())).pfnAllocation as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAllocationCallbacks>())).pfnReallocation as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnReallocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAllocationCallbacks>())).pfnFree as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnFree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAllocationCallbacks>())).pfnInternalAllocation as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnInternalAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAllocationCallbacks>())).pfnInternalFree as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAllocationCallbacks),
            "::",
            stringify!(pfnInternalFree)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFeatures>(),
        220usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).robustBufferAccess as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(robustBufferAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).fullDrawIndexUint32 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(fullDrawIndexUint32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).imageCubeArray as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(imageCubeArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).independentBlend as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(independentBlend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).geometryShader as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(geometryShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).tessellationShader as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(tessellationShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sampleRateShading as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sampleRateShading)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).dualSrcBlend as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(dualSrcBlend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).logicOp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(logicOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).multiDrawIndirect as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(multiDrawIndirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).drawIndirectFirstInstance
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(drawIndirectFirstInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).depthClamp as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(depthClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).depthBiasClamp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(depthBiasClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).fillModeNonSolid as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(fillModeNonSolid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).depthBounds as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(depthBounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).wideLines as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(wideLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).largePoints as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(largePoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).alphaToOne as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(alphaToOne)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).multiViewport as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(multiViewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).samplerAnisotropy as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(samplerAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).textureCompressionETC2 as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(textureCompressionETC2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).textureCompressionASTC_LDR
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(textureCompressionASTC_LDR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).textureCompressionBC as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(textureCompressionBC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).occlusionQueryPrecise as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(occlusionQueryPrecise)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).pipelineStatisticsQuery as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(pipelineStatisticsQuery)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).vertexPipelineStoresAndAtomics
                as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(vertexPipelineStoresAndAtomics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).fragmentStoresAndAtomics
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(fragmentStoresAndAtomics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderTessellationAndGeometryPointSize as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderTessellationAndGeometryPointSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderImageGatherExtended
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderImageGatherExtended)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderStorageImageExtendedFormats
                as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageImageExtendedFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderStorageImageMultisample
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageImageMultisample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderStorageImageReadWithoutFormat
                as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageImageReadWithoutFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderStorageImageWriteWithoutFormat as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageImageWriteWithoutFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderUniformBufferArrayDynamicIndexing as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderUniformBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderSampledImageArrayDynamicIndexing as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderSampledImageArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderStorageBufferArrayDynamicIndexing as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>()))
                .shaderStorageImageArrayDynamicIndexing as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderStorageImageArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderClipDistance as *const _
                as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderClipDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderCullDistance as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderCullDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderFloat64 as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderInt64 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderInt64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderInt16 as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderInt16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderResourceResidency as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderResourceResidency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).shaderResourceMinLod as *const _
                as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(shaderResourceMinLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseBinding as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseBinding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidencyBuffer as *const _
                as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidencyBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidencyImage2D as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidencyImage2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidencyImage3D as *const _
                as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidencyImage3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidency2Samples as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidency2Samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidency4Samples as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidency4Samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidency8Samples as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidency8Samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidency16Samples
                as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidency16Samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).sparseResidencyAliased as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(sparseResidencyAliased)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).variableMultisampleRate as *const _
                as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(variableMultisampleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures>())).inheritedQueries as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures),
            "::",
            stringify!(inheritedQueries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkFormatProperties>(),
        12usize,
        concat!("Size of: ", stringify!(VkFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFormatProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkFormatProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFormatProperties>())).linearTilingFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties),
            "::",
            stringify!(linearTilingFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFormatProperties>())).optimalTilingFeatures as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties),
            "::",
            stringify!(optimalTilingFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFormatProperties>())).bufferFeatures as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties),
            "::",
            stringify!(bufferFeatures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExtent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkExtent3D() {
    assert_eq!(
        ::std::mem::size_of::<VkExtent3D>(),
        12usize,
        concat!("Size of: ", stringify!(VkExtent3D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtent3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExtent3D>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExtent3D>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExtent3D>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent3D),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: u32,
    pub maxArrayLayers: u32,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties>())).maxExtent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties),
            "::",
            stringify!(maxExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties>())).maxMipLevels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties),
            "::",
            stringify!(maxMipLevels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties>())).maxArrayLayers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties),
            "::",
            stringify!(maxArrayLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties>())).sampleCounts as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties),
            "::",
            stringify!(sampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties>())).maxResourceSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties),
            "::",
            stringify!(maxResourceSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3usize],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3usize],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: size_t,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLimits() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLimits>(),
        504usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceLimits))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLimits>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceLimits))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxImageDimension1D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxImageDimension2D as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxImageDimension3D as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimension3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxImageDimensionCube as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageDimensionCube)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxImageArrayLayers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxImageArrayLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxTexelBufferElements as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelBufferElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxUniformBufferRange as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxUniformBufferRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxStorageBufferRange as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxStorageBufferRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPushConstantsSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPushConstantsSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxMemoryAllocationCount as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxMemoryAllocationCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxSamplerAllocationCount as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerAllocationCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).bufferImageGranularity as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(bufferImageGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).sparseAddressSpaceSize as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sparseAddressSpaceSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxBoundDescriptorSets as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxBoundDescriptorSets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorSamplers
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorUniformBuffers
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorStorageBuffers
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorSampledImages
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorStorageImages
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageDescriptorInputAttachments
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageDescriptorInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxPerStageResources as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxPerStageResources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetSamplers as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetUniformBuffers
                as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetUniformBuffersDynamic
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetUniformBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetStorageBuffers
                as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetStorageBuffersDynamic
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetSampledImages
                as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetStorageImages
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDescriptorSetInputAttachments
                as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDescriptorSetInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxVertexInputAttributes as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxVertexInputBindings as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputBindings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxVertexInputAttributeOffset
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputAttributeOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxVertexInputBindingStride
                as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexInputBindingStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxVertexOutputComponents as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxVertexOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxTessellationGenerationLevel
                as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationGenerationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxTessellationPatchSize as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationPatchSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationControlPerVertexInputComponents as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerVertexInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationControlPerVertexOutputComponents as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerVertexOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationControlPerPatchOutputComponents as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlPerPatchOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationControlTotalOutputComponents as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationControlTotalOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationEvaluationInputComponents as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationEvaluationInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>()))
                .maxTessellationEvaluationOutputComponents as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTessellationEvaluationOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxGeometryShaderInvocations
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryShaderInvocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxGeometryInputComponents
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxGeometryOutputComponents
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxGeometryOutputVertices as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryOutputVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxGeometryTotalOutputComponents
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxGeometryTotalOutputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFragmentInputComponents
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentInputComponents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFragmentOutputAttachments
                as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentOutputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFragmentDualSrcAttachments
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentDualSrcAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFragmentCombinedOutputResources
                as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFragmentCombinedOutputResources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxComputeSharedMemorySize
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeSharedMemorySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxComputeWorkGroupCount as *const _
                as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxComputeWorkGroupInvocations
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupInvocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxComputeWorkGroupSize as *const _
                as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxComputeWorkGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).subPixelPrecisionBits as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subPixelPrecisionBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).subTexelPrecisionBits as *const _
                as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subTexelPrecisionBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).mipmapPrecisionBits as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(mipmapPrecisionBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDrawIndexedIndexValue as *const _
                as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDrawIndexedIndexValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxDrawIndirectCount as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxDrawIndirectCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxSamplerLodBias as *const _
                as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerLodBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxSamplerAnisotropy as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSamplerAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxViewports as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxViewports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxViewportDimensions as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxViewportDimensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).viewportBoundsRange as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(viewportBoundsRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).viewportSubPixelBits as *const _
                as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(viewportSubPixelBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minMemoryMapAlignment as *const _
                as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minMemoryMapAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minTexelBufferOffsetAlignment
                as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minUniformBufferOffsetAlignment
                as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minUniformBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minStorageBufferOffsetAlignment
                as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minStorageBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minTexelOffset as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxTexelOffset as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minTexelGatherOffset as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minTexelGatherOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxTexelGatherOffset as *const _
                as usize
        },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxTexelGatherOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).minInterpolationOffset as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(minInterpolationOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxInterpolationOffset as *const _
                as usize
        },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxInterpolationOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).subPixelInterpolationOffsetBits
                as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(subPixelInterpolationOffsetBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFramebufferWidth as *const _
                as usize
        },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFramebufferHeight as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxFramebufferLayers as *const _
                as usize
        },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxFramebufferLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).framebufferColorSampleCounts
                as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferColorSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).framebufferDepthSampleCounts
                as *const _ as usize
        },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferDepthSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).framebufferStencilSampleCounts
                as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferStencilSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).framebufferNoAttachmentsSampleCounts
                as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(framebufferNoAttachmentsSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxColorAttachments as *const _
                as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxColorAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).sampledImageColorSampleCounts
                as *const _ as usize
        },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageColorSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).sampledImageIntegerSampleCounts
                as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageIntegerSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).sampledImageDepthSampleCounts
                as *const _ as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageDepthSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).sampledImageStencilSampleCounts
                as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(sampledImageStencilSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).storageImageSampleCounts as *const _
                as usize
        },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(storageImageSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxSampleMaskWords as *const _
                as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxSampleMaskWords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).timestampComputeAndGraphics
                as *const _ as usize
        },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(timestampComputeAndGraphics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).timestampPeriod as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(timestampPeriod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxClipDistances as *const _ as usize
        },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxClipDistances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxCullDistances as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxCullDistances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).maxCombinedClipAndCullDistances
                as *const _ as usize
        },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(maxCombinedClipAndCullDistances)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).discreteQueuePriorities as *const _
                as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(discreteQueuePriorities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).pointSizeRange as *const _ as usize
        },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(pointSizeRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).lineWidthRange as *const _ as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(lineWidthRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).pointSizeGranularity as *const _
                as usize
        },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(pointSizeGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).lineWidthGranularity as *const _
                as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(lineWidthGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).strictLines as *const _ as usize
        },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(strictLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).standardSampleLocations as *const _
                as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(standardSampleLocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).optimalBufferCopyOffsetAlignment
                as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(optimalBufferCopyOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).optimalBufferCopyRowPitchAlignment
                as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(optimalBufferCopyRowPitchAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLimits>())).nonCoherentAtomSize as *const _
                as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLimits),
            "::",
            stringify!(nonCoherentAtomSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSparseProperties>(),
        20usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSparseProperties>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSparseProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseProperties>()))
                .residencyStandard2DBlockShape as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard2DBlockShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseProperties>()))
                .residencyStandard2DMultisampleBlockShape as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard2DMultisampleBlockShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseProperties>()))
                .residencyStandard3DBlockShape as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyStandard3DBlockShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseProperties>())).residencyAlignedMipSize
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyAlignedMipSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseProperties>())).residencyNonResidentStrict
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseProperties),
            "::",
            stringify!(residencyNonResidentStrict)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [u8; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProperties>(),
        824usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).apiVersion as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(apiVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).driverVersion as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(driverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).vendorID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(vendorID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).deviceID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).deviceType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).deviceName as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(deviceName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).pipelineCacheUUID as *const _
                as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(pipelineCacheUUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).limits as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties>())).sparseProperties as *const _
                as usize
        },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties),
            "::",
            stringify!(sparseProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: u32,
    pub timestampValidBits: u32,
    pub minImageTransferGranularity: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyProperties>(),
        24usize,
        concat!("Size of: ", stringify!(VkQueueFamilyProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkQueueFamilyProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyProperties>())).queueFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties),
            "::",
            stringify!(queueFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyProperties>())).queueCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties),
            "::",
            stringify!(queueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyProperties>())).timestampValidBits as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties),
            "::",
            stringify!(timestampValidBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyProperties>())).minImageTransferGranularity
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties),
            "::",
            stringify!(minImageTransferGranularity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryType() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryType>(),
        8usize,
        concat!("Size of: ", stringify!(VkMemoryType))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryType>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMemoryType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryType>())).propertyFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryType),
            "::",
            stringify!(propertyFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryType>())).heapIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryType),
            "::",
            stringify!(heapIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryHeap() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryHeap>(),
        16usize,
        concat!("Size of: ", stringify!(VkMemoryHeap))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryHeap>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryHeap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryHeap>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHeap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryHeap>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHeap),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties>(),
        520usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties>())).memoryTypeCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryTypeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties>())).memoryTypes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties>())).memoryHeapCount as *const _
                as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryHeapCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties>())).memoryHeaps as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties),
            "::",
            stringify!(memoryHeaps)
        )
    );
}
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: u32,
    pub queueCount: u32,
    pub pQueuePriorities: *const f32,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDeviceQueueCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceQueueCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).queueFamilyIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(queueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).queueCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(queueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueCreateInfo>())).pQueuePriorities as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueCreateInfo),
            "::",
            stringify!(pQueuePriorities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: u32,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkDeviceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceCreateInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).queueCreateInfoCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(queueCreateInfoCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).pQueueCreateInfos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(pQueueCreateInfos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).enabledLayerCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(enabledLayerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).ppEnabledLayerNames as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(ppEnabledLayerNames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).enabledExtensionCount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(enabledExtensionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).ppEnabledExtensionNames as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(ppEnabledExtensionNames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceCreateInfo>())).pEnabledFeatures as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceCreateInfo),
            "::",
            stringify!(pEnabledFeatures)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkExtensionProperties {
    pub extensionName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
}
#[test]
fn bindgen_test_layout_VkExtensionProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExtensionProperties>(),
        260usize,
        concat!("Size of: ", stringify!(VkExtensionProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtensionProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtensionProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExtensionProperties>())).extensionName as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtensionProperties),
            "::",
            stringify!(extensionName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExtensionProperties>())).specVersion as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtensionProperties),
            "::",
            stringify!(specVersion)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkLayerProperties {
    pub layerName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
    pub implementationVersion: u32,
    pub description: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkLayerProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkLayerProperties>(),
        520usize,
        concat!("Size of: ", stringify!(VkLayerProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkLayerProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkLayerProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkLayerProperties>())).layerName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkLayerProperties),
            "::",
            stringify!(layerName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkLayerProperties>())).specVersion as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(VkLayerProperties),
            "::",
            stringify!(specVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkLayerProperties>())).implementationVersion as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(VkLayerProperties),
            "::",
            stringify!(implementationVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkLayerProperties>())).description as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(VkLayerProperties),
            "::",
            stringify!(description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: u32,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubmitInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubmitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).waitSemaphoreCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(waitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).pWaitSemaphores as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(pWaitSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).pWaitDstStageMask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(pWaitDstStageMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).commandBufferCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(commandBufferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).pCommandBuffers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(pCommandBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubmitInfo>())).signalSemaphoreCount as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(signalSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubmitInfo>())).pSignalSemaphores as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubmitInfo),
            "::",
            stringify!(pSignalSemaphores)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryAllocateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryAllocateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryAllocateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryAllocateInfo>())).allocationSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(allocationSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryAllocateInfo>())).memoryTypeIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateInfo),
            "::",
            stringify!(memoryTypeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkMappedMemoryRange() {
    assert_eq!(
        ::std::mem::size_of::<VkMappedMemoryRange>(),
        40usize,
        concat!("Size of: ", stringify!(VkMappedMemoryRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMappedMemoryRange>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMappedMemoryRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMappedMemoryRange>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMappedMemoryRange>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMappedMemoryRange>())).memory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMappedMemoryRange>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMappedMemoryRange>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMappedMemoryRange),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryRequirements>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryRequirements>())).alignment as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryRequirements>())).memoryTypeBits as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements),
            "::",
            stringify!(memoryTypeBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageFormatProperties>(),
        20usize,
        concat!("Size of: ", stringify!(VkSparseImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageFormatProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSparseImageFormatProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties>())).aspectMask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties),
            "::",
            stringify!(aspectMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties>())).imageGranularity as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties),
            "::",
            stringify!(imageGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: u32,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryRequirements>(),
        48usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryRequirements))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements>())).formatProperties as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements),
            "::",
            stringify!(formatProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements>())).imageMipTailFirstLod
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements),
            "::",
            stringify!(imageMipTailFirstLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements>())).imageMipTailSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements),
            "::",
            stringify!(imageMipTailSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements>())).imageMipTailOffset
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements),
            "::",
            stringify!(imageMipTailOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements>())).imageMipTailStride
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements),
            "::",
            stringify!(imageMipTailStride)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseMemoryBind() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseMemoryBind>(),
        40usize,
        concat!("Size of: ", stringify!(VkSparseMemoryBind))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseMemoryBind>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseMemoryBind))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseMemoryBind>())).resourceOffset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseMemoryBind),
            "::",
            stringify!(resourceOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseMemoryBind>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseMemoryBind),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseMemoryBind>())).memory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseMemoryBind),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseMemoryBind>())).memoryOffset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseMemoryBind),
            "::",
            stringify!(memoryOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseMemoryBind>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseMemoryBind),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseBufferMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseBufferMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseBufferMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseBufferMemoryBindInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseBufferMemoryBindInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseBufferMemoryBindInfo>())).buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseBufferMemoryBindInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseBufferMemoryBindInfo>())).bindCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseBufferMemoryBindInfo),
            "::",
            stringify!(bindCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseBufferMemoryBindInfo>())).pBinds as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseBufferMemoryBindInfo),
            "::",
            stringify!(pBinds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageOpaqueMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageOpaqueMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseImageOpaqueMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageOpaqueMemoryBindInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSparseImageOpaqueMemoryBindInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageOpaqueMemoryBindInfo>())).image as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageOpaqueMemoryBindInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageOpaqueMemoryBindInfo>())).bindCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageOpaqueMemoryBindInfo),
            "::",
            stringify!(bindCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageOpaqueMemoryBindInfo>())).pBinds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageOpaqueMemoryBindInfo),
            "::",
            stringify!(pBinds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub arrayLayer: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresource() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresource>(),
        12usize,
        concat!("Size of: ", stringify!(VkImageSubresource))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresource>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageSubresource>())).aspectMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresource),
            "::",
            stringify!(aspectMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageSubresource>())).mipLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresource),
            "::",
            stringify!(mipLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageSubresource>())).arrayLayer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresource),
            "::",
            stringify!(arrayLayer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOffset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_VkOffset3D() {
    assert_eq!(
        ::std::mem::size_of::<VkOffset3D>(),
        12usize,
        concat!("Size of: ", stringify!(VkOffset3D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOffset3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkOffset3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkOffset3D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkOffset3D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkOffset3D>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset3D),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBind() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryBind>(),
        64usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryBind))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryBind>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryBind))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).subresource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(subresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).extent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).memory as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).memoryOffset as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(memoryOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSparseImageMemoryBind>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBind),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseImageMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryBindInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryBindInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryBindInfo>())).image as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBindInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryBindInfo>())).bindCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBindInfo),
            "::",
            stringify!(bindCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryBindInfo>())).pBinds as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryBindInfo),
            "::",
            stringify!(pBinds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: u32,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: u32,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: u32,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkBindSparseInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindSparseInfo>(),
        96usize,
        concat!("Size of: ", stringify!(VkBindSparseInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindSparseInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindSparseInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindSparseInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindSparseInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).waitSemaphoreCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(waitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).pWaitSemaphores as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pWaitSemaphores)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).bufferBindCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(bufferBindCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindSparseInfo>())).pBufferBinds as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pBufferBinds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).imageOpaqueBindCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(imageOpaqueBindCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).pImageOpaqueBinds as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pImageOpaqueBinds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindSparseInfo>())).imageBindCount as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(imageBindCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindSparseInfo>())).pImageBinds as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pImageBinds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).signalSemaphoreCount as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(signalSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindSparseInfo>())).pSignalSemaphores as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindSparseInfo),
            "::",
            stringify!(pSignalSemaphores)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFenceCreateFlags,
}
#[test]
fn bindgen_test_layout_VkFenceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFenceCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkFenceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFenceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFenceCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceCreateInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreCreateFlags,
}
#[test]
fn bindgen_test_layout_VkSemaphoreCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSemaphoreCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreCreateInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkEventCreateFlags,
}
#[test]
fn bindgen_test_layout_VkEventCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkEventCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkEventCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkEventCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkEventCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkEventCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkEventCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkEventCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkEventCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkEventCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkEventCreateInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: u32,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkQueryPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkQueryPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkQueryPoolCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).queryType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(queryType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).queryCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(queryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolCreateInfo>())).pipelineStatistics as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfo),
            "::",
            stringify!(pipelineStatistics)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).usage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCreateInfo>())).sharingMode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(sharingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferCreateInfo>())).queueFamilyIndexCount as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferCreateInfo>())).pQueueFamilyIndices as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCreateInfo),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferViewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferViewCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferViewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferViewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferViewCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferViewCreateInfo>())).range as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferViewCreateInfo),
            "::",
            stringify!(range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub initialLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkImageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(VkImageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).imageType as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(imageType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).extent as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).mipLevels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(mipLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).arrayLayers as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(arrayLayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).samples as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).tiling as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(tiling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).usage as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).sharingMode as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(sharingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageCreateInfo>())).queueFamilyIndexCount as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageCreateInfo>())).pQueueFamilyIndices as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCreateInfo>())).initialLayout as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCreateInfo),
            "::",
            stringify!(initialLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSubresourceLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkSubresourceLayout>(),
        40usize,
        concat!("Size of: ", stringify!(VkSubresourceLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubresourceLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubresourceLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubresourceLayout>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubresourceLayout),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubresourceLayout>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubresourceLayout),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubresourceLayout>())).rowPitch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubresourceLayout),
            "::",
            stringify!(rowPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubresourceLayout>())).arrayPitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubresourceLayout),
            "::",
            stringify!(arrayPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubresourceLayout>())).depthPitch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubresourceLayout),
            "::",
            stringify!(depthPitch)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}
#[test]
fn bindgen_test_layout_VkComponentMapping() {
    assert_eq!(
        ::std::mem::size_of::<VkComponentMapping>(),
        16usize,
        concat!("Size of: ", stringify!(VkComponentMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VkComponentMapping>(),
        4usize,
        concat!("Alignment of ", stringify!(VkComponentMapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkComponentMapping>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComponentMapping),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkComponentMapping>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComponentMapping),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkComponentMapping>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComponentMapping),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkComponentMapping>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComponentMapping),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: u32,
    pub levelCount: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceRange() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresourceRange>(),
        20usize,
        concat!("Size of: ", stringify!(VkImageSubresourceRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresourceRange>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresourceRange))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceRange>())).aspectMask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceRange),
            "::",
            stringify!(aspectMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceRange>())).baseMipLevel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceRange),
            "::",
            stringify!(baseMipLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceRange>())).levelCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceRange),
            "::",
            stringify!(levelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceRange>())).baseArrayLayer as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceRange),
            "::",
            stringify!(baseArrayLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceRange>())).layerCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceRange),
            "::",
            stringify!(layerCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageViewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewCreateInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VkImageViewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).image as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).viewType as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(viewType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewCreateInfo>())).format as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewCreateInfo>())).components as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewCreateInfo>())).subresourceRange as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewCreateInfo),
            "::",
            stringify!(subresourceRange)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: size_t,
    pub pCode: *const u32,
}
#[test]
fn bindgen_test_layout_VkShaderModuleCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderModuleCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkShaderModuleCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderModuleCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderModuleCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkShaderModuleCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkShaderModuleCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkShaderModuleCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderModuleCreateInfo>())).codeSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleCreateInfo),
            "::",
            stringify!(codeSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkShaderModuleCreateInfo>())).pCode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleCreateInfo),
            "::",
            stringify!(pCode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: size_t,
    pub pInitialData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkPipelineCacheCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCacheCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkPipelineCacheCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCacheCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineCacheCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineCacheCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCacheCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineCacheCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCacheCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineCacheCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCacheCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCacheCreateInfo>())).initialDataSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCacheCreateInfo),
            "::",
            stringify!(initialDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCacheCreateInfo>())).pInitialData as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCacheCreateInfo),
            "::",
            stringify!(pInitialData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSpecializationMapEntry {
    pub constantID: u32,
    pub offset: u32,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_VkSpecializationMapEntry() {
    assert_eq!(
        ::std::mem::size_of::<VkSpecializationMapEntry>(),
        16usize,
        concat!("Size of: ", stringify!(VkSpecializationMapEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSpecializationMapEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSpecializationMapEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSpecializationMapEntry>())).constantID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationMapEntry),
            "::",
            stringify!(constantID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSpecializationMapEntry>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationMapEntry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSpecializationMapEntry>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationMapEntry),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSpecializationInfo {
    pub mapEntryCount: u32,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: size_t,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkSpecializationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSpecializationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSpecializationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSpecializationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSpecializationInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSpecializationInfo>())).mapEntryCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationInfo),
            "::",
            stringify!(mapEntryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSpecializationInfo>())).pMapEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationInfo),
            "::",
            stringify!(pMapEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSpecializationInfo>())).dataSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationInfo),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSpecializationInfo>())).pData as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSpecializationInfo),
            "::",
            stringify!(pData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const ::std::os::raw::c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineShaderStageCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineShaderStageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineShaderStageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineShaderStageCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).stage as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).module as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).pName as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(pName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageCreateInfo>())).pSpecializationInfo
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageCreateInfo),
            "::",
            stringify!(pSpecializationInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub inputRate: VkVertexInputRate,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputBindingDescription>(),
        12usize,
        concat!("Size of: ", stringify!(VkVertexInputBindingDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputBindingDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(VkVertexInputBindingDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputBindingDescription>())).binding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputBindingDescription),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputBindingDescription>())).stride as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputBindingDescription),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputBindingDescription>())).inputRate as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputBindingDescription),
            "::",
            stringify!(inputRate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: VkFormat,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputAttributeDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputAttributeDescription>(),
        16usize,
        concat!("Size of: ", stringify!(VkVertexInputAttributeDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputAttributeDescription>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputAttributeDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputAttributeDescription>())).location as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputAttributeDescription),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputAttributeDescription>())).binding as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputAttributeDescription),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputAttributeDescription>())).format as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputAttributeDescription),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputAttributeDescription>())).offset as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputAttributeDescription),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: u32,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: u32,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
#[test]
fn bindgen_test_layout_VkPipelineVertexInputStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineVertexInputStateCreateInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineVertexInputStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineVertexInputStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineVertexInputStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>()))
                .vertexBindingDescriptionCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(vertexBindingDescriptionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>()))
                .pVertexBindingDescriptions as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(pVertexBindingDescriptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>()))
                .vertexAttributeDescriptionCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(vertexAttributeDescriptionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputStateCreateInfo>()))
                .pVertexAttributeDescriptions as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputStateCreateInfo),
            "::",
            stringify!(pVertexAttributeDescriptions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineInputAssemblyStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineInputAssemblyStateCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineInputAssemblyStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineInputAssemblyStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineInputAssemblyStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineInputAssemblyStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineInputAssemblyStateCreateInfo>())).topology as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo),
            "::",
            stringify!(topology)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineInputAssemblyStateCreateInfo>()))
                .primitiveRestartEnable as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo),
            "::",
            stringify!(primitiveRestartEnable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineTessellationStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineTessellationStateCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineTessellationStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineTessellationStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineTessellationStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationStateCreateInfo>())).patchControlPoints
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationStateCreateInfo),
            "::",
            stringify!(patchControlPoints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkViewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}
#[test]
fn bindgen_test_layout_VkViewport() {
    assert_eq!(
        ::std::mem::size_of::<VkViewport>(),
        24usize,
        concat!("Size of: ", stringify!(VkViewport))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewport>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).minDepth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(minDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewport>())).maxDepth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewport),
            "::",
            stringify!(maxDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOffset2D {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_VkOffset2D() {
    assert_eq!(
        ::std::mem::size_of::<VkOffset2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkOffset2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOffset2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkOffset2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkOffset2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkOffset2D>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkOffset2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExtent2D {
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_VkExtent2D() {
    assert_eq!(
        ::std::mem::size_of::<VkExtent2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkExtent2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtent2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExtent2D>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent2D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExtent2D>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExtent2D),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkRect2D() {
    assert_eq!(
        ::std::mem::size_of::<VkRect2D>(),
        16usize,
        concat!("Size of: ", stringify!(VkRect2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRect2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkRect2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRect2D>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRect2D),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRect2D>())).extent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRect2D),
            "::",
            stringify!(extent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: u32,
    pub pViewports: *const VkViewport,
    pub scissorCount: u32,
    pub pScissors: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportStateCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineViewportStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).viewportCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(viewportCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).pViewports as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(pViewports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).scissorCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(scissorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportStateCreateInfo>())).pScissors as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportStateCreateInfo),
            "::",
            stringify!(pScissors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateCreateInfo>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).depthClampEnable
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(depthClampEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>()))
                .rasterizerDiscardEnable as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(rasterizerDiscardEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).polygonMode
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(polygonMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).cullMode as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(cullMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).frontFace as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(frontFace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).depthBiasEnable
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(depthBiasEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>()))
                .depthBiasConstantFactor as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(depthBiasConstantFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).depthBiasClamp
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(depthBiasClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).depthBiasSlopeFactor
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(depthBiasSlopeFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateCreateInfo>())).lineWidth as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateCreateInfo),
            "::",
            stringify!(lineWidth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineMultisampleStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineMultisampleStateCreateInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineMultisampleStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineMultisampleStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineMultisampleStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).rasterizationSamples
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(rasterizationSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).sampleShadingEnable
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(sampleShadingEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).minSampleShading
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(minSampleShading)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).pSampleMask as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(pSampleMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).alphaToCoverageEnable
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(alphaToCoverageEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineMultisampleStateCreateInfo>())).alphaToOneEnable
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineMultisampleStateCreateInfo),
            "::",
            stringify!(alphaToOneEnable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: u32,
    pub writeMask: u32,
    pub reference: u32,
}
#[test]
fn bindgen_test_layout_VkStencilOpState() {
    assert_eq!(
        ::std::mem::size_of::<VkStencilOpState>(),
        28usize,
        concat!("Size of: ", stringify!(VkStencilOpState))
    );
    assert_eq!(
        ::std::mem::align_of::<VkStencilOpState>(),
        4usize,
        concat!("Alignment of ", stringify!(VkStencilOpState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).failOp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(failOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).passOp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(passOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).depthFailOp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(depthFailOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).compareOp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(compareOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).compareMask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(compareMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).writeMask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(writeMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkStencilOpState>())).reference as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkStencilOpState),
            "::",
            stringify!(reference)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineDepthStencilStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDepthStencilStateCreateInfo>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDepthStencilStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDepthStencilStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).depthTestEnable
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(depthTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).depthWriteEnable
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(depthWriteEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).depthCompareOp
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(depthCompareOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).depthBoundsTestEnable
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(depthBoundsTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).stencilTestEnable
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(stencilTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).front as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(front)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).back as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(back)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).minDepthBounds
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(minDepthBounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDepthStencilStateCreateInfo>())).maxDepthBounds
                as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo),
            "::",
            stringify!(maxDepthBounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAttachmentState() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendAttachmentState>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineColorBlendAttachmentState))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendAttachmentState>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendAttachmentState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).blendEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(blendEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).srcColorBlendFactor
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(srcColorBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).dstColorBlendFactor
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(dstColorBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).colorBlendOp as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(colorBlendOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).srcAlphaBlendFactor
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(srcAlphaBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).dstAlphaBlendFactor
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(dstAlphaBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).alphaBlendOp as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(alphaBlendOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAttachmentState>())).colorWriteMask
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAttachmentState),
            "::",
            stringify!(colorWriteMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: u32,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendStateCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkPipelineColorBlendStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).logicOpEnable
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(logicOpEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).logicOp as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(logicOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).attachmentCount
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(attachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).pAttachments as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(pAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendStateCreateInfo>())).blendConstants
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendStateCreateInfo),
            "::",
            stringify!(blendConstants)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: u32,
    pub pDynamicStates: *const VkDynamicState,
}
#[test]
fn bindgen_test_layout_VkPipelineDynamicStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDynamicStateCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineDynamicStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDynamicStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDynamicStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDynamicStateCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDynamicStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDynamicStateCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDynamicStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDynamicStateCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDynamicStateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDynamicStateCreateInfo>())).dynamicStateCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDynamicStateCreateInfo),
            "::",
            stringify!(dynamicStateCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDynamicStateCreateInfo>())).pDynamicStates as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDynamicStateCreateInfo),
            "::",
            stringify!(pDynamicStates)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkGraphicsPipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkGraphicsPipelineCreateInfo>(),
        144usize,
        concat!("Size of: ", stringify!(VkGraphicsPipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGraphicsPipelineCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGraphicsPipelineCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).stageCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(stageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pStages as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pVertexInputState as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pVertexInputState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pInputAssemblyState as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pInputAssemblyState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pTessellationState as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pTessellationState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pViewportState as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pViewportState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pRasterizationState as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pRasterizationState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pMultisampleState as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pMultisampleState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pDepthStencilState as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pDepthStencilState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pColorBlendState as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pColorBlendState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).pDynamicState as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(pDynamicState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).layout as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).renderPass as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(renderPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).subpass as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(subpass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).basePipelineHandle as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(basePipelineHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGraphicsPipelineCreateInfo>())).basePipelineIndex as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGraphicsPipelineCreateInfo),
            "::",
            stringify!(basePipelineIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkComputePipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkComputePipelineCreateInfo>(),
        96usize,
        concat!("Size of: ", stringify!(VkComputePipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkComputePipelineCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkComputePipelineCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).stage as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).layout as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).basePipelineHandle as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(basePipelineHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkComputePipelineCreateInfo>())).basePipelineIndex as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkComputePipelineCreateInfo),
            "::",
            stringify!(basePipelineIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_VkPushConstantRange() {
    assert_eq!(
        ::std::mem::size_of::<VkPushConstantRange>(),
        12usize,
        concat!("Size of: ", stringify!(VkPushConstantRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPushConstantRange>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPushConstantRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPushConstantRange>())).stageFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPushConstantRange),
            "::",
            stringify!(stageFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPushConstantRange>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPushConstantRange),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPushConstantRange>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPushConstantRange),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: u32,
    pub pPushConstantRanges: *const VkPushConstantRange,
}
#[test]
fn bindgen_test_layout_VkPipelineLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineLayoutCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineLayoutCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineLayoutCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineLayoutCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).setLayoutCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(setLayoutCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).pSetLayouts as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(pSetLayouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).pushConstantRangeCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(pushConstantRangeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineLayoutCreateInfo>())).pPushConstantRanges as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineLayoutCreateInfo),
            "::",
            stringify!(pPushConstantRanges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerCreateInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VkSamplerCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSamplerCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).magFilter as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(magFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).minFilter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(minFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).mipmapMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(mipmapMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).addressModeU as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(addressModeU)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).addressModeV as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(addressModeV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).addressModeW as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(addressModeW)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).mipLodBias as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(mipLodBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).anisotropyEnable as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(anisotropyEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).maxAnisotropy as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).compareEnable as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(compareEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).compareOp as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(compareOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).minLod as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(minLod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).maxLod as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(maxLod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSamplerCreateInfo>())).borderColor as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerCreateInfo>())).unnormalizedCoordinates as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerCreateInfo),
            "::",
            stringify!(unnormalizedCoordinates)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutBinding {
    pub binding: u32,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: u32,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutBinding() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutBinding>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutBinding))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutBinding>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutBinding))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBinding>())).binding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBinding),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBinding>())).descriptorType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBinding),
            "::",
            stringify!(descriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBinding>())).descriptorCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBinding),
            "::",
            stringify!(descriptorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBinding>())).stageFlags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBinding),
            "::",
            stringify!(stageFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBinding>())).pImmutableSamplers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBinding),
            "::",
            stringify!(pImmutableSamplers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: u32,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutCreateInfo>())).bindingCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutCreateInfo),
            "::",
            stringify!(bindingCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutCreateInfo>())).pBindings as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutCreateInfo),
            "::",
            stringify!(pBindings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolSize {
    pub type_: VkDescriptorType,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolSize() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolSize>(),
        8usize,
        concat!("Size of: ", stringify!(VkDescriptorPoolSize))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolSize>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDescriptorPoolSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorPoolSize>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolSize),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolSize>())).descriptorCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolSize),
            "::",
            stringify!(descriptorCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: u32,
    pub poolSizeCount: u32,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDescriptorPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorPoolCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).maxSets as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(maxSets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).poolSizeCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(poolSizeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolCreateInfo>())).pPoolSizes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolCreateInfo),
            "::",
            stringify!(pPoolSizes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetAllocateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDescriptorSetAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetAllocateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetAllocateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetAllocateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetAllocateInfo>())).descriptorPool as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetAllocateInfo),
            "::",
            stringify!(descriptorPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetAllocateInfo>())).descriptorSetCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetAllocateInfo),
            "::",
            stringify!(descriptorSetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetAllocateInfo>())).pSetLayouts as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetAllocateInfo),
            "::",
            stringify!(pSetLayouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorImageInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorImageInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorImageInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorImageInfo>())).sampler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorImageInfo),
            "::",
            stringify!(sampler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorImageInfo>())).imageView as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorImageInfo),
            "::",
            stringify!(imageView)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorImageInfo>())).imageLayout as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorImageInfo),
            "::",
            stringify!(imageLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorBufferInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorBufferInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorBufferInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorBufferInfo>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorBufferInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorBufferInfo>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorBufferInfo),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDescriptorBufferInfo>())).range as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorBufferInfo),
            "::",
            stringify!(range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSet() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSet>(),
        64usize,
        concat!("Size of: ", stringify!(VkWriteDescriptorSet))
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSet>(),
        8usize,
        concat!("Alignment of ", stringify!(VkWriteDescriptorSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkWriteDescriptorSet>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkWriteDescriptorSet>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkWriteDescriptorSet>())).dstSet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(dstSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkWriteDescriptorSet>())).dstBinding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(dstBinding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSet>())).dstArrayElement as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(dstArrayElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSet>())).descriptorCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(descriptorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSet>())).descriptorType as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(descriptorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkWriteDescriptorSet>())).pImageInfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(pImageInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSet>())).pBufferInfo as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(pBufferInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSet>())).pTexelBufferView as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSet),
            "::",
            stringify!(pTexelBufferView)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: u32,
    pub srcArrayElement: u32,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkCopyDescriptorSet() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyDescriptorSet>(),
        56usize,
        concat!("Size of: ", stringify!(VkCopyDescriptorSet))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyDescriptorSet>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyDescriptorSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).srcSet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(srcSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).srcBinding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(srcBinding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCopyDescriptorSet>())).srcArrayElement as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(srcArrayElement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).dstSet as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(dstSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCopyDescriptorSet>())).dstBinding as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(dstBinding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCopyDescriptorSet>())).dstArrayElement as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(dstArrayElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCopyDescriptorSet>())).descriptorCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCopyDescriptorSet),
            "::",
            stringify!(descriptorCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: u32,
    pub pAttachments: *const VkImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
#[test]
fn bindgen_test_layout_VkFramebufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkFramebufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFramebufferCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).renderPass as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(renderPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).attachmentCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(attachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).pAttachments as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(pAttachments)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFramebufferCreateInfo>())).layers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferCreateInfo),
            "::",
            stringify!(layers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescription>(),
        36usize,
        concat!("Size of: ", stringify!(VkAttachmentDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(VkAttachmentDescription))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription>())).samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription>())).loadOp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(loadOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription>())).storeOp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(storeOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription>())).stencilLoadOp as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(stencilLoadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription>())).stencilStoreOp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(stencilStoreOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription>())).initialLayout as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(initialLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription>())).finalLayout as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription),
            "::",
            stringify!(finalLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReference {
    pub attachment: u32,
    pub layout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentReference() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReference>(),
        8usize,
        concat!("Size of: ", stringify!(VkAttachmentReference))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReference>(),
        4usize,
        concat!("Alignment of ", stringify!(VkAttachmentReference))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReference>())).attachment as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference),
            "::",
            stringify!(attachment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentReference>())).layout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference),
            "::",
            stringify!(layout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: *const u32,
}
#[test]
fn bindgen_test_layout_VkSubpassDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescription>(),
        72usize,
        concat!("Size of: ", stringify!(VkSubpassDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDescription))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDescription>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pipelineBindPoint as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pipelineBindPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).inputAttachmentCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(inputAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pInputAttachments as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).colorAttachmentCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(colorAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pColorAttachments as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pColorAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pResolveAttachments as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pResolveAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pDepthStencilAttachment as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pDepthStencilAttachment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).preserveAttachmentCount as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(preserveAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription>())).pPreserveAttachments as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription),
            "::",
            stringify!(pPreserveAttachments)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDependency {
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}
#[test]
fn bindgen_test_layout_VkSubpassDependency() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDependency>(),
        28usize,
        concat!("Size of: ", stringify!(VkSubpassDependency))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDependency>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSubpassDependency))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency>())).srcSubpass as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(srcSubpass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency>())).dstSubpass as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(dstSubpass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency>())).srcStageMask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(srcStageMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency>())).dstStageMask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(dstStageMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency>())).srcAccessMask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(srcAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency>())).dstAccessMask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(dstAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency>())).dependencyFlags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency),
            "::",
            stringify!(dependencyFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: u32,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: u32,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: u32,
    pub pDependencies: *const VkSubpassDependency,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).attachmentCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(attachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).pAttachments as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(pAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).subpassCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(subpassCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).pSubpasses as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(pSubpasses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).dependencyCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(dependencyCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo>())).pDependencies as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo),
            "::",
            stringify!(pDependencies)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: u32,
}
#[test]
fn bindgen_test_layout_VkCommandPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandPoolCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkCommandPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandPoolCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandPoolCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandPoolCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandPoolCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandPoolCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandPoolCreateInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandPoolCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandPoolCreateInfo>())).queueFamilyIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandPoolCreateInfo),
            "::",
            stringify!(queueFamilyIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: u32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkCommandBufferAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferAllocateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferAllocateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferAllocateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferAllocateInfo>())).commandPool as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferAllocateInfo),
            "::",
            stringify!(commandPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferAllocateInfo>())).level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferAllocateInfo),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferAllocateInfo>())).commandBufferCount as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferAllocateInfo),
            "::",
            stringify!(commandBufferCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkCommandBufferInheritanceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferInheritanceInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).renderPass as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(renderPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).subpass as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(subpass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).framebuffer as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).occlusionQueryEnable
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(occlusionQueryEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).queryFlags as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(queryFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceInfo>())).pipelineStatistics
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceInfo),
            "::",
            stringify!(pipelineStatistics)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
#[test]
fn bindgen_test_layout_VkCommandBufferBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkCommandBufferBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferBeginInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandBufferBeginInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandBufferBeginInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCommandBufferBeginInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferBeginInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferBeginInfo>())).pInheritanceInfo as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferBeginInfo),
            "::",
            stringify!(pInheritanceInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCopy>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCopy>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCopy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCopy>())).srcOffset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(srcOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCopy>())).dstOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(dstOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferCopy>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferCopy),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceLayers() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresourceLayers>(),
        16usize,
        concat!("Size of: ", stringify!(VkImageSubresourceLayers))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresourceLayers>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresourceLayers))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceLayers>())).aspectMask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceLayers),
            "::",
            stringify!(aspectMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceLayers>())).mipLevel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceLayers),
            "::",
            stringify!(mipLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceLayers>())).baseArrayLayer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceLayers),
            "::",
            stringify!(baseArrayLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSubresourceLayers>())).layerCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSubresourceLayers),
            "::",
            stringify!(layerCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCopy>(),
        68usize,
        concat!("Size of: ", stringify!(VkImageCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCopy>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageCopy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCopy>())).srcSubresource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCopy),
            "::",
            stringify!(srcSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCopy>())).srcOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCopy),
            "::",
            stringify!(srcOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCopy>())).dstSubresource as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCopy),
            "::",
            stringify!(dstSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCopy>())).dstOffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCopy),
            "::",
            stringify!(dstOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageCopy>())).extent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageCopy),
            "::",
            stringify!(extent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}
#[test]
fn bindgen_test_layout_VkImageBlit() {
    assert_eq!(
        ::std::mem::size_of::<VkImageBlit>(),
        80usize,
        concat!("Size of: ", stringify!(VkImageBlit))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageBlit>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageBlit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageBlit>())).srcSubresource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageBlit),
            "::",
            stringify!(srcSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageBlit>())).srcOffsets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageBlit),
            "::",
            stringify!(srcOffsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageBlit>())).dstSubresource as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageBlit),
            "::",
            stringify!(dstSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageBlit>())).dstOffsets as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageBlit),
            "::",
            stringify!(dstOffsets)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkBufferImageCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferImageCopy>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferImageCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferImageCopy>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferImageCopy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferImageCopy>())).bufferOffset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(bufferOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferImageCopy>())).bufferRowLength as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(bufferRowLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferImageCopy>())).bufferImageHeight as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(bufferImageHeight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferImageCopy>())).imageSubresource as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(imageSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferImageCopy>())).imageOffset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(imageOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferImageCopy>())).imageExtent as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferImageCopy),
            "::",
            stringify!(imageExtent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearColorValue {
    pub float32: [f32; 4usize],
    pub int32: [i32; 4usize],
    pub uint32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VkClearColorValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearColorValue>(),
        16usize,
        concat!("Size of: ", stringify!(VkClearColorValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearColorValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearColorValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearColorValue>())).float32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearColorValue),
            "::",
            stringify!(float32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearColorValue>())).int32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearColorValue),
            "::",
            stringify!(int32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearColorValue>())).uint32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearColorValue),
            "::",
            stringify!(uint32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_VkClearDepthStencilValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearDepthStencilValue>(),
        8usize,
        concat!("Size of: ", stringify!(VkClearDepthStencilValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearDepthStencilValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearDepthStencilValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearDepthStencilValue>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearDepthStencilValue),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkClearDepthStencilValue>())).stencil as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearDepthStencilValue),
            "::",
            stringify!(stencil)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearValue {
    pub color: VkClearColorValue,
    pub depthStencil: VkClearDepthStencilValue,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VkClearValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearValue>(),
        16usize,
        concat!("Size of: ", stringify!(VkClearValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearValue>())).color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearValue),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearValue>())).depthStencil as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearValue),
            "::",
            stringify!(depthStencil)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: u32,
    pub clearValue: VkClearValue,
}
#[test]
fn bindgen_test_layout_VkClearAttachment() {
    assert_eq!(
        ::std::mem::size_of::<VkClearAttachment>(),
        24usize,
        concat!("Size of: ", stringify!(VkClearAttachment))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearAttachment>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearAttachment))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearAttachment>())).aspectMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearAttachment),
            "::",
            stringify!(aspectMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkClearAttachment>())).colorAttachment as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearAttachment),
            "::",
            stringify!(colorAttachment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearAttachment>())).clearValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearAttachment),
            "::",
            stringify!(clearValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkClearRect() {
    assert_eq!(
        ::std::mem::size_of::<VkClearRect>(),
        24usize,
        concat!("Size of: ", stringify!(VkClearRect))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearRect>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearRect>())).rect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearRect),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearRect>())).baseArrayLayer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearRect),
            "::",
            stringify!(baseArrayLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkClearRect>())).layerCount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkClearRect),
            "::",
            stringify!(layerCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageResolve() {
    assert_eq!(
        ::std::mem::size_of::<VkImageResolve>(),
        68usize,
        concat!("Size of: ", stringify!(VkImageResolve))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageResolve>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageResolve))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageResolve>())).srcSubresource as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageResolve),
            "::",
            stringify!(srcSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageResolve>())).srcOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageResolve),
            "::",
            stringify!(srcOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageResolve>())).dstSubresource as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageResolve),
            "::",
            stringify!(dstSubresource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageResolve>())).dstOffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageResolve),
            "::",
            stringify!(dstOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageResolve>())).extent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageResolve),
            "::",
            stringify!(extent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryBarrier>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryBarrier>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryBarrier),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryBarrier>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryBarrier),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryBarrier>())).srcAccessMask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryBarrier),
            "::",
            stringify!(srcAccessMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryBarrier>())).dstAccessMask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryBarrier),
            "::",
            stringify!(dstAccessMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryBarrier>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).srcAccessMask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(srcAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).dstAccessMask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(dstAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).srcQueueFamilyIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(srcQueueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).dstQueueFamilyIndex as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(dstQueueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).offset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferMemoryBarrier>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryBarrier),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryBarrier>(),
        72usize,
        concat!("Size of: ", stringify!(VkImageMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryBarrier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageMemoryBarrier>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageMemoryBarrier>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryBarrier>())).srcAccessMask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(srcAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryBarrier>())).dstAccessMask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(dstAccessMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageMemoryBarrier>())).oldLayout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(oldLayout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageMemoryBarrier>())).newLayout as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(newLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryBarrier>())).srcQueueFamilyIndex as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(srcQueueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryBarrier>())).dstQueueFamilyIndex as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(dstQueueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageMemoryBarrier>())).image as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryBarrier>())).subresourceRange as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryBarrier),
            "::",
            stringify!(subresourceRange)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: u32,
    pub pClearValues: *const VkClearValue,
}
#[test]
fn bindgen_test_layout_VkRenderPassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassBeginInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassBeginInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).renderPass as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(renderPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).framebuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).renderArea as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(renderArea)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).clearValueCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(clearValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassBeginInfo>())).pClearValues as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassBeginInfo),
            "::",
            stringify!(pClearValues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
#[test]
fn bindgen_test_layout_VkDispatchIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDispatchIndirectCommand>(),
        12usize,
        concat!("Size of: ", stringify!(VkDispatchIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDispatchIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDispatchIndirectCommand))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDispatchIndirectCommand>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDispatchIndirectCommand),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDispatchIndirectCommand>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDispatchIndirectCommand),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDispatchIndirectCommand>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDispatchIndirectCommand),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrawIndexedIndirectCommand {
    pub indexCount: u32,
    pub instanceCount: u32,
    pub firstIndex: u32,
    pub vertexOffset: i32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndexedIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawIndexedIndirectCommand>(),
        20usize,
        concat!("Size of: ", stringify!(VkDrawIndexedIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawIndexedIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDrawIndexedIndirectCommand))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndexedIndirectCommand>())).indexCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndexedIndirectCommand),
            "::",
            stringify!(indexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndexedIndirectCommand>())).instanceCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndexedIndirectCommand),
            "::",
            stringify!(instanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndexedIndirectCommand>())).firstIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndexedIndirectCommand),
            "::",
            stringify!(firstIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndexedIndirectCommand>())).vertexOffset as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndexedIndirectCommand),
            "::",
            stringify!(vertexOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndexedIndirectCommand>())).firstInstance as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndexedIndirectCommand),
            "::",
            stringify!(firstInstance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrawIndirectCommand {
    pub vertexCount: u32,
    pub instanceCount: u32,
    pub firstVertex: u32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawIndirectCommand>(),
        16usize,
        concat!("Size of: ", stringify!(VkDrawIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDrawIndirectCommand))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndirectCommand>())).vertexCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndirectCommand),
            "::",
            stringify!(vertexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndirectCommand>())).instanceCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndirectCommand),
            "::",
            stringify!(instanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndirectCommand>())).firstVertex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndirectCommand),
            "::",
            stringify!(firstVertex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawIndirectCommand>())).firstInstance as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawIndirectCommand),
            "::",
            stringify!(firstInstance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBaseOutStructure {
    pub sType: VkStructureType,
    pub pNext: *mut VkBaseOutStructure,
}
#[test]
fn bindgen_test_layout_VkBaseOutStructure() {
    assert_eq!(
        ::std::mem::size_of::<VkBaseOutStructure>(),
        16usize,
        concat!("Size of: ", stringify!(VkBaseOutStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBaseOutStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBaseOutStructure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBaseOutStructure>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBaseOutStructure),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBaseOutStructure>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBaseOutStructure),
            "::",
            stringify!(pNext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBaseInStructure {
    pub sType: VkStructureType,
    pub pNext: *const VkBaseInStructure,
}
#[test]
fn bindgen_test_layout_VkBaseInStructure() {
    assert_eq!(
        ::std::mem::size_of::<VkBaseInStructure>(),
        16usize,
        concat!("Size of: ", stringify!(VkBaseInStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBaseInStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBaseInStructure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBaseInStructure>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBaseInStructure),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBaseInStructure>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBaseInStructure),
            "::",
            stringify!(pNext)
        )
    );
}
pub type PFN_vkCreateInstance = ::std::option::Option<
    unsafe extern "C" fn(
        pCreateInfo: *const VkInstanceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance,
    ) -> VkResult,
>;
pub type PFN_vkDestroyInstance = ::std::option::Option<
    unsafe extern "C" fn(instance: VkInstance, pAllocator: *const VkAllocationCallbacks),
>;
pub type PFN_vkEnumeratePhysicalDevices = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut u32,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceFeatures = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    ),
>;
pub type PFN_vkGetInstanceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkGetDeviceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkCreateDevice = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDevice: *mut VkDevice,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDevice = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks),
>;
pub type PFN_vkEnumerateInstanceExtensionProperties = ::std::option::Option<
    unsafe extern "C" fn(
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult,
>;
pub type PFN_vkEnumerateDeviceExtensionProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult,
>;
pub type PFN_vkEnumerateInstanceLayerProperties = ::std::option::Option<
    unsafe extern "C" fn(pPropertyCount: *mut u32, pProperties: *mut VkLayerProperties) -> VkResult,
>;
pub type PFN_vkEnumerateDeviceLayerProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceQueue = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queueFamilyIndex: u32,
        queueIndex: u32,
        pQueue: *mut VkQueue,
    ),
>;
pub type PFN_vkQueueSubmit = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkQueueWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue) -> VkResult>;
pub type PFN_vkDeviceWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice) -> VkResult>;
pub type PFN_vkAllocateMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult,
>;
pub type PFN_vkFreeMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMapMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkInvalidateMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceMemoryCommitment = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    ),
>;
pub type PFN_vkBindBufferMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkGetBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties,
    ),
>;
pub type PFN_vkQueueBindSparse = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        bindInfoCount: u32,
        pBindInfo: *const VkBindSparseInfo,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkCreateFence = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkDestroyFence = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        fence: VkFence,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetFences = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult,
>;
pub type PFN_vkGetFenceStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, fence: VkFence) -> VkResult>;
pub type PFN_vkWaitForFences = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        fenceCount: u32,
        pFences: *const VkFence,
        waitAll: VkBool32,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkCreateSemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSemaphore: *mut VkSemaphore,
    ) -> VkResult,
>;
pub type PFN_vkDestroySemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        semaphore: VkSemaphore,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateEvent = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pEvent: *mut VkEvent,
    ) -> VkResult,
>;
pub type PFN_vkDestroyEvent = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        event: VkEvent,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetEventStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkSetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkResetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkCreateQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pQueryPool: *mut VkQueryPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetQueryPoolResults = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ) -> VkResult,
>;
pub type PFN_vkCreateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateBufferView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBufferView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetImageSubresourceLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    ),
>;
pub type PFN_vkCreateImageView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImageView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateShaderModule = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult,
>;
pub type PFN_vkDestroyShaderModule = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreatePipelineCache = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipelineCache = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetPipelineCacheData = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pDataSize: *mut size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkMergePipelineCaches = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        dstCache: VkPipelineCache,
        srcCacheCount: u32,
        pSrcCaches: *const VkPipelineCache,
    ) -> VkResult,
>;
pub type PFN_vkCreateGraphicsPipelines = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkCreateComputePipelines = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipeline = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreatePipelineLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipelineLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateSampler = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSampler: *mut VkSampler,
    ) -> VkResult,
>;
pub type PFN_vkDestroySampler = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        sampler: VkSampler,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorSetLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorSetLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        flags: VkDescriptorPoolResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkAllocateDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult,
>;
pub type PFN_vkFreeDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
    ) -> VkResult,
>;
pub type PFN_vkUpdateDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: u32,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    ),
>;
pub type PFN_vkCreateFramebuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyFramebuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkDestroyRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        renderPass: VkRenderPass,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetRenderAreaGranularity = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D),
>;
pub type PFN_vkCreateCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkAllocateCommandBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult,
>;
pub type PFN_vkFreeCommandBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    ),
>;
pub type PFN_vkBeginCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult,
>;
pub type PFN_vkEndCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer) -> VkResult>;
pub type PFN_vkResetCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        flags: VkCommandBufferResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkCmdBindPipeline = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
    ),
>;
pub type PFN_vkCmdSetViewport = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewports: *const VkViewport,
    ),
>;
pub type PFN_vkCmdSetScissor = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstScissor: u32,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    ),
>;
pub type PFN_vkCmdSetLineWidth =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, lineWidth: f32)>;
pub type PFN_vkCmdSetDepthBias = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        depthBiasConstantFactor: f32,
        depthBiasClamp: f32,
        depthBiasSlopeFactor: f32,
    ),
>;
pub type PFN_vkCmdSetBlendConstants = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, blendConstants: *const f32),
>;
pub type PFN_vkCmdSetDepthBounds = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32),
>;
pub type PFN_vkCmdSetStencilCompareMask = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        compareMask: u32,
    ),
>;
pub type PFN_vkCmdSetStencilWriteMask = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        writeMask: u32,
    ),
>;
pub type PFN_vkCmdSetStencilReference = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        reference: u32,
    ),
>;
pub type PFN_vkCmdBindDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: u32,
        pDynamicOffsets: *const u32,
    ),
>;
pub type PFN_vkCmdBindIndexBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        indexType: VkIndexType,
    ),
>;
pub type PFN_vkCmdBindVertexBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdDraw = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        vertexCount: u32,
        instanceCount: u32,
        firstVertex: u32,
        firstInstance: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexed = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        indexCount: u32,
        instanceCount: u32,
        firstIndex: u32,
        vertexOffset: i32,
        firstInstance: u32,
    ),
>;
pub type PFN_vkCmdDrawIndirect = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirect = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDispatch = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
pub type PFN_vkCmdDispatchIndirect = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize),
>;
pub type PFN_vkCmdCopyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    ),
>;
pub type PFN_vkCmdCopyImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageCopy,
    ),
>;
pub type PFN_vkCmdBlitImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageBlit,
        filter: VkFilter,
    ),
>;
pub type PFN_vkCmdCopyBufferToImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    ),
>;
pub type PFN_vkCmdCopyImageToBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    ),
>;
pub type PFN_vkCmdUpdateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        dataSize: VkDeviceSize,
        pData: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkCmdFillBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        size: VkDeviceSize,
        data: u32,
    ),
>;
pub type PFN_vkCmdClearColorImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pColor: *const VkClearColorValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    ),
>;
pub type PFN_vkCmdClearDepthStencilImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    ),
>;
pub type PFN_vkCmdClearAttachments = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pAttachments: *const VkClearAttachment,
        rectCount: u32,
        pRects: *const VkClearRect,
    ),
>;
pub type PFN_vkCmdResolveImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageResolve,
    ),
>;
pub type PFN_vkCmdSetEvent = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    ),
>;
pub type PFN_vkCmdResetEvent = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    ),
>;
pub type PFN_vkCmdWaitEvents = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    ),
>;
pub type PFN_vkCmdPipelineBarrier = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    ),
>;
pub type PFN_vkCmdBeginQuery = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
    ),
>;
pub type PFN_vkCmdEndQuery = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32),
>;
pub type PFN_vkCmdResetQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
pub type PFN_vkCmdWriteTimestamp = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        queryPool: VkQueryPool,
        query: u32,
    ),
>;
pub type PFN_vkCmdCopyQueryPoolResults = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ),
>;
pub type PFN_vkCmdPushConstants = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        layout: VkPipelineLayout,
        stageFlags: VkShaderStageFlags,
        offset: u32,
        size: u32,
        pValues: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkCmdBeginRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    ),
>;
pub type PFN_vkCmdNextSubpass = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, contents: VkSubpassContents),
>;
pub type PFN_vkCmdEndRenderPass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdExecuteCommands = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    ),
>;
extern "C" {
    pub fn vkCreateInstance(
        pCreateInfo: *const VkInstanceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyInstance(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumeratePhysicalDevices(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut u32,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    pub fn vkGetInstanceProcAddr(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkGetDeviceProcAddr(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkCreateDevice(
        physicalDevice: VkPhysicalDevice,
        pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDevice: *mut VkDevice,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDevice(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumerateInstanceExtensionProperties(
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceExtensionProperties(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateInstanceLayerProperties(
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceLayerProperties(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceQueue(
        device: VkDevice,
        queueFamilyIndex: u32,
        queueIndex: u32,
        pQueue: *mut VkQueue,
    );
}
extern "C" {
    pub fn vkQueueSubmit(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
}
extern "C" {
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
}
extern "C" {
    pub fn vkAllocateMemory(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkMapMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
}
extern "C" {
    pub fn vkFlushMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
}
extern "C" {
    pub fn vkInvalidateMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceMemoryCommitment(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    );
}
extern "C" {
    pub fn vkBindBufferMemory(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetImageMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties,
    );
}
extern "C" {
    pub fn vkQueueBindSparse(
        queue: VkQueue,
        bindInfoCount: u32,
        pBindInfo: *const VkBindSparseInfo,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateFence(
        device: VkDevice,
        pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFence(
        device: VkDevice,
        fence: VkFence,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetFences(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
}
extern "C" {
    pub fn vkWaitForFences(
        device: VkDevice,
        fenceCount: u32,
        pFences: *const VkFence,
        waitAll: VkBool32,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateSemaphore(
        device: VkDevice,
        pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSemaphore: *mut VkSemaphore,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySemaphore(
        device: VkDevice,
        semaphore: VkSemaphore,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateEvent(
        device: VkDevice,
        pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pEvent: *mut VkEvent,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyEvent(
        device: VkDevice,
        event: VkEvent,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkCreateQueryPool(
        device: VkDevice,
        pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pQueryPool: *mut VkQueryPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyQueryPool(
        device: VkDevice,
        queryPool: VkQueryPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetQueryPoolResults(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateBuffer(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBuffer(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateBufferView(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBufferView(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateImage(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImage(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetImageSubresourceLayout(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    );
}
extern "C" {
    pub fn vkCreateImageView(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImageView(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateShaderModule(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyShaderModule(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreatePipelineCache(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineCache(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetPipelineCacheData(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pDataSize: *mut size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkMergePipelineCaches(
        device: VkDevice,
        dstCache: VkPipelineCache,
        srcCacheCount: u32,
        pSrcCaches: *const VkPipelineCache,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateGraphicsPipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateComputePipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipeline(
        device: VkDevice,
        pipeline: VkPipeline,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreatePipelineLayout(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineLayout(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateSampler(
        device: VkDevice,
        pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSampler: *mut VkSampler,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySampler(
        device: VkDevice,
        sampler: VkSampler,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorSetLayout(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorSetLayout(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorPool(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        flags: VkDescriptorPoolResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAllocateDescriptorSets(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeDescriptorSets(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUpdateDescriptorSets(
        device: VkDevice,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: u32,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    );
}
extern "C" {
    pub fn vkCreateFramebuffer(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFramebuffer(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateRenderPass(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyRenderPass(
        device: VkDevice,
        renderPass: VkRenderPass,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetRenderAreaGranularity(
        device: VkDevice,
        renderPass: VkRenderPass,
        pGranularity: *mut VkExtent2D,
    );
}
extern "C" {
    pub fn vkCreateCommandPool(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAllocateCommandBuffers(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeCommandBuffers(
        device: VkDevice,
        commandPool: VkCommandPool,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    );
}
extern "C" {
    pub fn vkBeginCommandBuffer(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
}
extern "C" {
    pub fn vkResetCommandBuffer(
        commandBuffer: VkCommandBuffer,
        flags: VkCommandBufferResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBindPipeline(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
    );
}
extern "C" {
    pub fn vkCmdSetViewport(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewports: *const VkViewport,
    );
}
extern "C" {
    pub fn vkCmdSetScissor(
        commandBuffer: VkCommandBuffer,
        firstScissor: u32,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    );
}
extern "C" {
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer, lineWidth: f32);
}
extern "C" {
    pub fn vkCmdSetDepthBias(
        commandBuffer: VkCommandBuffer,
        depthBiasConstantFactor: f32,
        depthBiasClamp: f32,
        depthBiasSlopeFactor: f32,
    );
}
extern "C" {
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer, blendConstants: *const f32);
}
extern "C" {
    pub fn vkCmdSetDepthBounds(
        commandBuffer: VkCommandBuffer,
        minDepthBounds: f32,
        maxDepthBounds: f32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilCompareMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        compareMask: u32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilWriteMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        writeMask: u32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilReference(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        reference: u32,
    );
}
extern "C" {
    pub fn vkCmdBindDescriptorSets(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: u32,
        pDynamicOffsets: *const u32,
    );
}
extern "C" {
    pub fn vkCmdBindIndexBuffer(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        indexType: VkIndexType,
    );
}
extern "C" {
    pub fn vkCmdBindVertexBuffers(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdDraw(
        commandBuffer: VkCommandBuffer,
        vertexCount: u32,
        instanceCount: u32,
        firstVertex: u32,
        firstInstance: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexed(
        commandBuffer: VkCommandBuffer,
        indexCount: u32,
        instanceCount: u32,
        firstIndex: u32,
        vertexOffset: i32,
        firstInstance: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDispatch(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
extern "C" {
    pub fn vkCmdDispatchIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdCopyBuffer(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    );
}
extern "C" {
    pub fn vkCmdCopyImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageCopy,
    );
}
extern "C" {
    pub fn vkCmdBlitImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageBlit,
        filter: VkFilter,
    );
}
extern "C" {
    pub fn vkCmdCopyBufferToImage(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    );
}
extern "C" {
    pub fn vkCmdCopyImageToBuffer(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    );
}
extern "C" {
    pub fn vkCmdUpdateBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        dataSize: VkDeviceSize,
        pData: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkCmdFillBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        size: VkDeviceSize,
        data: u32,
    );
}
extern "C" {
    pub fn vkCmdClearColorImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pColor: *const VkClearColorValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    );
}
extern "C" {
    pub fn vkCmdClearDepthStencilImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    );
}
extern "C" {
    pub fn vkCmdClearAttachments(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pAttachments: *const VkClearAttachment,
        rectCount: u32,
        pRects: *const VkClearRect,
    );
}
extern "C" {
    pub fn vkCmdResolveImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageResolve,
    );
}
extern "C" {
    pub fn vkCmdSetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
}
extern "C" {
    pub fn vkCmdResetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
}
extern "C" {
    pub fn vkCmdWaitEvents(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
}
extern "C" {
    pub fn vkCmdPipelineBarrier(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
}
extern "C" {
    pub fn vkCmdBeginQuery(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
    );
}
extern "C" {
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32);
}
extern "C" {
    pub fn vkCmdResetQueryPool(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
extern "C" {
    pub fn vkCmdWriteTimestamp(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        queryPool: VkQueryPool,
        query: u32,
    );
}
extern "C" {
    pub fn vkCmdCopyQueryPoolResults(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    );
}
extern "C" {
    pub fn vkCmdPushConstants(
        commandBuffer: VkCommandBuffer,
        layout: VkPipelineLayout,
        stageFlags: VkShaderStageFlags,
        offset: u32,
        size: u32,
        pValues: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkCmdBeginRenderPass(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
}
extern "C" {
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdExecuteCommands(
        commandBuffer: VkCommandBuffer,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversion_T {
    _unused: [u8; 0],
}
pub type VkSamplerYcbcrConversion = *mut VkSamplerYcbcrConversion_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplate_T {
    _unused: [u8; 0],
}
pub type VkDescriptorUpdateTemplate = *mut VkDescriptorUpdateTemplate_T;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
    VkPointClippingBehavior = 0;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
    VkPointClippingBehavior = 1;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR:
    VkPointClippingBehavior = 0;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR:
    VkPointClippingBehavior = 1;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE: VkPointClippingBehavior =
    0;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_END_RANGE: VkPointClippingBehavior = 1;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE: VkPointClippingBehavior =
    2;
pub const VkPointClippingBehavior_VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM: VkPointClippingBehavior =
    2147483647;
pub type VkPointClippingBehavior = ::std::os::raw::c_uint;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT:
    VkTessellationDomainOrigin = 0;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT:
    VkTessellationDomainOrigin = 1;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR:
    VkTessellationDomainOrigin = 0;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR:
    VkTessellationDomainOrigin = 1;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE:
    VkTessellationDomainOrigin = 0;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE:
    VkTessellationDomainOrigin = 1;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE:
    VkTessellationDomainOrigin = 2;
pub const VkTessellationDomainOrigin_VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM:
    VkTessellationDomainOrigin = 2147483647;
pub type VkTessellationDomainOrigin = ::std::os::raw::c_uint;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY:
    VkSamplerYcbcrModelConversion = 0;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY:
    VkSamplerYcbcrModelConversion = 1;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709:
    VkSamplerYcbcrModelConversion = 2;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601:
    VkSamplerYcbcrModelConversion = 3;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020:
    VkSamplerYcbcrModelConversion = 4;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR:
    VkSamplerYcbcrModelConversion = 0;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR:
    VkSamplerYcbcrModelConversion = 1;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR:
    VkSamplerYcbcrModelConversion = 2;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR:
    VkSamplerYcbcrModelConversion = 3;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR:
    VkSamplerYcbcrModelConversion = 4;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE:
    VkSamplerYcbcrModelConversion = 0;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE:
    VkSamplerYcbcrModelConversion = 4;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE:
    VkSamplerYcbcrModelConversion = 5;
pub const VkSamplerYcbcrModelConversion_VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM:
    VkSamplerYcbcrModelConversion = 2147483647;
pub type VkSamplerYcbcrModelConversion = ::std::os::raw::c_uint;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_FULL: VkSamplerYcbcrRange = 0;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: VkSamplerYcbcrRange = 1;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange = 0;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange = 1;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE: VkSamplerYcbcrRange = 0;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_END_RANGE: VkSamplerYcbcrRange = 1;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE: VkSamplerYcbcrRange = 2;
pub const VkSamplerYcbcrRange_VK_SAMPLER_YCBCR_RANGE_MAX_ENUM: VkSamplerYcbcrRange = 2147483647;
pub type VkSamplerYcbcrRange = ::std::os::raw::c_uint;
pub const VkChromaLocation_VK_CHROMA_LOCATION_COSITED_EVEN: VkChromaLocation = 0;
pub const VkChromaLocation_VK_CHROMA_LOCATION_MIDPOINT: VkChromaLocation = 1;
pub const VkChromaLocation_VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation = 0;
pub const VkChromaLocation_VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation = 1;
pub const VkChromaLocation_VK_CHROMA_LOCATION_BEGIN_RANGE: VkChromaLocation = 0;
pub const VkChromaLocation_VK_CHROMA_LOCATION_END_RANGE: VkChromaLocation = 1;
pub const VkChromaLocation_VK_CHROMA_LOCATION_RANGE_SIZE: VkChromaLocation = 2;
pub const VkChromaLocation_VK_CHROMA_LOCATION_MAX_ENUM: VkChromaLocation = 2147483647;
pub type VkChromaLocation = ::std::os::raw::c_uint;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET:
    VkDescriptorUpdateTemplateType = 0;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR:
    VkDescriptorUpdateTemplateType = 1;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR:
    VkDescriptorUpdateTemplateType = 0;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE:
    VkDescriptorUpdateTemplateType = 0;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE:
    VkDescriptorUpdateTemplateType = 0;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE:
    VkDescriptorUpdateTemplateType = 1;
pub const VkDescriptorUpdateTemplateType_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM:
    VkDescriptorUpdateTemplateType = 2147483647;
pub type VkDescriptorUpdateTemplateType = ::std::os::raw::c_uint;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_BASIC_BIT: VkSubgroupFeatureFlagBits = 1;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_VOTE_BIT: VkSubgroupFeatureFlagBits = 2;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: VkSubgroupFeatureFlagBits =
    4;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_BALLOT_BIT: VkSubgroupFeatureFlagBits = 8;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_SHUFFLE_BIT: VkSubgroupFeatureFlagBits = 16;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT:
    VkSubgroupFeatureFlagBits = 32;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_CLUSTERED_BIT: VkSubgroupFeatureFlagBits =
    64;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_QUAD_BIT: VkSubgroupFeatureFlagBits = 128;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV:
    VkSubgroupFeatureFlagBits = 256;
pub const VkSubgroupFeatureFlagBits_VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM:
    VkSubgroupFeatureFlagBits = 2147483647;
pub type VkSubgroupFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkSubgroupFeatureFlags = VkFlags;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT:
    VkPeerMemoryFeatureFlagBits = 1;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_COPY_DST_BIT:
    VkPeerMemoryFeatureFlagBits = 2;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT:
    VkPeerMemoryFeatureFlagBits = 4;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT:
    VkPeerMemoryFeatureFlagBits = 8;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR:
    VkPeerMemoryFeatureFlagBits = 1;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR:
    VkPeerMemoryFeatureFlagBits = 2;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR:
    VkPeerMemoryFeatureFlagBits = 4;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR:
    VkPeerMemoryFeatureFlagBits = 8;
pub const VkPeerMemoryFeatureFlagBits_VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM:
    VkPeerMemoryFeatureFlagBits = 2147483647;
pub type VkPeerMemoryFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkPeerMemoryFeatureFlags = VkFlags;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagBits = 1;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: VkMemoryAllocateFlagBits =
    2;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT:
    VkMemoryAllocateFlagBits = 4;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR:
    VkMemoryAllocateFlagBits = 1;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR:
    VkMemoryAllocateFlagBits = 2;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR:
    VkMemoryAllocateFlagBits = 4;
pub const VkMemoryAllocateFlagBits_VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM: VkMemoryAllocateFlagBits =
    2147483647;
pub type VkMemoryAllocateFlagBits = ::std::os::raw::c_uint;
pub type VkMemoryAllocateFlags = VkFlags;
pub type VkCommandPoolTrimFlags = VkFlags;
pub type VkDescriptorUpdateTemplateCreateFlags = VkFlags;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
    VkExternalMemoryHandleTypeFlagBits = 1;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
    VkExternalMemoryHandleTypeFlagBits = 2;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
    VkExternalMemoryHandleTypeFlagBits = 4;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
    VkExternalMemoryHandleTypeFlagBits = 8;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT : VkExternalMemoryHandleTypeFlagBits = 16 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
    VkExternalMemoryHandleTypeFlagBits = 32;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
    VkExternalMemoryHandleTypeFlagBits = 64;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT:
    VkExternalMemoryHandleTypeFlagBits = 512;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID : VkExternalMemoryHandleTypeFlagBits = 1024 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT : VkExternalMemoryHandleTypeFlagBits = 128 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT : VkExternalMemoryHandleTypeFlagBits = 256 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 1;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 2;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR : VkExternalMemoryHandleTypeFlagBits = 4 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR : VkExternalMemoryHandleTypeFlagBits = 8 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR : VkExternalMemoryHandleTypeFlagBits = 16 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 32;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR : VkExternalMemoryHandleTypeFlagBits = 64 ;
pub const VkExternalMemoryHandleTypeFlagBits_VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM:
    VkExternalMemoryHandleTypeFlagBits = 2147483647;
pub type VkExternalMemoryHandleTypeFlagBits = ::std::os::raw::c_uint;
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT:
    VkExternalMemoryFeatureFlagBits = 1;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT:
    VkExternalMemoryFeatureFlagBits = 2;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT:
    VkExternalMemoryFeatureFlagBits = 4;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR:
    VkExternalMemoryFeatureFlagBits = 1;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR:
    VkExternalMemoryFeatureFlagBits = 2;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR:
    VkExternalMemoryFeatureFlagBits = 4;
pub const VkExternalMemoryFeatureFlagBits_VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM:
    VkExternalMemoryFeatureFlagBits = 2147483647;
pub type VkExternalMemoryFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkExternalMemoryFeatureFlags = VkFlags;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
    VkExternalFenceHandleTypeFlagBits = 1;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
    VkExternalFenceHandleTypeFlagBits = 2;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
    VkExternalFenceHandleTypeFlagBits = 4;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
    VkExternalFenceHandleTypeFlagBits = 8;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR:
    VkExternalFenceHandleTypeFlagBits = 1;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR:
    VkExternalFenceHandleTypeFlagBits = 2;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR : VkExternalFenceHandleTypeFlagBits = 4 ;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR:
    VkExternalFenceHandleTypeFlagBits = 8;
pub const VkExternalFenceHandleTypeFlagBits_VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM:
    VkExternalFenceHandleTypeFlagBits = 2147483647;
pub type VkExternalFenceHandleTypeFlagBits = ::std::os::raw::c_uint;
pub type VkExternalFenceHandleTypeFlags = VkFlags;
pub const VkExternalFenceFeatureFlagBits_VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT:
    VkExternalFenceFeatureFlagBits = 1;
pub const VkExternalFenceFeatureFlagBits_VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT:
    VkExternalFenceFeatureFlagBits = 2;
pub const VkExternalFenceFeatureFlagBits_VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR:
    VkExternalFenceFeatureFlagBits = 1;
pub const VkExternalFenceFeatureFlagBits_VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR:
    VkExternalFenceFeatureFlagBits = 2;
pub const VkExternalFenceFeatureFlagBits_VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM:
    VkExternalFenceFeatureFlagBits = 2147483647;
pub type VkExternalFenceFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkExternalFenceFeatureFlags = VkFlags;
pub const VkFenceImportFlagBits_VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagBits = 1;
pub const VkFenceImportFlagBits_VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits = 1;
pub const VkFenceImportFlagBits_VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM: VkFenceImportFlagBits =
    2147483647;
pub type VkFenceImportFlagBits = ::std::os::raw::c_uint;
pub type VkFenceImportFlags = VkFlags;
pub const VkSemaphoreImportFlagBits_VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagBits =
    1;
pub const VkSemaphoreImportFlagBits_VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR:
    VkSemaphoreImportFlagBits = 1;
pub const VkSemaphoreImportFlagBits_VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM:
    VkSemaphoreImportFlagBits = 2147483647;
pub type VkSemaphoreImportFlagBits = ::std::os::raw::c_uint;
pub type VkSemaphoreImportFlags = VkFlags;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
    VkExternalSemaphoreHandleTypeFlagBits = 1;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT : VkExternalSemaphoreHandleTypeFlagBits = 2 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT : VkExternalSemaphoreHandleTypeFlagBits = 4 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT : VkExternalSemaphoreHandleTypeFlagBits = 8 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:
    VkExternalSemaphoreHandleTypeFlagBits = 16;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR : VkExternalSemaphoreHandleTypeFlagBits = 1 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR : VkExternalSemaphoreHandleTypeFlagBits = 2 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR : VkExternalSemaphoreHandleTypeFlagBits = 4 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR : VkExternalSemaphoreHandleTypeFlagBits = 8 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR : VkExternalSemaphoreHandleTypeFlagBits = 16 ;
pub const VkExternalSemaphoreHandleTypeFlagBits_VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM : VkExternalSemaphoreHandleTypeFlagBits = 2147483647 ;
pub type VkExternalSemaphoreHandleTypeFlagBits = ::std::os::raw::c_uint;
pub type VkExternalSemaphoreHandleTypeFlags = VkFlags;
pub const VkExternalSemaphoreFeatureFlagBits_VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT:
    VkExternalSemaphoreFeatureFlagBits = 1;
pub const VkExternalSemaphoreFeatureFlagBits_VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT:
    VkExternalSemaphoreFeatureFlagBits = 2;
pub const VkExternalSemaphoreFeatureFlagBits_VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR:
    VkExternalSemaphoreFeatureFlagBits = 1;
pub const VkExternalSemaphoreFeatureFlagBits_VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR:
    VkExternalSemaphoreFeatureFlagBits = 2;
pub const VkExternalSemaphoreFeatureFlagBits_VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM:
    VkExternalSemaphoreFeatureFlagBits = 2147483647;
pub type VkExternalSemaphoreFeatureFlagBits = ::std::os::raw::c_uint;
pub type VkExternalSemaphoreFeatureFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subgroupSize: u32,
    pub supportedStages: VkShaderStageFlags,
    pub supportedOperations: VkSubgroupFeatureFlags,
    pub quadOperationsInAllStages: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSubgroupProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).subgroupSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(subgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).supportedStages
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(supportedStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).supportedOperations
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(supportedOperations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupProperties>())).quadOperationsInAllStages
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupProperties),
            "::",
            stringify!(quadOperationsInAllStages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindBufferMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindBufferMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindBufferMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindBufferMemoryInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindBufferMemoryInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindBufferMemoryInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindBufferMemoryInfo>())).buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindBufferMemoryInfo>())).memory as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindBufferMemoryInfo>())).memoryOffset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryInfo),
            "::",
            stringify!(memoryOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindImageMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindImageMemoryInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindImageMemoryInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindImageMemoryInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindImageMemoryInfo>())).image as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBindImageMemoryInfo>())).memory as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryInfo>())).memoryOffset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryInfo),
            "::",
            stringify!(memoryOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice16BitStorageFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice16BitStorageFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevice16BitStorageFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevice16BitStorageFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevice16BitStorageFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>()))
                .storageBuffer16BitAccess as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(storageBuffer16BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>()))
                .uniformAndStorageBuffer16BitAccess as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(uniformAndStorageBuffer16BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>())).storagePushConstant16
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(storagePushConstant16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice16BitStorageFeatures>())).storageInputOutput16
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures),
            "::",
            stringify!(storageInputOutput16)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryDedicatedRequirements {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub prefersDedicatedAllocation: VkBool32,
    pub requiresDedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryDedicatedRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryDedicatedRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryDedicatedRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryDedicatedRequirements))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedRequirements>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedRequirements),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedRequirements>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedRequirements),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedRequirements>())).prefersDedicatedAllocation
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedRequirements),
            "::",
            stringify!(prefersDedicatedAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedRequirements>())).requiresDedicatedAllocation
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedRequirements),
            "::",
            stringify!(requiresDedicatedAllocation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryDedicatedAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryDedicatedAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryDedicatedAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryDedicatedAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryDedicatedAllocateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedAllocateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedAllocateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedAllocateInfo>())).image as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedAllocateInfo),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryDedicatedAllocateInfo>())).buffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryDedicatedAllocateInfo),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateFlagsInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkMemoryAllocateFlags,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateFlagsInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryAllocateFlagsInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryAllocateFlagsInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryAllocateFlagsInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryAllocateFlagsInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryAllocateFlagsInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateFlagsInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryAllocateFlagsInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateFlagsInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryAllocateFlagsInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateFlagsInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryAllocateFlagsInfo>())).deviceMask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryAllocateFlagsInfo),
            "::",
            stringify!(deviceMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
    pub deviceRenderAreaCount: u32,
    pub pDeviceRenderAreas: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupRenderPassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupRenderPassBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceGroupRenderPassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupRenderPassBeginInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupRenderPassBeginInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupRenderPassBeginInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupRenderPassBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupRenderPassBeginInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupRenderPassBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupRenderPassBeginInfo>())).deviceMask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupRenderPassBeginInfo),
            "::",
            stringify!(deviceMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupRenderPassBeginInfo>())).deviceRenderAreaCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupRenderPassBeginInfo),
            "::",
            stringify!(deviceRenderAreaCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupRenderPassBeginInfo>())).pDeviceRenderAreas
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupRenderPassBeginInfo),
            "::",
            stringify!(pDeviceRenderAreas)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupCommandBufferBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupCommandBufferBeginInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupCommandBufferBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupCommandBufferBeginInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupCommandBufferBeginInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupCommandBufferBeginInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupCommandBufferBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupCommandBufferBeginInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupCommandBufferBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupCommandBufferBeginInfo>())).deviceMask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupCommandBufferBeginInfo),
            "::",
            stringify!(deviceMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphoreDeviceIndices: *const u32,
    pub commandBufferCount: u32,
    pub pCommandBufferDeviceMasks: *const u32,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphoreDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupSubmitInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkDeviceGroupSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupSubmitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).waitSemaphoreCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(waitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).pWaitSemaphoreDeviceIndices
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(pWaitSemaphoreDeviceIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).commandBufferCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(commandBufferCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).pCommandBufferDeviceMasks
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(pCommandBufferDeviceMasks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).signalSemaphoreCount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(signalSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSubmitInfo>())).pSignalSemaphoreDeviceIndices
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSubmitInfo),
            "::",
            stringify!(pSignalSemaphoreDeviceIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub resourceDeviceIndex: u32,
    pub memoryDeviceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupBindSparseInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupBindSparseInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupBindSparseInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupBindSparseInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupBindSparseInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupBindSparseInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupBindSparseInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupBindSparseInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupBindSparseInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupBindSparseInfo>())).resourceDeviceIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupBindSparseInfo),
            "::",
            stringify!(resourceDeviceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupBindSparseInfo>())).memoryDeviceIndex as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupBindSparseInfo),
            "::",
            stringify!(memoryDeviceIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryDeviceGroupInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryDeviceGroupInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindBufferMemoryDeviceGroupInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkBindBufferMemoryDeviceGroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindBufferMemoryDeviceGroupInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindBufferMemoryDeviceGroupInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindBufferMemoryDeviceGroupInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindBufferMemoryDeviceGroupInfo>())).deviceIndexCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo),
            "::",
            stringify!(deviceIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindBufferMemoryDeviceGroupInfo>())).pDeviceIndices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo),
            "::",
            stringify!(pDeviceIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryDeviceGroupInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
    pub splitInstanceBindRegionCount: u32,
    pub pSplitInstanceBindRegions: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryDeviceGroupInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemoryDeviceGroupInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkBindImageMemoryDeviceGroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemoryDeviceGroupInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindImageMemoryDeviceGroupInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>())).deviceIndexCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(deviceIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>())).pDeviceIndices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(pDeviceIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>()))
                .splitInstanceBindRegionCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(splitInstanceBindRegionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemoryDeviceGroupInfo>())).pSplitInstanceBindRegions
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemoryDeviceGroupInfo),
            "::",
            stringify!(pSplitInstanceBindRegions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceGroupProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub physicalDevices: [VkPhysicalDevice; 32usize],
    pub subsetAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGroupProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceGroupProperties>(),
        288usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceGroupProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceGroupProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceGroupProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceGroupProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceGroupProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceGroupProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceGroupProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceGroupProperties>())).physicalDeviceCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceGroupProperties),
            "::",
            stringify!(physicalDeviceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceGroupProperties>())).physicalDevices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceGroupProperties),
            "::",
            stringify!(physicalDevices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceGroupProperties>())).subsetAllocation as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceGroupProperties),
            "::",
            stringify!(subsetAllocation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub pPhysicalDevices: *const VkPhysicalDevice,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupDeviceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupDeviceCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceGroupDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupDeviceCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupDeviceCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupDeviceCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupDeviceCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupDeviceCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupDeviceCreateInfo>())).physicalDeviceCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupDeviceCreateInfo),
            "::",
            stringify!(physicalDeviceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupDeviceCreateInfo>())).pPhysicalDevices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupDeviceCreateInfo),
            "::",
            stringify!(pPhysicalDevices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryRequirementsInfo2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryRequirementsInfo2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferMemoryRequirementsInfo2>())).buffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferMemoryRequirementsInfo2),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryRequirementsInfo2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryRequirementsInfo2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageMemoryRequirementsInfo2>())).image as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageMemoryRequirementsInfo2),
            "::",
            stringify!(image)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSparseMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageSparseMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSparseMemoryRequirementsInfo2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkImageSparseMemoryRequirementsInfo2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSparseMemoryRequirementsInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageSparseMemoryRequirementsInfo2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSparseMemoryRequirementsInfo2>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSparseMemoryRequirementsInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSparseMemoryRequirementsInfo2>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSparseMemoryRequirementsInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSparseMemoryRequirementsInfo2>())).image as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSparseMemoryRequirementsInfo2),
            "::",
            stringify!(image)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements2() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements2>(),
        40usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryRequirements2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryRequirements2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryRequirements2>())).memoryRequirements as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryRequirements2),
            "::",
            stringify!(memoryRequirements)
        )
    );
}
pub type VkMemoryRequirements2KHR = VkMemoryRequirements2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkSparseImageMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements2() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryRequirements2>(),
        64usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryRequirements2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryRequirements2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSparseImageMemoryRequirements2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageMemoryRequirements2>())).memoryRequirements
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageMemoryRequirements2),
            "::",
            stringify!(memoryRequirements)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub features: VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFeatures2>(),
        240usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFeatures2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPhysicalDeviceFeatures2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPhysicalDeviceFeatures2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFeatures2>())).features as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFeatures2),
            "::",
            stringify!(features)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkPhysicalDeviceProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProperties2>(),
        840usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceProperties2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProperties2>())).properties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProperties2),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub formatProperties: VkFormatProperties,
}
#[test]
fn bindgen_test_layout_VkFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkFormatProperties2>(),
        32usize,
        concat!("Size of: ", stringify!(VkFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFormatProperties2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFormatProperties2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFormatProperties2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFormatProperties2>())).formatProperties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFormatProperties2),
            "::",
            stringify!(formatProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageFormatProperties: VkImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatProperties2>(),
        48usize,
        concat!("Size of: ", stringify!(VkImageFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatProperties2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageFormatProperties2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageFormatProperties2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatProperties2>())).imageFormatProperties as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatProperties2),
            "::",
            stringify!(imageFormatProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageFormatInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub flags: VkImageCreateFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageFormatInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageFormatInfo2>(),
        40usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceImageFormatInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageFormatInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageFormatInfo2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).format as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).type_ as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).tiling as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(tiling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).usage as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageFormatInfo2>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageFormatInfo2),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub queueFamilyProperties: VkQueueFamilyProperties,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyProperties2>(),
        40usize,
        concat!("Size of: ", stringify!(VkQueueFamilyProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkQueueFamilyProperties2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueueFamilyProperties2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkQueueFamilyProperties2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyProperties2>())).queueFamilyProperties as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyProperties2),
            "::",
            stringify!(queueFamilyProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties2>(),
        536usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryProperties2>())).memoryProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryProperties2),
            "::",
            stringify!(memoryProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkSparseImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageFormatProperties2>(),
        40usize,
        concat!("Size of: ", stringify!(VkSparseImageFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageFormatProperties2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties2>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties2>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSparseImageFormatProperties2>())).properties as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSparseImageFormatProperties2),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub samples: VkSampleCountFlagBits,
    pub usage: VkImageUsageFlags,
    pub tiling: VkImageTiling,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseImageFormatInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSparseImageFormatInfo2>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSparseImageFormatInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).format as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).type_ as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).samples as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).usage as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSparseImageFormatInfo2>())).tiling as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
            "::",
            stringify!(tiling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePointClippingProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pointClippingBehavior: VkPointClippingBehavior,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePointClippingProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePointClippingProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePointClippingProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePointClippingProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePointClippingProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePointClippingProperties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePointClippingProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePointClippingProperties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePointClippingProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePointClippingProperties>()))
                .pointClippingBehavior as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePointClippingProperties),
            "::",
            stringify!(pointClippingBehavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInputAttachmentAspectReference {
    pub subpass: u32,
    pub inputAttachmentIndex: u32,
    pub aspectMask: VkImageAspectFlags,
}
#[test]
fn bindgen_test_layout_VkInputAttachmentAspectReference() {
    assert_eq!(
        ::std::mem::size_of::<VkInputAttachmentAspectReference>(),
        12usize,
        concat!("Size of: ", stringify!(VkInputAttachmentAspectReference))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInputAttachmentAspectReference>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkInputAttachmentAspectReference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInputAttachmentAspectReference>())).subpass as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInputAttachmentAspectReference),
            "::",
            stringify!(subpass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInputAttachmentAspectReference>())).inputAttachmentIndex
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInputAttachmentAspectReference),
            "::",
            stringify!(inputAttachmentIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInputAttachmentAspectReference>())).aspectMask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInputAttachmentAspectReference),
            "::",
            stringify!(aspectMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub aspectReferenceCount: u32,
    pub pAspectReferences: *const VkInputAttachmentAspectReference,
}
#[test]
fn bindgen_test_layout_VkRenderPassInputAttachmentAspectCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassInputAttachmentAspectCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassInputAttachmentAspectCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassInputAttachmentAspectCreateInfo>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassInputAttachmentAspectCreateInfo>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassInputAttachmentAspectCreateInfo>()))
                .aspectReferenceCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
            "::",
            stringify!(aspectReferenceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassInputAttachmentAspectCreateInfo>()))
                .pAspectReferences as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
            "::",
            stringify!(pAspectReferences)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewUsageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub usage: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkImageViewUsageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewUsageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageViewUsageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewUsageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewUsageCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewUsageCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewUsageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewUsageCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewUsageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewUsageCreateInfo>())).usage as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewUsageCreateInfo),
            "::",
            stringify!(usage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub domainOrigin: VkTessellationDomainOrigin,
}
#[test]
fn bindgen_test_layout_VkPipelineTessellationDomainOriginStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineTessellationDomainOriginStateCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineTessellationDomainOriginStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationDomainOriginStateCreateInfo>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationDomainOriginStateCreateInfo>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineTessellationDomainOriginStateCreateInfo>()))
                .domainOrigin as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
            "::",
            stringify!(domainOrigin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassMultiviewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub subpassCount: u32,
    pub pViewMasks: *const u32,
    pub dependencyCount: u32,
    pub pViewOffsets: *const i32,
    pub correlationMaskCount: u32,
    pub pCorrelationMasks: *const u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassMultiviewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassMultiviewCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassMultiviewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassMultiviewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassMultiviewCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).subpassCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(subpassCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).pViewMasks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(pViewMasks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).dependencyCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(dependencyCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).pViewOffsets as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(pViewOffsets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).correlationMaskCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(correlationMaskCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassMultiviewCreateInfo>())).pCorrelationMasks
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassMultiviewCreateInfo),
            "::",
            stringify!(pCorrelationMasks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewFeatures>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMultiviewFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewFeatures>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewFeatures>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewFeatures>())).multiview as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewFeatures),
            "::",
            stringify!(multiview)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewFeatures>())).multiviewGeometryShader
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewFeatures),
            "::",
            stringify!(multiviewGeometryShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewFeatures>()))
                .multiviewTessellationShader as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewFeatures),
            "::",
            stringify!(multiviewTessellationShader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewProperties>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMultiviewProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewProperties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewProperties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewProperties>())).maxMultiviewViewCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewProperties),
            "::",
            stringify!(maxMultiviewViewCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewProperties>()))
                .maxMultiviewInstanceIndex as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewProperties),
            "::",
            stringify!(maxMultiviewInstanceIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointersFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVariablePointersFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVariablePointersFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVariablePointersFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVariablePointersFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVariablePointersFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVariablePointersFeatures>()))
                .variablePointersStorageBuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures),
            "::",
            stringify!(variablePointersStorageBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVariablePointersFeatures>())).variablePointers
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures),
            "::",
            stringify!(variablePointers)
        )
    );
}
pub type VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub protectedMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProtectedMemoryFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProtectedMemoryFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProtectedMemoryFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryFeatures>())).protectedMemory
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
            "::",
            stringify!(protectedMemory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub protectedNoFault: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProtectedMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProtectedMemoryProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProtectedMemoryProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryProperties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryProperties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceProtectedMemoryProperties>())).protectedNoFault
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties),
            "::",
            stringify!(protectedNoFault)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: u32,
    pub queueIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueInfo2>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceQueueInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceQueueInfo2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueInfo2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueInfo2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueInfo2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueInfo2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueInfo2>())).queueFamilyIndex as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueInfo2),
            "::",
            stringify!(queueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceQueueInfo2>())).queueIndex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueInfo2),
            "::",
            stringify!(queueIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkProtectedSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub protectedSubmit: VkBool32,
}
#[test]
fn bindgen_test_layout_VkProtectedSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkProtectedSubmitInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkProtectedSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkProtectedSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkProtectedSubmitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkProtectedSubmitInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkProtectedSubmitInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkProtectedSubmitInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkProtectedSubmitInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkProtectedSubmitInfo>())).protectedSubmit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkProtectedSubmitInfo),
            "::",
            stringify!(protectedSubmit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub ycbcrModel: VkSamplerYcbcrModelConversion,
    pub ycbcrRange: VkSamplerYcbcrRange,
    pub components: VkComponentMapping,
    pub xChromaOffset: VkChromaLocation,
    pub yChromaOffset: VkChromaLocation,
    pub chromaFilter: VkFilter,
    pub forceExplicitReconstruction: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkSamplerYcbcrConversionCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerYcbcrConversionCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).format as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).ycbcrModel as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(ycbcrModel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).ycbcrRange as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(ycbcrRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).components as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).xChromaOffset as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(xChromaOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).yChromaOffset as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(yChromaOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>())).chromaFilter as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(chromaFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionCreateInfo>()))
                .forceExplicitReconstruction as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionCreateInfo),
            "::",
            stringify!(forceExplicitReconstruction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub conversion: VkSamplerYcbcrConversion,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSamplerYcbcrConversionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSamplerYcbcrConversionInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionInfo>())).conversion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionInfo),
            "::",
            stringify!(conversion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImagePlaneMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkBindImagePlaneMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImagePlaneMemoryInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkBindImagePlaneMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImagePlaneMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindImagePlaneMemoryInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImagePlaneMemoryInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImagePlaneMemoryInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImagePlaneMemoryInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImagePlaneMemoryInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImagePlaneMemoryInfo>())).planeAspect as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImagePlaneMemoryInfo),
            "::",
            stringify!(planeAspect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImagePlaneMemoryRequirementsInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkImagePlaneMemoryRequirementsInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImagePlaneMemoryRequirementsInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImagePlaneMemoryRequirementsInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImagePlaneMemoryRequirementsInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImagePlaneMemoryRequirementsInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImagePlaneMemoryRequirementsInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImagePlaneMemoryRequirementsInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImagePlaneMemoryRequirementsInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImagePlaneMemoryRequirementsInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImagePlaneMemoryRequirementsInfo>())).planeAspect as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImagePlaneMemoryRequirementsInfo),
            "::",
            stringify!(planeAspect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub samplerYcbcrConversion: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSamplerYcbcrConversionFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>()))
                .samplerYcbcrConversion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
            "::",
            stringify!(samplerYcbcrConversion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionImageFormatProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub combinedImageSamplerDescriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionImageFormatProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionImageFormatProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionImageFormatProperties>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionImageFormatProperties>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerYcbcrConversionImageFormatProperties>()))
                .combinedImageSamplerDescriptorCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties),
            "::",
            stringify!(combinedImageSamplerDescriptorCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplateEntry {
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub offset: size_t,
    pub stride: size_t,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateEntry() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorUpdateTemplateEntry>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorUpdateTemplateEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorUpdateTemplateEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorUpdateTemplateEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).dstBinding as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(dstBinding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).dstArrayElement as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(dstArrayElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).descriptorCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(descriptorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).descriptorType as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(descriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateEntry>())).stride as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateEntry),
            "::",
            stringify!(stride)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorUpdateTemplateCreateFlags,
    pub descriptorUpdateEntryCount: u32,
    pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntry,
    pub templateType: VkDescriptorUpdateTemplateType,
    pub descriptorSetLayout: VkDescriptorSetLayout,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipelineLayout: VkPipelineLayout,
    pub set: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorUpdateTemplateCreateInfo>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorUpdateTemplateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>()))
                .descriptorUpdateEntryCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(descriptorUpdateEntryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>()))
                .pDescriptorUpdateEntries as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(pDescriptorUpdateEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).templateType
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(templateType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).descriptorSetLayout
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(descriptorSetLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).pipelineBindPoint
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(pipelineBindPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).pipelineLayout
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(pipelineLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorUpdateTemplateCreateInfo>())).set as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo),
            "::",
            stringify!(set)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryProperties {
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlags,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryProperties>(),
        12usize,
        concat!("Size of: ", stringify!(VkExternalMemoryProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExternalMemoryProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryProperties>())).externalMemoryFeatures
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryProperties),
            "::",
            stringify!(externalMemoryFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryProperties>())).exportFromImportedHandleTypes
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryProperties),
            "::",
            stringify!(exportFromImportedHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryProperties>())).compatibleHandleTypes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryProperties),
            "::",
            stringify!(compatibleHandleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalImageFormatInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalImageFormatInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalImageFormatInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalImageFormatInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalImageFormatInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalImageFormatInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalImageFormatInfo>())).handleType
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo),
            "::",
            stringify!(handleType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalImageFormatProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalImageFormatProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalImageFormatProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalImageFormatProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatProperties>())).externalMemoryProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatProperties),
            "::",
            stringify!(externalMemoryProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalBufferInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub usage: VkBufferUsageFlags,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalBufferInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceExternalBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalBufferInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalBufferInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalBufferInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalBufferInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalBufferInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalBufferInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalBufferInfo>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalBufferInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalBufferInfo>())).usage as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalBufferInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalBufferInfo>())).handleType as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalBufferInfo),
            "::",
            stringify!(handleType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalBufferProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkExternalBufferProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalBufferProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalBufferProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalBufferProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalBufferProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalBufferProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalBufferProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalBufferProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalBufferProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalBufferProperties>())).externalMemoryProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalBufferProperties),
            "::",
            stringify!(externalMemoryProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceIDProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceUUID: [u8; 16usize],
    pub driverUUID: [u8; 16usize],
    pub deviceLUID: [u8; 8usize],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceIDProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceIDProperties>(),
        64usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceIDProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceIDProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceIDProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).deviceUUID as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(deviceUUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).driverUUID as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(driverUUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).deviceLUID as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(deviceLUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).deviceNodeMask as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(deviceNodeMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIDProperties>())).deviceLUIDValid as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIDProperties),
            "::",
            stringify!(deviceLUIDValid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryImageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryImageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryImageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalMemoryImageCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfo>())).handleTypes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfo),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryBufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryBufferCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryBufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryBufferCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalMemoryBufferCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryBufferCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryBufferCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryBufferCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryBufferCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryBufferCreateInfo>())).handleTypes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryBufferCreateInfo),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportMemoryAllocateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportMemoryAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportMemoryAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportMemoryAllocateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfo>())).handleTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfo),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalFenceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalFenceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalFenceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceExternalFenceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalFenceInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalFenceInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalFenceInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalFenceInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalFenceInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalFenceInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalFenceInfo>())).handleType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalFenceInfo),
            "::",
            stringify!(handleType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalFenceProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
    pub externalFenceFeatures: VkExternalFenceFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkExternalFenceProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalFenceProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalFenceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalFenceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalFenceProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExternalFenceProperties>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalFenceProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExternalFenceProperties>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalFenceProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalFenceProperties>())).exportFromImportedHandleTypes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalFenceProperties),
            "::",
            stringify!(exportFromImportedHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalFenceProperties>())).compatibleHandleTypes as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalFenceProperties),
            "::",
            stringify!(compatibleHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalFenceProperties>())).externalFenceFeatures as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalFenceProperties),
            "::",
            stringify!(externalFenceFeatures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalFenceHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportFenceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportFenceCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportFenceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportFenceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportFenceCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExportFenceCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportFenceCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkExportFenceCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportFenceCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportFenceCreateInfo>())).handleTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportFenceCreateInfo),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalSemaphoreHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportSemaphoreCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportSemaphoreCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportSemaphoreCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportSemaphoreCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportSemaphoreCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportSemaphoreCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportSemaphoreCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportSemaphoreCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportSemaphoreCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportSemaphoreCreateInfo>())).handleTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportSemaphoreCreateInfo),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalSemaphoreInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalSemaphoreInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalSemaphoreInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalSemaphoreInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalSemaphoreInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalSemaphoreInfo>())).handleType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
            "::",
            stringify!(handleType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalSemaphoreProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkExternalSemaphoreProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalSemaphoreProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalSemaphoreProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalSemaphoreProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalSemaphoreProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalSemaphoreProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalSemaphoreProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalSemaphoreProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalSemaphoreProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalSemaphoreProperties>())).exportFromImportedHandleTypes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalSemaphoreProperties),
            "::",
            stringify!(exportFromImportedHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalSemaphoreProperties>())).compatibleHandleTypes
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalSemaphoreProperties),
            "::",
            stringify!(compatibleHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalSemaphoreProperties>())).externalSemaphoreFeatures
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalSemaphoreProperties),
            "::",
            stringify!(externalSemaphoreFeatures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance3Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMaintenance3Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMaintenance3Properties>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMaintenance3Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMaintenance3Properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMaintenance3Properties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMaintenance3Properties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMaintenance3Properties>())).maxPerSetDescriptors
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties),
            "::",
            stringify!(maxPerSetDescriptors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMaintenance3Properties>()))
                .maxMemoryAllocationSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties),
            "::",
            stringify!(maxMemoryAllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutSupport {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supported: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutSupport() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutSupport>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutSupport))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutSupport>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutSupport))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutSupport>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutSupport),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutSupport>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutSupport),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutSupport>())).supported as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutSupport),
            "::",
            stringify!(supported)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderDrawParameters: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderDrawParametersFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderDrawParametersFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderDrawParametersFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDrawParametersFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDrawParametersFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDrawParametersFeatures>()))
                .shaderDrawParameters as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
            "::",
            stringify!(shaderDrawParameters)
        )
    );
}
pub type VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
pub type PFN_vkEnumerateInstanceVersion =
    ::std::option::Option<unsafe extern "C" fn(pApiVersion: *mut u32) -> VkResult>;
pub type PFN_vkBindBufferMemory2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupPeerMemoryFeatures = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    ),
>;
pub type PFN_vkCmdSetDeviceMask =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, deviceMask: u32)>;
pub type PFN_vkCmdDispatchBase = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
pub type PFN_vkEnumeratePhysicalDeviceGroups = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetImageMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFeatures2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    ),
>;
pub type PFN_vkTrimCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    ),
>;
pub type PFN_vkGetDeviceQueue2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pQueueInfo: *const VkDeviceQueueInfo2,
        pQueue: *mut VkQueue,
    ),
>;
pub type PFN_vkCreateSamplerYcbcrConversion = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult,
>;
pub type PFN_vkDestroySamplerYcbcrConversion = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorUpdateTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorUpdateTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkUpdateDescriptorSetWithTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalBufferProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalFenceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    ),
>;
pub type PFN_vkGetDescriptorSetLayoutSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    ),
>;
extern "C" {
    pub fn vkEnumerateInstanceVersion(pApiVersion: *mut u32) -> VkResult;
}
extern "C" {
    pub fn vkBindBufferMemory2(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory2(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupPeerMemoryFeatures(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    );
}
extern "C" {
    pub fn vkCmdSetDeviceMask(commandBuffer: VkCommandBuffer, deviceMask: u32);
}
extern "C" {
    pub fn vkCmdDispatchBase(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
extern "C" {
    pub fn vkEnumeratePhysicalDeviceGroups(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetImageMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures2(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties2(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties2(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties2(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    );
}
extern "C" {
    pub fn vkTrimCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    );
}
extern "C" {
    pub fn vkGetDeviceQueue2(
        device: VkDevice,
        pQueueInfo: *const VkDeviceQueueInfo2,
        pQueue: *mut VkQueue,
    );
}
extern "C" {
    pub fn vkCreateSamplerYcbcrConversion(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySamplerYcbcrConversion(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorUpdateTemplate(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorUpdateTemplate(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkUpdateDescriptorSetWithTemplate(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalBufferProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalFenceProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalSemaphoreProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    );
}
extern "C" {
    pub fn vkGetDescriptorSetLayoutSupport(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    );
}
pub type VkDeviceAddress = u64;
pub const VkDriverId_VK_DRIVER_ID_AMD_PROPRIETARY: VkDriverId = 1;
pub const VkDriverId_VK_DRIVER_ID_AMD_OPEN_SOURCE: VkDriverId = 2;
pub const VkDriverId_VK_DRIVER_ID_MESA_RADV: VkDriverId = 3;
pub const VkDriverId_VK_DRIVER_ID_NVIDIA_PROPRIETARY: VkDriverId = 4;
pub const VkDriverId_VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: VkDriverId = 5;
pub const VkDriverId_VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA: VkDriverId = 6;
pub const VkDriverId_VK_DRIVER_ID_IMAGINATION_PROPRIETARY: VkDriverId = 7;
pub const VkDriverId_VK_DRIVER_ID_QUALCOMM_PROPRIETARY: VkDriverId = 8;
pub const VkDriverId_VK_DRIVER_ID_ARM_PROPRIETARY: VkDriverId = 9;
pub const VkDriverId_VK_DRIVER_ID_GOOGLE_SWIFTSHADER: VkDriverId = 10;
pub const VkDriverId_VK_DRIVER_ID_GGP_PROPRIETARY: VkDriverId = 11;
pub const VkDriverId_VK_DRIVER_ID_BROADCOM_PROPRIETARY: VkDriverId = 12;
pub const VkDriverId_VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverId = 1;
pub const VkDriverId_VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverId = 2;
pub const VkDriverId_VK_DRIVER_ID_MESA_RADV_KHR: VkDriverId = 3;
pub const VkDriverId_VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverId = 4;
pub const VkDriverId_VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverId = 5;
pub const VkDriverId_VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverId = 6;
pub const VkDriverId_VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverId = 7;
pub const VkDriverId_VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverId = 8;
pub const VkDriverId_VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverId = 9;
pub const VkDriverId_VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverId = 10;
pub const VkDriverId_VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverId = 11;
pub const VkDriverId_VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverId = 12;
pub const VkDriverId_VK_DRIVER_ID_BEGIN_RANGE: VkDriverId = 1;
pub const VkDriverId_VK_DRIVER_ID_END_RANGE: VkDriverId = 12;
pub const VkDriverId_VK_DRIVER_ID_RANGE_SIZE: VkDriverId = 12;
pub const VkDriverId_VK_DRIVER_ID_MAX_ENUM: VkDriverId = 2147483647;
pub type VkDriverId = ::std::os::raw::c_uint;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY:
    VkShaderFloatControlsIndependence = 0;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL:
    VkShaderFloatControlsIndependence = 1;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE:
    VkShaderFloatControlsIndependence = 2;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR : VkShaderFloatControlsIndependence = 0 ;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR:
    VkShaderFloatControlsIndependence = 1;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR:
    VkShaderFloatControlsIndependence = 2;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE:
    VkShaderFloatControlsIndependence = 0;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE:
    VkShaderFloatControlsIndependence = 2;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE:
    VkShaderFloatControlsIndependence = 3;
pub const VkShaderFloatControlsIndependence_VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM:
    VkShaderFloatControlsIndependence = 2147483647;
pub type VkShaderFloatControlsIndependence = ::std::os::raw::c_uint;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE:
    VkSamplerReductionMode = 0;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_MIN: VkSamplerReductionMode = 1;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_MAX: VkSamplerReductionMode = 2;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT:
    VkSamplerReductionMode = 0;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionMode = 1;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionMode = 2;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE: VkSamplerReductionMode = 0;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_END_RANGE: VkSamplerReductionMode = 2;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE: VkSamplerReductionMode = 3;
pub const VkSamplerReductionMode_VK_SAMPLER_REDUCTION_MODE_MAX_ENUM: VkSamplerReductionMode =
    2147483647;
pub type VkSamplerReductionMode = ::std::os::raw::c_uint;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_BINARY: VkSemaphoreType = 0;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_TIMELINE: VkSemaphoreType = 1;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreType = 0;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreType = 1;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_BEGIN_RANGE: VkSemaphoreType = 0;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_END_RANGE: VkSemaphoreType = 1;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_RANGE_SIZE: VkSemaphoreType = 2;
pub const VkSemaphoreType_VK_SEMAPHORE_TYPE_MAX_ENUM: VkSemaphoreType = 2147483647;
pub type VkSemaphoreType = ::std::os::raw::c_uint;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_NONE: VkResolveModeFlagBits = 0;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: VkResolveModeFlagBits = 1;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_AVERAGE_BIT: VkResolveModeFlagBits = 2;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_MIN_BIT: VkResolveModeFlagBits = 4;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_MAX_BIT: VkResolveModeFlagBits = 8;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBits = 0;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBits = 1;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBits = 2;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBits = 4;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBits = 8;
pub const VkResolveModeFlagBits_VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM: VkResolveModeFlagBits =
    2147483647;
pub type VkResolveModeFlagBits = ::std::os::raw::c_uint;
pub type VkResolveModeFlags = VkFlags;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT:
    VkDescriptorBindingFlagBits = 1;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT:
    VkDescriptorBindingFlagBits = 2;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT:
    VkDescriptorBindingFlagBits = 4;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT:
    VkDescriptorBindingFlagBits = 8;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT:
    VkDescriptorBindingFlagBits = 1;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT:
    VkDescriptorBindingFlagBits = 2;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT:
    VkDescriptorBindingFlagBits = 4;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT:
    VkDescriptorBindingFlagBits = 8;
pub const VkDescriptorBindingFlagBits_VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM:
    VkDescriptorBindingFlagBits = 2147483647;
pub type VkDescriptorBindingFlagBits = ::std::os::raw::c_uint;
pub type VkDescriptorBindingFlags = VkFlags;
pub const VkSemaphoreWaitFlagBits_VK_SEMAPHORE_WAIT_ANY_BIT: VkSemaphoreWaitFlagBits = 1;
pub const VkSemaphoreWaitFlagBits_VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBits = 1;
pub const VkSemaphoreWaitFlagBits_VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM: VkSemaphoreWaitFlagBits =
    2147483647;
pub type VkSemaphoreWaitFlagBits = ::std::os::raw::c_uint;
pub type VkSemaphoreWaitFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
    pub protectedMemory: VkBool32,
    pub samplerYcbcrConversion: VkBool32,
    pub shaderDrawParameters: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan11Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan11Features>(),
        64usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan11Features))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan11Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan11Features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).storageBuffer16BitAccess
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(storageBuffer16BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>()))
                .uniformAndStorageBuffer16BitAccess as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(uniformAndStorageBuffer16BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).storagePushConstant16
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(storagePushConstant16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).storageInputOutput16
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(storageInputOutput16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).multiview as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(multiview)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).multiviewGeometryShader
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(multiviewGeometryShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).multiviewTessellationShader
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(multiviewTessellationShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>()))
                .variablePointersStorageBuffer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(variablePointersStorageBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).variablePointers
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(variablePointers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).protectedMemory as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(protectedMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).samplerYcbcrConversion
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(samplerYcbcrConversion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Features>())).shaderDrawParameters
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Features),
            "::",
            stringify!(shaderDrawParameters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceUUID: [u8; 16usize],
    pub driverUUID: [u8; 16usize],
    pub deviceLUID: [u8; 8usize],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
    pub subgroupSize: u32,
    pub subgroupSupportedStages: VkShaderStageFlags,
    pub subgroupSupportedOperations: VkSubgroupFeatureFlags,
    pub subgroupQuadOperationsInAllStages: VkBool32,
    pub pointClippingBehavior: VkPointClippingBehavior,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
    pub protectedNoFault: VkBool32,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan11Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan11Properties>(),
        112usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan11Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan11Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan11Properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).deviceUUID as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(deviceUUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).driverUUID as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(driverUUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).deviceLUID as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(deviceLUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).deviceNodeMask
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(deviceNodeMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).deviceLUIDValid
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(deviceLUIDValid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).subgroupSize as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(subgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).subgroupSupportedStages
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(subgroupSupportedStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>()))
                .subgroupSupportedOperations as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(subgroupSupportedOperations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>()))
                .subgroupQuadOperationsInAllStages as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(subgroupQuadOperationsInAllStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).pointClippingBehavior
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(pointClippingBehavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).maxMultiviewViewCount
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(maxMultiviewViewCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).maxMultiviewInstanceIndex
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(maxMultiviewInstanceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).protectedNoFault
                as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(protectedNoFault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).maxPerSetDescriptors
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(maxPerSetDescriptors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan11Properties>())).maxMemoryAllocationSize
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan11Properties),
            "::",
            stringify!(maxMemoryAllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub samplerMirrorClampToEdge: VkBool32,
    pub drawIndirectCount: VkBool32,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
    pub descriptorIndexing: VkBool32,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
    pub samplerFilterMinmax: VkBool32,
    pub scalarBlockLayout: VkBool32,
    pub imagelessFramebuffer: VkBool32,
    pub uniformBufferStandardLayout: VkBool32,
    pub shaderSubgroupExtendedTypes: VkBool32,
    pub separateDepthStencilLayouts: VkBool32,
    pub hostQueryReset: VkBool32,
    pub timelineSemaphore: VkBool32,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
    pub shaderOutputViewportIndex: VkBool32,
    pub shaderOutputLayer: VkBool32,
    pub subgroupBroadcastDynamicId: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan12Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan12Features>(),
        208usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan12Features))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan12Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan12Features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).samplerMirrorClampToEdge
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(samplerMirrorClampToEdge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).drawIndirectCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(drawIndirectCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).storageBuffer8BitAccess
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(storageBuffer8BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .uniformAndStorageBuffer8BitAccess as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(uniformAndStorageBuffer8BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).storagePushConstant8
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(storagePushConstant8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderBufferInt64Atomics
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderBufferInt64Atomics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderSharedInt64Atomics
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderSharedInt64Atomics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderFloat16 as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderInt8 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderInt8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).descriptorIndexing
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderInputAttachmentArrayDynamicIndexing as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderInputAttachmentArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderUniformTexelBufferArrayDynamicIndexing as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderUniformTexelBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderStorageTexelBufferArrayDynamicIndexing as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderStorageTexelBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderUniformBufferArrayNonUniformIndexing as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderUniformBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderSampledImageArrayNonUniformIndexing as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderSampledImageArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderStorageBufferArrayNonUniformIndexing as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderStorageBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderStorageImageArrayNonUniformIndexing as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderStorageImageArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderInputAttachmentArrayNonUniformIndexing as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderInputAttachmentArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderUniformTexelBufferArrayNonUniformIndexing as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderUniformTexelBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .shaderStorageTexelBufferArrayNonUniformIndexing as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderStorageTexelBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingUniformBufferUpdateAfterBind as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingUniformBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingSampledImageUpdateAfterBind as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingSampledImageUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingStorageImageUpdateAfterBind as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingStorageImageUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingStorageBufferUpdateAfterBind as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingStorageBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingUniformTexelBufferUpdateAfterBind as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingUniformTexelBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingStorageTexelBufferUpdateAfterBind as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingStorageTexelBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingUpdateUnusedWhilePending as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingUpdateUnusedWhilePending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingPartiallyBound as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingPartiallyBound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .descriptorBindingVariableDescriptorCount as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(descriptorBindingVariableDescriptorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).runtimeDescriptorArray
                as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(runtimeDescriptorArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).samplerFilterMinmax
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(samplerFilterMinmax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).scalarBlockLayout
                as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(scalarBlockLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).imagelessFramebuffer
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(imagelessFramebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).uniformBufferStandardLayout
                as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(uniformBufferStandardLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderSubgroupExtendedTypes
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderSubgroupExtendedTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).separateDepthStencilLayouts
                as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(separateDepthStencilLayouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).hostQueryReset as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(hostQueryReset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).timelineSemaphore
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(timelineSemaphore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).bufferDeviceAddress
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(bufferDeviceAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .bufferDeviceAddressCaptureReplay as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(bufferDeviceAddressCaptureReplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .bufferDeviceAddressMultiDevice as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(bufferDeviceAddressMultiDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).vulkanMemoryModel
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(vulkanMemoryModel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .vulkanMemoryModelDeviceScope as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(vulkanMemoryModelDeviceScope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>()))
                .vulkanMemoryModelAvailabilityVisibilityChains as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(vulkanMemoryModelAvailabilityVisibilityChains)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderOutputViewportIndex
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderOutputViewportIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).shaderOutputLayer
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(shaderOutputLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Features>())).subgroupBroadcastDynamicId
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Features),
            "::",
            stringify!(subgroupBroadcastDynamicId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
#[test]
fn bindgen_test_layout_VkConformanceVersion() {
    assert_eq!(
        ::std::mem::size_of::<VkConformanceVersion>(),
        4usize,
        concat!("Size of: ", stringify!(VkConformanceVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<VkConformanceVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(VkConformanceVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkConformanceVersion>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConformanceVersion),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkConformanceVersion>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConformanceVersion),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkConformanceVersion>())).subminor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConformanceVersion),
            "::",
            stringify!(subminor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkConformanceVersion>())).patch as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConformanceVersion),
            "::",
            stringify!(patch)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub driverID: VkDriverId,
    pub driverName: [::std::os::raw::c_char; 256usize],
    pub driverInfo: [::std::os::raw::c_char; 256usize],
    pub conformanceVersion: VkConformanceVersion,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
    pub supportedDepthResolveModes: VkResolveModeFlags,
    pub supportedStencilResolveModes: VkResolveModeFlags,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
    pub maxTimelineSemaphoreValueDifference: u64,
    pub framebufferIntegerColorSampleCounts: VkSampleCountFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan12Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan12Properties>(),
        736usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan12Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan12Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan12Properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).driverID as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(driverID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).driverName as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(driverName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).driverInfo as *const _
                as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(driverInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).conformanceVersion
                as *const _ as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(conformanceVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .denormBehaviorIndependence as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(denormBehaviorIndependence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).roundingModeIndependence
                as *const _ as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(roundingModeIndependence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderSignedZeroInfNanPreserveFloat16 as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderSignedZeroInfNanPreserveFloat32 as *const _ as usize
        },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderSignedZeroInfNanPreserveFloat64 as *const _ as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormPreserveFloat16 as *const _ as usize
        },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormPreserveFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormPreserveFloat32 as *const _ as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormPreserveFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormPreserveFloat64 as *const _ as usize
        },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormPreserveFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormFlushToZeroFloat16 as *const _ as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormFlushToZeroFloat32 as *const _ as usize
        },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderDenormFlushToZeroFloat64 as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTEFloat16 as *const _ as usize
        },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTEFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTEFloat32 as *const _ as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTEFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTEFloat64 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTEFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTZFloat16 as *const _ as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTZFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTZFloat32 as *const _ as usize
        },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTZFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderRoundingModeRTZFloat64 as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderRoundingModeRTZFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxUpdateAfterBindDescriptorsInAllPools as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxUpdateAfterBindDescriptorsInAllPools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderUniformBufferArrayNonUniformIndexingNative as *const _ as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderUniformBufferArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderSampledImageArrayNonUniformIndexingNative as *const _ as usize
        },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderSampledImageArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderStorageBufferArrayNonUniformIndexingNative as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderStorageBufferArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderStorageImageArrayNonUniformIndexingNative as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderStorageImageArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .shaderInputAttachmentArrayNonUniformIndexingNative as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(shaderInputAttachmentArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .robustBufferAccessUpdateAfterBind as *const _ as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(robustBufferAccessUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).quadDivergentImplicitLod
                as *const _ as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(quadDivergentImplicitLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindSamplers as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindUniformBuffers as *const _ as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindStorageBuffers as *const _ as usize
        },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindSampledImages as *const _ as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindStorageImages as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageDescriptorUpdateAfterBindInputAttachments as *const _
                as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxPerStageUpdateAfterBindResources as *const _ as usize
        },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxPerStageUpdateAfterBindResources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindSamplers as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindUniformBuffers as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindUniformBuffersDynamic as *const _
                as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindStorageBuffers as *const _ as usize
        },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindStorageBuffersDynamic as *const _
                as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindSampledImages as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindStorageImages as *const _ as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxDescriptorSetUpdateAfterBindInputAttachments as *const _ as usize
        },
        692usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .supportedDepthResolveModes as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(supportedDepthResolveModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .supportedStencilResolveModes as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(supportedStencilResolveModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).independentResolveNone
                as *const _ as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(independentResolveNone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>())).independentResolve
                as *const _ as usize
        },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(independentResolve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .filterMinmaxSingleComponentFormats as *const _ as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(filterMinmaxSingleComponentFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .filterMinmaxImageComponentMapping as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(filterMinmaxImageComponentMapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .maxTimelineSemaphoreValueDifference as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(maxTimelineSemaphoreValueDifference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkan12Properties>()))
                .framebufferIntegerColorSampleCounts as *const _ as usize
        },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkan12Properties),
            "::",
            stringify!(framebufferIntegerColorSampleCounts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageFormatListCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewFormatCount: u32,
    pub pViewFormats: *const VkFormat,
}
#[test]
fn bindgen_test_layout_VkImageFormatListCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatListCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageFormatListCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatListCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatListCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatListCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatListCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatListCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatListCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatListCreateInfo>())).viewFormatCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatListCreateInfo),
            "::",
            stringify!(viewFormatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageFormatListCreateInfo>())).pViewFormats as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageFormatListCreateInfo),
            "::",
            stringify!(pViewFormats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescription2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescription2() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescription2>(),
        56usize,
        concat!("Size of: ", stringify!(VkAttachmentDescription2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescription2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentDescription2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription2>())).format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).samples as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentDescription2>())).loadOp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(loadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).storeOp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(storeOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).stencilLoadOp as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(stencilLoadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).stencilStoreOp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(stencilStoreOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).initialLayout as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(initialLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescription2>())).finalLayout as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescription2),
            "::",
            stringify!(finalLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReference2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachment: u32,
    pub layout: VkImageLayout,
    pub aspectMask: VkImageAspectFlags,
}
#[test]
fn bindgen_test_layout_VkAttachmentReference2() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReference2>(),
        32usize,
        concat!("Size of: ", stringify!(VkAttachmentReference2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReference2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentReference2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentReference2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentReference2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReference2>())).attachment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference2),
            "::",
            stringify!(attachment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAttachmentReference2>())).layout as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference2),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReference2>())).aspectMask as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReference2),
            "::",
            stringify!(aspectMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescription2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub viewMask: u32,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: *const VkAttachmentReference2,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkAttachmentReference2,
    pub pResolveAttachments: *const VkAttachmentReference2,
    pub pDepthStencilAttachment: *const VkAttachmentReference2,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: *const u32,
}
#[test]
fn bindgen_test_layout_VkSubpassDescription2() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescription2>(),
        88usize,
        concat!("Size of: ", stringify!(VkSubpassDescription2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescription2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDescription2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDescription2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDescription2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDescription2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pipelineBindPoint as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pipelineBindPoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDescription2>())).viewMask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(viewMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).inputAttachmentCount as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(inputAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pInputAttachments as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).colorAttachmentCount as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(colorAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pColorAttachments as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pColorAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pResolveAttachments as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pResolveAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pDepthStencilAttachment as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pDepthStencilAttachment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).preserveAttachmentCount as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(preserveAttachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescription2>())).pPreserveAttachments as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescription2),
            "::",
            stringify!(pPreserveAttachments)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDependency2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
    pub viewOffset: i32,
}
#[test]
fn bindgen_test_layout_VkSubpassDependency2() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDependency2>(),
        48usize,
        concat!("Size of: ", stringify!(VkSubpassDependency2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDependency2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDependency2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency2>())).srcSubpass as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(srcSubpass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency2>())).dstSubpass as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(dstSubpass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency2>())).srcStageMask as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(srcStageMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency2>())).dstStageMask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(dstStageMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency2>())).srcAccessMask as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(srcAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency2>())).dstAccessMask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(dstAccessMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDependency2>())).dependencyFlags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(dependencyFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassDependency2>())).viewOffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDependency2),
            "::",
            stringify!(viewOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreateInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: u32,
    pub pAttachments: *const VkAttachmentDescription2,
    pub subpassCount: u32,
    pub pSubpasses: *const VkSubpassDescription2,
    pub dependencyCount: u32,
    pub pDependencies: *const VkSubpassDependency2,
    pub correlatedViewMaskCount: u32,
    pub pCorrelatedViewMasks: *const u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreateInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreateInfo2>(),
        80usize,
        concat!("Size of: ", stringify!(VkRenderPassCreateInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreateInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassCreateInfo2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).attachmentCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(attachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).pAttachments as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(pAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).subpassCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(subpassCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).pSubpasses as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(pSubpasses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).dependencyCount as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(dependencyCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).pDependencies as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(pDependencies)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).correlatedViewMaskCount as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(correlatedViewMaskCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassCreateInfo2>())).pCorrelatedViewMasks as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassCreateInfo2),
            "::",
            stringify!(pCorrelatedViewMasks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub contents: VkSubpassContents,
}
#[test]
fn bindgen_test_layout_VkSubpassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassBeginInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSubpassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassBeginInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassBeginInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassBeginInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassBeginInfo>())).contents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassBeginInfo),
            "::",
            stringify!(contents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassEndInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkSubpassEndInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassEndInfo>(),
        16usize,
        concat!("Size of: ", stringify!(VkSubpassEndInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassEndInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassEndInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassEndInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassEndInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSubpassEndInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassEndInfo),
            "::",
            stringify!(pNext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice8BitStorageFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice8BitStorageFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevice8BitStorageFeatures>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDevice8BitStorageFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevice8BitStorageFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevice8BitStorageFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice8BitStorageFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice8BitStorageFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice8BitStorageFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice8BitStorageFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice8BitStorageFeatures>())).storageBuffer8BitAccess
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice8BitStorageFeatures),
            "::",
            stringify!(storageBuffer8BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice8BitStorageFeatures>()))
                .uniformAndStorageBuffer8BitAccess as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice8BitStorageFeatures),
            "::",
            stringify!(uniformAndStorageBuffer8BitAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevice8BitStorageFeatures>())).storagePushConstant8
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevice8BitStorageFeatures),
            "::",
            stringify!(storagePushConstant8)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceDriverProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub driverID: VkDriverId,
    pub driverName: [::std::os::raw::c_char; 256usize],
    pub driverInfo: [::std::os::raw::c_char; 256usize],
    pub conformanceVersion: VkConformanceVersion,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDriverProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDriverProperties>(),
        536usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceDriverProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDriverProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDriverProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).driverID as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(driverID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).driverName as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(driverName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).driverInfo as *const _
                as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(driverInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDriverProperties>())).conformanceVersion
                as *const _ as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDriverProperties),
            "::",
            stringify!(conformanceVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderAtomicInt64Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderAtomicInt64Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderAtomicInt64Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderAtomicInt64Features>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderAtomicInt64Features>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderAtomicInt64Features>()))
                .shaderBufferInt64Atomics as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
            "::",
            stringify!(shaderBufferInt64Atomics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderAtomicInt64Features>()))
                .shaderSharedInt64Atomics as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
            "::",
            stringify!(shaderSharedInt64Atomics)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderFloat16Int8Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderFloat16Int8Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderFloat16Int8Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderFloat16Int8Features>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderFloat16Int8Features>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderFloat16Int8Features>())).shaderFloat16
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
            "::",
            stringify!(shaderFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderFloat16Int8Features>())).shaderInt8
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
            "::",
            stringify!(shaderInt8)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFloatControlsProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFloatControlsProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFloatControlsProperties>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFloatControlsProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFloatControlsProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .denormBehaviorIndependence as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(denormBehaviorIndependence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .roundingModeIndependence as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(roundingModeIndependence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderSignedZeroInfNanPreserveFloat16 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderSignedZeroInfNanPreserveFloat32 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderSignedZeroInfNanPreserveFloat64 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderSignedZeroInfNanPreserveFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormPreserveFloat16 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormPreserveFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormPreserveFloat32 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormPreserveFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormPreserveFloat64 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormPreserveFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormFlushToZeroFloat16 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormFlushToZeroFloat32 as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderDenormFlushToZeroFloat64 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderDenormFlushToZeroFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTEFloat16 as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTEFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTEFloat32 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTEFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTEFloat64 as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTEFloat64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTZFloat16 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTZFloat16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTZFloat32 as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTZFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFloatControlsProperties>()))
                .shaderRoundingModeRTZFloat64 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties),
            "::",
            stringify!(shaderRoundingModeRTZFloat64)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub bindingCount: u32,
    pub pBindingFlags: *const VkDescriptorBindingFlags,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutBindingFlagsCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutBindingFlagsCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutBindingFlagsCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBindingFlagsCreateInfo>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBindingFlagsCreateInfo>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBindingFlagsCreateInfo>())).bindingCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
            "::",
            stringify!(bindingCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetLayoutBindingFlagsCreateInfo>())).pBindingFlags
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
            "::",
            stringify!(pBindingFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorIndexingFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorIndexingFeatures>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorIndexingFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderInputAttachmentArrayDynamicIndexing as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderInputAttachmentArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderUniformTexelBufferArrayDynamicIndexing as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderUniformTexelBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderStorageTexelBufferArrayDynamicIndexing as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderStorageTexelBufferArrayDynamicIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderUniformBufferArrayNonUniformIndexing as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderUniformBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderSampledImageArrayNonUniformIndexing as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderSampledImageArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderStorageBufferArrayNonUniformIndexing as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderStorageBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderStorageImageArrayNonUniformIndexing as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderStorageImageArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderInputAttachmentArrayNonUniformIndexing as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderInputAttachmentArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderUniformTexelBufferArrayNonUniformIndexing as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderUniformTexelBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .shaderStorageTexelBufferArrayNonUniformIndexing as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(shaderStorageTexelBufferArrayNonUniformIndexing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingUniformBufferUpdateAfterBind as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingUniformBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingSampledImageUpdateAfterBind as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingSampledImageUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingStorageImageUpdateAfterBind as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingStorageImageUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingStorageBufferUpdateAfterBind as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingStorageBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingUniformTexelBufferUpdateAfterBind as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingUniformTexelBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingStorageTexelBufferUpdateAfterBind as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingStorageTexelBufferUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingUpdateUnusedWhilePending as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingUpdateUnusedWhilePending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingPartiallyBound as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingPartiallyBound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .descriptorBindingVariableDescriptorCount as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(descriptorBindingVariableDescriptorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingFeatures>()))
                .runtimeDescriptorArray as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
            "::",
            stringify!(runtimeDescriptorArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorIndexingProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorIndexingProperties>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorIndexingProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxUpdateAfterBindDescriptorsInAllPools as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxUpdateAfterBindDescriptorsInAllPools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .shaderUniformBufferArrayNonUniformIndexingNative as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(shaderUniformBufferArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .shaderSampledImageArrayNonUniformIndexingNative as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(shaderSampledImageArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .shaderStorageBufferArrayNonUniformIndexingNative as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(shaderStorageBufferArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .shaderStorageImageArrayNonUniformIndexingNative as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(shaderStorageImageArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .shaderInputAttachmentArrayNonUniformIndexingNative as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(shaderInputAttachmentArrayNonUniformIndexingNative)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .robustBufferAccessUpdateAfterBind as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(robustBufferAccessUpdateAfterBind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .quadDivergentImplicitLod as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(quadDivergentImplicitLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindSamplers as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindUniformBuffers as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindStorageBuffers as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindSampledImages as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindStorageImages as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageDescriptorUpdateAfterBindInputAttachments as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindInputAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxPerStageUpdateAfterBindResources as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxPerStageUpdateAfterBindResources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindSamplers as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindUniformBuffers as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindUniformBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindUniformBuffersDynamic as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindStorageBuffers as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindStorageBuffersDynamic as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindSampledImages as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindSampledImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindStorageImages as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindStorageImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDescriptorIndexingProperties>()))
                .maxDescriptorSetUpdateAfterBindInputAttachments as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindInputAttachments)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorSetCount: u32,
    pub pDescriptorCounts: *const u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetVariableDescriptorCountAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetVariableDescriptorCountAllocateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetVariableDescriptorCountAllocateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountAllocateInfo>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountAllocateInfo>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountAllocateInfo>()))
                .descriptorSetCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
            "::",
            stringify!(descriptorSetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountAllocateInfo>()))
                .pDescriptorCounts as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
            "::",
            stringify!(pDescriptorCounts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxVariableDescriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetVariableDescriptorCountLayoutSupport() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetVariableDescriptorCountLayoutSupport>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetVariableDescriptorCountLayoutSupport>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountLayoutSupport>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountLayoutSupport>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorSetVariableDescriptorCountLayoutSupport>()))
                .maxVariableDescriptorCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
            "::",
            stringify!(maxVariableDescriptorCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescriptionDepthStencilResolve {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub depthResolveMode: VkResolveModeFlagBits,
    pub stencilResolveMode: VkResolveModeFlagBits,
    pub pDepthStencilResolveAttachment: *const VkAttachmentReference2,
}
#[test]
fn bindgen_test_layout_VkSubpassDescriptionDepthStencilResolve() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescriptionDepthStencilResolve>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescriptionDepthStencilResolve>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSubpassDescriptionDepthStencilResolve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescriptionDepthStencilResolve>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescriptionDepthStencilResolve>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescriptionDepthStencilResolve>())).depthResolveMode
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve),
            "::",
            stringify!(depthResolveMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescriptionDepthStencilResolve>())).stencilResolveMode
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve),
            "::",
            stringify!(stencilResolveMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassDescriptionDepthStencilResolve>()))
                .pDepthStencilResolveAttachment as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve),
            "::",
            stringify!(pDepthStencilResolveAttachment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportedDepthResolveModes: VkResolveModeFlags,
    pub supportedStencilResolveModes: VkResolveModeFlags,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthStencilResolveProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthStencilResolveProperties>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthStencilResolveProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>()))
                .supportedDepthResolveModes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(supportedDepthResolveModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>()))
                .supportedStencilResolveModes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(supportedStencilResolveModes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>()))
                .independentResolveNone as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(independentResolveNone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthStencilResolveProperties>()))
                .independentResolve as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
            "::",
            stringify!(independentResolve)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub scalarBlockLayout: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceScalarBlockLayoutFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceScalarBlockLayoutFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceScalarBlockLayoutFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceScalarBlockLayoutFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceScalarBlockLayoutFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceScalarBlockLayoutFeatures>())).scalarBlockLayout
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
            "::",
            stringify!(scalarBlockLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageStencilUsageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub stencilUsage: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkImageStencilUsageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageStencilUsageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageStencilUsageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageStencilUsageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageStencilUsageCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageStencilUsageCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageStencilUsageCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageStencilUsageCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageStencilUsageCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageStencilUsageCreateInfo>())).stencilUsage as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageStencilUsageCreateInfo),
            "::",
            stringify!(stencilUsage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerReductionModeCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub reductionMode: VkSamplerReductionMode,
}
#[test]
fn bindgen_test_layout_VkSamplerReductionModeCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerReductionModeCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSamplerReductionModeCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerReductionModeCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerReductionModeCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerReductionModeCreateInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerReductionModeCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerReductionModeCreateInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerReductionModeCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSamplerReductionModeCreateInfo>())).reductionMode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSamplerReductionModeCreateInfo),
            "::",
            stringify!(reductionMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSamplerFilterMinmaxProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSamplerFilterMinmaxProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSamplerFilterMinmaxProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerFilterMinmaxProperties>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerFilterMinmaxProperties>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerFilterMinmaxProperties>()))
                .filterMinmaxSingleComponentFormats as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
            "::",
            stringify!(filterMinmaxSingleComponentFormats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSamplerFilterMinmaxProperties>()))
                .filterMinmaxImageComponentMapping as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
            "::",
            stringify!(filterMinmaxImageComponentMapping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkanMemoryModelFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkanMemoryModelFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkanMemoryModelFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkanMemoryModelFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkanMemoryModelFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkanMemoryModelFeatures>())).vulkanMemoryModel
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
            "::",
            stringify!(vulkanMemoryModel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkanMemoryModelFeatures>()))
                .vulkanMemoryModelDeviceScope as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
            "::",
            stringify!(vulkanMemoryModelDeviceScope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVulkanMemoryModelFeatures>()))
                .vulkanMemoryModelAvailabilityVisibilityChains as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
            "::",
            stringify!(vulkanMemoryModelAvailabilityVisibilityChains)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imagelessFramebuffer: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImagelessFramebufferFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImagelessFramebufferFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImagelessFramebufferFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImagelessFramebufferFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImagelessFramebufferFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImagelessFramebufferFeatures>()))
                .imagelessFramebuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
            "::",
            stringify!(imagelessFramebuffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferAttachmentImageInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub usage: VkImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layerCount: u32,
    pub viewFormatCount: u32,
    pub pViewFormats: *const VkFormat,
}
#[test]
fn bindgen_test_layout_VkFramebufferAttachmentImageInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferAttachmentImageInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkFramebufferAttachmentImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferAttachmentImageInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferAttachmentImageInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).usage as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).layerCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(layerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).viewFormatCount as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(viewFormatCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentImageInfo>())).pViewFormats as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentImageInfo),
            "::",
            stringify!(pViewFormats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferAttachmentsCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentImageInfoCount: u32,
    pub pAttachmentImageInfos: *const VkFramebufferAttachmentImageInfo,
}
#[test]
fn bindgen_test_layout_VkFramebufferAttachmentsCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferAttachmentsCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkFramebufferAttachmentsCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferAttachmentsCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferAttachmentsCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentsCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentsCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentsCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentsCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentsCreateInfo>())).attachmentImageInfoCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentsCreateInfo),
            "::",
            stringify!(attachmentImageInfoCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferAttachmentsCreateInfo>())).pAttachmentImageInfos
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferAttachmentsCreateInfo),
            "::",
            stringify!(pAttachmentImageInfos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassAttachmentBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentCount: u32,
    pub pAttachments: *const VkImageView,
}
#[test]
fn bindgen_test_layout_VkRenderPassAttachmentBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassAttachmentBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkRenderPassAttachmentBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassAttachmentBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassAttachmentBeginInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassAttachmentBeginInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassAttachmentBeginInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassAttachmentBeginInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassAttachmentBeginInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassAttachmentBeginInfo>())).attachmentCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassAttachmentBeginInfo),
            "::",
            stringify!(attachmentCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassAttachmentBeginInfo>())).pAttachments as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassAttachmentBeginInfo),
            "::",
            stringify!(pAttachments)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub uniformBufferStandardLayout: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceUniformBufferStandardLayoutFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>()))
                .uniformBufferStandardLayout as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
            "::",
            stringify!(uniformBufferStandardLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSubgroupExtendedTypes: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>()))
                .shaderSubgroupExtendedTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
            "::",
            stringify!(shaderSubgroupExtendedTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub separateDepthStencilLayouts: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>()))
                .separateDepthStencilLayouts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
            "::",
            stringify!(separateDepthStencilLayouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReferenceStencilLayout {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stencilLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentReferenceStencilLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReferenceStencilLayout>(),
        24usize,
        concat!("Size of: ", stringify!(VkAttachmentReferenceStencilLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReferenceStencilLayout>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAttachmentReferenceStencilLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReferenceStencilLayout>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReferenceStencilLayout),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReferenceStencilLayout>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReferenceStencilLayout),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentReferenceStencilLayout>())).stencilLayout as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentReferenceStencilLayout),
            "::",
            stringify!(stencilLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescriptionStencilLayout {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stencilInitialLayout: VkImageLayout,
    pub stencilFinalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescriptionStencilLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescriptionStencilLayout>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkAttachmentDescriptionStencilLayout)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescriptionStencilLayout>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAttachmentDescriptionStencilLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescriptionStencilLayout>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescriptionStencilLayout),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescriptionStencilLayout>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescriptionStencilLayout),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescriptionStencilLayout>())).stencilInitialLayout
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescriptionStencilLayout),
            "::",
            stringify!(stencilInitialLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentDescriptionStencilLayout>())).stencilFinalLayout
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentDescriptionStencilLayout),
            "::",
            stringify!(stencilFinalLayout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceHostQueryResetFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub hostQueryReset: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceHostQueryResetFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceHostQueryResetFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceHostQueryResetFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceHostQueryResetFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceHostQueryResetFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceHostQueryResetFeatures>())).hostQueryReset
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures),
            "::",
            stringify!(hostQueryReset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub timelineSemaphore: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTimelineSemaphoreFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTimelineSemaphoreFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTimelineSemaphoreFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreFeatures>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreFeatures>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreFeatures>())).timelineSemaphore
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
            "::",
            stringify!(timelineSemaphore)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxTimelineSemaphoreValueDifference: u64,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTimelineSemaphoreProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTimelineSemaphoreProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTimelineSemaphoreProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreProperties>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreProperties>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTimelineSemaphoreProperties>()))
                .maxTimelineSemaphoreValueDifference as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
            "::",
            stringify!(maxTimelineSemaphoreValueDifference)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreTypeCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphoreType: VkSemaphoreType,
    pub initialValue: u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreTypeCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreTypeCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreTypeCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreTypeCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreTypeCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreTypeCreateInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreTypeCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreTypeCreateInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreTypeCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSemaphoreTypeCreateInfo>())).semaphoreType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreTypeCreateInfo),
            "::",
            stringify!(semaphoreType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSemaphoreTypeCreateInfo>())).initialValue as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreTypeCreateInfo),
            "::",
            stringify!(initialValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkTimelineSemaphoreSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreValueCount: u32,
    pub pWaitSemaphoreValues: *const u64,
    pub signalSemaphoreValueCount: u32,
    pub pSignalSemaphoreValues: *const u64,
}
#[test]
fn bindgen_test_layout_VkTimelineSemaphoreSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkTimelineSemaphoreSubmitInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkTimelineSemaphoreSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTimelineSemaphoreSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkTimelineSemaphoreSubmitInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).waitSemaphoreValueCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(waitSemaphoreValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).pWaitSemaphoreValues
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(pWaitSemaphoreValues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).signalSemaphoreValueCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(signalSemaphoreValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTimelineSemaphoreSubmitInfo>())).pSignalSemaphoreValues
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTimelineSemaphoreSubmitInfo),
            "::",
            stringify!(pSignalSemaphoreValues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreWaitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreWaitFlags,
    pub semaphoreCount: u32,
    pub pSemaphores: *const VkSemaphore,
    pub pValues: *const u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreWaitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreWaitInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkSemaphoreWaitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreWaitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreWaitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).semaphoreCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(semaphoreCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).pSemaphores as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(pSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreWaitInfo>())).pValues as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreWaitInfo),
            "::",
            stringify!(pValues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreSignalInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreSignalInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreSignalInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreSignalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreSignalInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreSignalInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreSignalInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreSignalInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreSignalInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreSignalInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreSignalInfo>())).semaphore as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreSignalInfo),
            "::",
            stringify!(semaphore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreSignalInfo>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreSignalInfo),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBufferDeviceAddressFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBufferDeviceAddressFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBufferDeviceAddressFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeatures>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeatures>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeatures>()))
                .bufferDeviceAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
            "::",
            stringify!(bufferDeviceAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeatures>()))
                .bufferDeviceAddressCaptureReplay as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
            "::",
            stringify!(bufferDeviceAddressCaptureReplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeatures>()))
                .bufferDeviceAddressMultiDevice as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
            "::",
            stringify!(bufferDeviceAddressMultiDevice)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferDeviceAddressInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferDeviceAddressInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferDeviceAddressInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferDeviceAddressInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferDeviceAddressInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferDeviceAddressInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferDeviceAddressInfo>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkBufferDeviceAddressInfo>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferDeviceAddressInfo>())).buffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressInfo),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub opaqueCaptureAddress: u64,
}
#[test]
fn bindgen_test_layout_VkBufferOpaqueCaptureAddressCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferOpaqueCaptureAddressCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferOpaqueCaptureAddressCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferOpaqueCaptureAddressCreateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferOpaqueCaptureAddressCreateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferOpaqueCaptureAddressCreateInfo>())).opaqueCaptureAddress
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
            "::",
            stringify!(opaqueCaptureAddress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub opaqueCaptureAddress: u64,
}
#[test]
fn bindgen_test_layout_VkMemoryOpaqueCaptureAddressAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryOpaqueCaptureAddressAllocateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryOpaqueCaptureAddressAllocateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryOpaqueCaptureAddressAllocateInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryOpaqueCaptureAddressAllocateInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryOpaqueCaptureAddressAllocateInfo>()))
                .opaqueCaptureAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
            "::",
            stringify!(opaqueCaptureAddress)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
}
#[test]
fn bindgen_test_layout_VkDeviceMemoryOpaqueCaptureAddressInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceMemoryOpaqueCaptureAddressInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceMemoryOpaqueCaptureAddressInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOpaqueCaptureAddressInfo>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOpaqueCaptureAddressInfo>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOpaqueCaptureAddressInfo>())).memory as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
            "::",
            stringify!(memory)
        )
    );
}
pub type PFN_vkCmdDrawIndirectCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCreateRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkCmdBeginRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    ),
>;
pub type PFN_vkCmdNextSubpass2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    ),
>;
pub type PFN_vkCmdEndRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo),
>;
pub type PFN_vkResetQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
pub type PFN_vkGetSemaphoreCounterValue = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut u64) -> VkResult,
>;
pub type PFN_vkWaitSemaphores = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkSignalSemaphore = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult,
>;
pub type PFN_vkGetBufferDeviceAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
pub type PFN_vkGetBufferOpaqueCaptureAddress = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64,
>;
pub type PFN_vkGetDeviceMemoryOpaqueCaptureAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64,
>;
extern "C" {
    pub fn vkCmdDrawIndirectCount(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCount(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCreateRenderPass2(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBeginRenderPass2(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass2(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRenderPass2(
        commandBuffer: VkCommandBuffer,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkResetQueryPool(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
extern "C" {
    pub fn vkGetSemaphoreCounterValue(
        device: VkDevice,
        semaphore: VkSemaphore,
        pValue: *mut u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWaitSemaphores(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSignalSemaphore(
        device: VkDevice,
        pSignalInfo: *const VkSemaphoreSignalInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetBufferDeviceAddress(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
extern "C" {
    pub fn vkGetBufferOpaqueCaptureAddress(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> u64;
}
extern "C" {
    pub fn vkGetDeviceMemoryOpaqueCaptureAddress(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceKHR_T {
    _unused: [u8; 0],
}
pub type VkSurfaceKHR = *mut VkSurfaceKHR_T;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = 0;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT: VkColorSpaceKHR = 1000104001;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT: VkColorSpaceKHR = 1000104002;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT: VkColorSpaceKHR = 1000104003;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT: VkColorSpaceKHR = 1000104004;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_BT709_LINEAR_EXT: VkColorSpaceKHR = 1000104005;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_BT709_NONLINEAR_EXT: VkColorSpaceKHR = 1000104006;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_BT2020_LINEAR_EXT: VkColorSpaceKHR = 1000104007;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_HDR10_ST2084_EXT: VkColorSpaceKHR = 1000104008;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DOLBYVISION_EXT: VkColorSpaceKHR = 1000104009;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_HDR10_HLG_EXT: VkColorSpaceKHR = 1000104010;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT: VkColorSpaceKHR = 1000104011;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT: VkColorSpaceKHR = 1000104012;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_PASS_THROUGH_EXT: VkColorSpaceKHR = 1000104013;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT: VkColorSpaceKHR = 1000104014;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DISPLAY_NATIVE_AMD: VkColorSpaceKHR = 1000213000;
pub const VkColorSpaceKHR_VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = 0;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR = 1000104003;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_BEGIN_RANGE_KHR: VkColorSpaceKHR = 0;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_END_RANGE_KHR: VkColorSpaceKHR = 0;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_RANGE_SIZE_KHR: VkColorSpaceKHR = 1;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_MAX_ENUM_KHR: VkColorSpaceKHR = 2147483647;
pub type VkColorSpaceKHR = ::std::os::raw::c_uint;
pub const VkPresentModeKHR_VK_PRESENT_MODE_IMMEDIATE_KHR: VkPresentModeKHR = 0;
pub const VkPresentModeKHR_VK_PRESENT_MODE_MAILBOX_KHR: VkPresentModeKHR = 1;
pub const VkPresentModeKHR_VK_PRESENT_MODE_FIFO_KHR: VkPresentModeKHR = 2;
pub const VkPresentModeKHR_VK_PRESENT_MODE_FIFO_RELAXED_KHR: VkPresentModeKHR = 3;
pub const VkPresentModeKHR_VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: VkPresentModeKHR = 1000111000;
pub const VkPresentModeKHR_VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: VkPresentModeKHR =
    1000111001;
pub const VkPresentModeKHR_VK_PRESENT_MODE_BEGIN_RANGE_KHR: VkPresentModeKHR = 0;
pub const VkPresentModeKHR_VK_PRESENT_MODE_END_RANGE_KHR: VkPresentModeKHR = 3;
pub const VkPresentModeKHR_VK_PRESENT_MODE_RANGE_SIZE_KHR: VkPresentModeKHR = 4;
pub const VkPresentModeKHR_VK_PRESENT_MODE_MAX_ENUM_KHR: VkPresentModeKHR = 2147483647;
pub type VkPresentModeKHR = ::std::os::raw::c_uint;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 1;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 2;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 4;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 8;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 16;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 32;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR : VkSurfaceTransformFlagBitsKHR = 64 ;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR : VkSurfaceTransformFlagBitsKHR = 128 ;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR:
    VkSurfaceTransformFlagBitsKHR = 256;
pub const VkSurfaceTransformFlagBitsKHR_VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR:
    VkSurfaceTransformFlagBitsKHR = 2147483647;
pub type VkSurfaceTransformFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkSurfaceTransformFlagsKHR = VkFlags;
pub const VkCompositeAlphaFlagBitsKHR_VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR:
    VkCompositeAlphaFlagBitsKHR = 1;
pub const VkCompositeAlphaFlagBitsKHR_VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR:
    VkCompositeAlphaFlagBitsKHR = 2;
pub const VkCompositeAlphaFlagBitsKHR_VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR:
    VkCompositeAlphaFlagBitsKHR = 4;
pub const VkCompositeAlphaFlagBitsKHR_VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR:
    VkCompositeAlphaFlagBitsKHR = 8;
pub const VkCompositeAlphaFlagBitsKHR_VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR:
    VkCompositeAlphaFlagBitsKHR = 2147483647;
pub type VkCompositeAlphaFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkCompositeAlphaFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilitiesKHR {
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilitiesKHR>(),
        52usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilitiesKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilitiesKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).minImageCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(minImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).maxImageCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(maxImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).currentExtent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(currentExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).minImageExtent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(minImageExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).maxImageExtent as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(maxImageExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).maxImageArrayLayers as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(maxImageArrayLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).supportedTransforms as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(supportedTransforms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).currentTransform as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(currentTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).supportedCompositeAlpha as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(supportedCompositeAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilitiesKHR>())).supportedUsageFlags as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilitiesKHR),
            "::",
            stringify!(supportedUsageFlags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormatKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceFormatKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkSurfaceFormatKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceFormatKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSurfaceFormatKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceFormatKHR>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceFormatKHR),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceFormatKHR>())).colorSpace as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceFormatKHR),
            "::",
            stringify!(colorSpace)
        )
    );
}
pub type PFN_vkDestroySurfaceKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        surface: VkSurfaceKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut u32,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkDestroySurfaceKHR(
        instance: VkInstance,
        surface: VkSurfaceKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut u32,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainKHR_T {
    _unused: [u8; 0],
}
pub type VkSwapchainKHR = *mut VkSwapchainKHR_T;
pub const VkSwapchainCreateFlagBitsKHR_VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR:
    VkSwapchainCreateFlagBitsKHR = 1;
pub const VkSwapchainCreateFlagBitsKHR_VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR:
    VkSwapchainCreateFlagBitsKHR = 2;
pub const VkSwapchainCreateFlagBitsKHR_VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR:
    VkSwapchainCreateFlagBitsKHR = 4;
pub const VkSwapchainCreateFlagBitsKHR_VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR:
    VkSwapchainCreateFlagBitsKHR = 2147483647;
pub type VkSwapchainCreateFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkSwapchainCreateFlagsKHR = VkFlags;
pub const VkDeviceGroupPresentModeFlagBitsKHR_VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR:
    VkDeviceGroupPresentModeFlagBitsKHR = 1;
pub const VkDeviceGroupPresentModeFlagBitsKHR_VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR:
    VkDeviceGroupPresentModeFlagBitsKHR = 2;
pub const VkDeviceGroupPresentModeFlagBitsKHR_VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR:
    VkDeviceGroupPresentModeFlagBitsKHR = 4;
pub const VkDeviceGroupPresentModeFlagBitsKHR_VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR : VkDeviceGroupPresentModeFlagBitsKHR = 8 ;
pub const VkDeviceGroupPresentModeFlagBitsKHR_VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR : VkDeviceGroupPresentModeFlagBitsKHR = 2147483647 ;
pub type VkDeviceGroupPresentModeFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkDeviceGroupPresentModeFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: u32,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: u32,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainCreateInfoKHR>(),
        104usize,
        concat!("Size of: ", stringify!(VkSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSwapchainCreateInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).surface as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).minImageCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(minImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageFormat as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageColorSpace as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageColorSpace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageExtent as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageArrayLayers as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageArrayLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageUsage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).imageSharingMode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(imageSharingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).queueFamilyIndexCount as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).pQueueFamilyIndices as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).preTransform as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(preTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).compositeAlpha as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(compositeAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).presentMode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(presentMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).clipped as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(clipped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCreateInfoKHR>())).oldSwapchain as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCreateInfoKHR),
            "::",
            stringify!(oldSwapchain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: u32,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const u32,
    pub pResults: *mut VkResult,
}
#[test]
fn bindgen_test_layout_VkPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentInfoKHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentInfoKHR>())).waitSemaphoreCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(waitSemaphoreCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentInfoKHR>())).pWaitSemaphores as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(pWaitSemaphores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).swapchainCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(swapchainCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).pSwapchains as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(pSwapchains)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).pImageIndices as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(pImageIndices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentInfoKHR>())).pResults as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentInfoKHR),
            "::",
            stringify!(pResults)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkImageSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSwapchainCreateInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSwapchainCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageSwapchainCreateInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSwapchainCreateInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSwapchainCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSwapchainCreateInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSwapchainCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageSwapchainCreateInfoKHR>())).swapchain as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageSwapchainCreateInfoKHR),
            "::",
            stringify!(swapchain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemorySwapchainInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub imageIndex: u32,
}
#[test]
fn bindgen_test_layout_VkBindImageMemorySwapchainInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemorySwapchainInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkBindImageMemorySwapchainInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemorySwapchainInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindImageMemorySwapchainInfoKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemorySwapchainInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemorySwapchainInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemorySwapchainInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemorySwapchainInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemorySwapchainInfoKHR>())).swapchain as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemorySwapchainInfoKHR),
            "::",
            stringify!(swapchain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindImageMemorySwapchainInfoKHR>())).imageIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindImageMemorySwapchainInfoKHR),
            "::",
            stringify!(imageIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAcquireNextImageInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub timeout: u64,
    pub semaphore: VkSemaphore,
    pub fence: VkFence,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkAcquireNextImageInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAcquireNextImageInfoKHR>(),
        56usize,
        concat!("Size of: ", stringify!(VkAcquireNextImageInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAcquireNextImageInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAcquireNextImageInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).swapchain as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(swapchain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).timeout as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).semaphore as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(semaphore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).fence as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireNextImageInfoKHR>())).deviceMask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireNextImageInfoKHR),
            "::",
            stringify!(deviceMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupPresentCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub presentMask: [u32; 32usize],
    pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupPresentCapabilitiesKHR>(),
        152usize,
        concat!("Size of: ", stringify!(VkDeviceGroupPresentCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupPresentCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentCapabilitiesKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentCapabilitiesKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentCapabilitiesKHR>())).presentMask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR),
            "::",
            stringify!(presentMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentCapabilitiesKHR>())).modes as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR),
            "::",
            stringify!(modes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pDeviceMasks: *const u32,
    pub mode: VkDeviceGroupPresentModeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupPresentInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkDeviceGroupPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupPresentInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentInfoKHR>())).swapchainCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentInfoKHR),
            "::",
            stringify!(swapchainCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentInfoKHR>())).pDeviceMasks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentInfoKHR),
            "::",
            stringify!(pDeviceMasks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupPresentInfoKHR>())).mode as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupPresentInfoKHR),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupSwapchainCreateInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupSwapchainCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupSwapchainCreateInfoKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSwapchainCreateInfoKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSwapchainCreateInfoKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGroupSwapchainCreateInfoKHR>())).modes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
            "::",
            stringify!(modes)
        )
    );
}
pub type PFN_vkCreateSwapchainKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult,
>;
pub type PFN_vkDestroySwapchainKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetSwapchainImagesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut u32,
        pSwapchainImages: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkAcquireNextImageKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        timeout: u64,
        semaphore: VkSemaphore,
        fence: VkFence,
        pImageIndex: *mut u32,
    ) -> VkResult,
>;
pub type PFN_vkQueuePresentKHR = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupPresentCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupSurfacePresentModesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        surface: VkSurfaceKHR,
        pModes: *mut VkDeviceGroupPresentModeFlagsKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDevicePresentRectanglesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pRectCount: *mut u32,
        pRects: *mut VkRect2D,
    ) -> VkResult,
>;
pub type PFN_vkAcquireNextImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAcquireInfo: *const VkAcquireNextImageInfoKHR,
        pImageIndex: *mut u32,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateSwapchainKHR(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySwapchainKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetSwapchainImagesKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut u32,
        pSwapchainImages: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImageKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        timeout: u64,
        semaphore: VkSemaphore,
        fence: VkFence,
        pImageIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueuePresentKHR(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupPresentCapabilitiesKHR(
        device: VkDevice,
        pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupSurfacePresentModesKHR(
        device: VkDevice,
        surface: VkSurfaceKHR,
        pModes: *mut VkDeviceGroupPresentModeFlagsKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDevicePresentRectanglesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pRectCount: *mut u32,
        pRects: *mut VkRect2D,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImage2KHR(
        device: VkDevice,
        pAcquireInfo: *const VkAcquireNextImageInfoKHR,
        pImageIndex: *mut u32,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayKHR = *mut VkDisplayKHR_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayModeKHR = *mut VkDisplayModeKHR_T;
pub const VkDisplayPlaneAlphaFlagBitsKHR_VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR:
    VkDisplayPlaneAlphaFlagBitsKHR = 1;
pub const VkDisplayPlaneAlphaFlagBitsKHR_VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR:
    VkDisplayPlaneAlphaFlagBitsKHR = 2;
pub const VkDisplayPlaneAlphaFlagBitsKHR_VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR:
    VkDisplayPlaneAlphaFlagBitsKHR = 4;
pub const VkDisplayPlaneAlphaFlagBitsKHR_VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR:
    VkDisplayPlaneAlphaFlagBitsKHR = 8;
pub const VkDisplayPlaneAlphaFlagBitsKHR_VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR:
    VkDisplayPlaneAlphaFlagBitsKHR = 2147483647;
pub type VkDisplayPlaneAlphaFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const ::std::os::raw::c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPropertiesKHR>(),
        48usize,
        concat!("Size of: ", stringify!(VkDisplayPropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPropertiesKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).displayName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(displayName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).physicalDimensions as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(physicalDimensions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).physicalResolution as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(physicalResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).supportedTransforms as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(supportedTransforms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).planeReorderPossible as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(planeReorderPossible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPropertiesKHR>())).persistentContent as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPropertiesKHR),
            "::",
            stringify!(persistentContent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayModeParametersKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeParametersKHR>(),
        12usize,
        concat!("Size of: ", stringify!(VkDisplayModeParametersKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeParametersKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDisplayModeParametersKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeParametersKHR>())).visibleRegion as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeParametersKHR),
            "::",
            stringify!(visibleRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeParametersKHR>())).refreshRate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeParametersKHR),
            "::",
            stringify!(refreshRate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModePropertiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayModePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModePropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModePropertiesKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModePropertiesKHR>())).displayMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModePropertiesKHR),
            "::",
            stringify!(displayMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModePropertiesKHR>())).parameters as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModePropertiesKHR),
            "::",
            stringify!(parameters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModeCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeCreateInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayModeCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModeCreateInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeCreateInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeCreateInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeCreateInfoKHR>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeCreateInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeCreateInfoKHR>())).parameters as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeCreateInfoKHR),
            "::",
            stringify!(parameters)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneCapabilitiesKHR>(),
        68usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneCapabilitiesKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneCapabilitiesKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).supportedAlpha as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(supportedAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).minSrcPosition as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(minSrcPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).maxSrcPosition as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(maxSrcPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).minSrcExtent as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(minSrcExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).maxSrcExtent as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(maxSrcExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).minDstPosition as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(minDstPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).maxDstPosition as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(maxDstPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).minDstExtent as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(minDstExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilitiesKHR>())).maxDstExtent as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilitiesKHR),
            "::",
            stringify!(maxDstExtent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayPlanePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlanePropertiesKHR>(),
        16usize,
        concat!("Size of: ", stringify!(VkDisplayPlanePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlanePropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlanePropertiesKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlanePropertiesKHR>())).currentDisplay as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlanePropertiesKHR),
            "::",
            stringify!(currentDisplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlanePropertiesKHR>())).currentStackIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlanePropertiesKHR),
            "::",
            stringify!(currentStackIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: u32,
    pub planeStackIndex: u32,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: f32,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplaySurfaceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplaySurfaceCreateInfoKHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkDisplaySurfaceCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplaySurfaceCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplaySurfaceCreateInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).displayMode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(displayMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).planeIndex as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(planeIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).planeStackIndex as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(planeStackIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).transform as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).globalAlpha as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(globalAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).alphaMode as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(alphaMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplaySurfaceCreateInfoKHR>())).imageExtent as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplaySurfaceCreateInfoKHR),
            "::",
            stringify!(imageExtent)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        planeIndex: u32,
        pDisplayCount: *mut u32,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayModePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkCreateDisplayModeKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: u32,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(
        physicalDevice: VkPhysicalDevice,
        planeIndex: u32,
        pDisplayCount: *mut u32,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayModePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayModeKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: u32,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayPlaneSurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPresentInfoKHR>(),
        56usize,
        concat!("Size of: ", stringify!(VkDisplayPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPresentInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPresentInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPresentInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPresentInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPresentInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPresentInfoKHR>())).srcRect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPresentInfoKHR),
            "::",
            stringify!(srcRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPresentInfoKHR>())).dstRect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPresentInfoKHR),
            "::",
            stringify!(dstRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPresentInfoKHR>())).persistent as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPresentInfoKHR),
            "::",
            stringify!(persistent)
        )
    );
}
pub type PFN_vkCreateSharedSwapchainsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchainCount: u32,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateSharedSwapchainsKHR(
        device: VkDevice,
        swapchainCount: u32,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult;
}
pub type VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
pub type VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
pub type VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
pub type VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
pub type VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
pub type VkFormatProperties2KHR = VkFormatProperties2;
pub type VkImageFormatProperties2KHR = VkImageFormatProperties2;
pub type VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
pub type VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
pub type VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
pub type VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
pub type VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
pub type PFN_vkGetPhysicalDeviceFeatures2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures2KHR(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    );
}
pub type VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
pub use self::VkPeerMemoryFeatureFlagBits as VkPeerMemoryFeatureFlagBitsKHR;
pub type VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
pub use self::VkMemoryAllocateFlagBits as VkMemoryAllocateFlagBitsKHR;
pub type VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
pub type VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
pub type VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
pub type VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
pub type VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
pub type VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
pub type VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
pub type PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    ),
>;
pub type PFN_vkCmdSetDeviceMaskKHR =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, deviceMask: u32)>;
pub type PFN_vkCmdDispatchBaseKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
extern "C" {
    pub fn vkGetDeviceGroupPeerMemoryFeaturesKHR(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    );
}
extern "C" {
    pub fn vkCmdSetDeviceMaskKHR(commandBuffer: VkCommandBuffer, deviceMask: u32);
}
extern "C" {
    pub fn vkCmdDispatchBaseKHR(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
pub type VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;
pub type PFN_vkTrimCommandPoolKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    ),
>;
extern "C" {
    pub fn vkTrimCommandPoolKHR(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    );
}
pub type VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
pub type VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
pub type PFN_vkEnumeratePhysicalDeviceGroupsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkEnumeratePhysicalDeviceGroupsKHR(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult;
}
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
pub use self::VkExternalMemoryHandleTypeFlagBits as VkExternalMemoryHandleTypeFlagBitsKHR;
pub type VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
pub use self::VkExternalMemoryFeatureFlagBits as VkExternalMemoryFeatureFlagBitsKHR;
pub type VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
pub type VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
pub type VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
pub type VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
pub type VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
pub type VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
pub type PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    );
}
pub type VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
pub type VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
pub type VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportMemoryFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportMemoryFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportMemoryFdInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkImportMemoryFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportMemoryFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportMemoryFdInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportMemoryFdInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportMemoryFdInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportMemoryFdInfoKHR>())).handleType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportMemoryFdInfoKHR>())).fd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryFdInfoKHR),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryFdPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryFdPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryFdPropertiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryFdPropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryFdPropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryFdPropertiesKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryFdPropertiesKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryFdPropertiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryFdPropertiesKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryFdPropertiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryFdPropertiesKHR>())).memoryTypeBits as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryFdPropertiesKHR),
            "::",
            stringify!(memoryTypeBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkMemoryGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryGetFdInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryGetFdInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryGetFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryGetFdInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryGetFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryGetFdInfoKHR>())).memory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryGetFdInfoKHR),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkMemoryGetFdInfoKHR>())).handleType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryGetFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
}
pub type PFN_vkGetMemoryFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkMemoryGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
pub type PFN_vkGetMemoryFdPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        fd: ::std::os::raw::c_int,
        pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetMemoryFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkMemoryGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetMemoryFdPropertiesKHR(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        fd: ::std::os::raw::c_int,
        pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR,
    ) -> VkResult;
}
pub type VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
pub use self::VkExternalSemaphoreHandleTypeFlagBits as VkExternalSemaphoreHandleTypeFlagBitsKHR;
pub type VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
pub use self::VkExternalSemaphoreFeatureFlagBits as VkExternalSemaphoreFeatureFlagBitsKHR;
pub type VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
pub type VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
pub type PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    );
}
pub type VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
pub use self::VkSemaphoreImportFlagBits as VkSemaphoreImportFlagBitsKHR;
pub type VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportSemaphoreFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub flags: VkSemaphoreImportFlags,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportSemaphoreFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportSemaphoreFdInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkImportSemaphoreFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportSemaphoreFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportSemaphoreFdInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).semaphore as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(semaphore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).handleType as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportSemaphoreFdInfoKHR>())).fd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportSemaphoreFdInfoKHR),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkSemaphoreGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreGetFdInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreGetFdInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreGetFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSemaphoreGetFdInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreGetFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSemaphoreGetFdInfoKHR>())).semaphore as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreGetFdInfoKHR),
            "::",
            stringify!(semaphore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSemaphoreGetFdInfoKHR>())).handleType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSemaphoreGetFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
}
pub type PFN_vkImportSemaphoreFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetSemaphoreFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkImportSemaphoreFdKHR(
        device: VkDevice,
        pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetSemaphoreFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxPushDescriptors: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePushDescriptorPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePushDescriptorPropertiesKHR>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePushDescriptorPropertiesKHR>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePushDescriptorPropertiesKHR>()))
                .maxPushDescriptors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
            "::",
            stringify!(maxPushDescriptors)
        )
    );
}
pub type PFN_vkCmdPushDescriptorSetKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
    ),
>;
pub type PFN_vkCmdPushDescriptorSetWithTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        layout: VkPipelineLayout,
        set: u32,
        pData: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn vkCmdPushDescriptorSetKHR(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
    );
}
extern "C" {
    pub fn vkCmdPushDescriptorSetWithTemplateKHR(
        commandBuffer: VkCommandBuffer,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        layout: VkPipelineLayout,
        set: u32,
        pData: *const ::std::os::raw::c_void,
    );
}
pub type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub type VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub type VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRectLayerKHR {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
    pub layer: u32,
}
#[test]
fn bindgen_test_layout_VkRectLayerKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRectLayerKHR>(),
        20usize,
        concat!("Size of: ", stringify!(VkRectLayerKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRectLayerKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkRectLayerKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRectLayerKHR>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRectLayerKHR),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRectLayerKHR>())).extent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRectLayerKHR),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkRectLayerKHR>())).layer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRectLayerKHR),
            "::",
            stringify!(layer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentRegionKHR {
    pub rectangleCount: u32,
    pub pRectangles: *const VkRectLayerKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentRegionKHR>(),
        16usize,
        concat!("Size of: ", stringify!(VkPresentRegionKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentRegionKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentRegionKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentRegionKHR>())).rectangleCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionKHR),
            "::",
            stringify!(rectangleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentRegionKHR>())).pRectangles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionKHR),
            "::",
            stringify!(pRectangles)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentRegionsKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pRegions: *const VkPresentRegionKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionsKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentRegionsKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPresentRegionsKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentRegionsKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentRegionsKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentRegionsKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionsKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentRegionsKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionsKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentRegionsKHR>())).swapchainCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionsKHR),
            "::",
            stringify!(swapchainCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentRegionsKHR>())).pRegions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentRegionsKHR),
            "::",
            stringify!(pRegions)
        )
    );
}
pub type VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
pub use self::VkDescriptorUpdateTemplateType as VkDescriptorUpdateTemplateTypeKHR;
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
pub type VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
pub type VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
pub type PFN_vkCreateDescriptorUpdateTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorUpdateTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkUpdateDescriptorSetWithTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn vkCreateDescriptorUpdateTemplateKHR(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorUpdateTemplateKHR(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkUpdateDescriptorSetWithTemplateKHR(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    );
}
pub type VkPhysicalDeviceImagelessFramebufferFeaturesKHR =
    VkPhysicalDeviceImagelessFramebufferFeatures;
pub type VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
pub type VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
pub type VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
pub type VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
pub type VkAttachmentDescription2KHR = VkAttachmentDescription2;
pub type VkAttachmentReference2KHR = VkAttachmentReference2;
pub type VkSubpassDescription2KHR = VkSubpassDescription2;
pub type VkSubpassDependency2KHR = VkSubpassDependency2;
pub type VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
pub type VkSubpassEndInfoKHR = VkSubpassEndInfo;
pub type PFN_vkCreateRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkCmdBeginRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    ),
>;
pub type PFN_vkCmdNextSubpass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    ),
>;
pub type PFN_vkCmdEndRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo),
>;
extern "C" {
    pub fn vkCreateRenderPass2KHR(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBeginRenderPass2KHR(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass2KHR(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRenderPass2KHR(
        commandBuffer: VkCommandBuffer,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sharedPresentSupportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSharedPresentSurfaceCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSharedPresentSurfaceCapabilitiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSharedPresentSurfaceCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSharedPresentSurfaceCapabilitiesKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSharedPresentSurfaceCapabilitiesKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSharedPresentSurfaceCapabilitiesKHR>()))
                .sharedPresentSupportedUsageFlags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
            "::",
            stringify!(sharedPresentSupportedUsageFlags)
        )
    );
}
pub type PFN_vkGetSwapchainStatusKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult,
>;
extern "C" {
    pub fn vkGetSwapchainStatusKHR(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult;
}
pub type VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
pub use self::VkExternalFenceHandleTypeFlagBits as VkExternalFenceHandleTypeFlagBitsKHR;
pub type VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
pub use self::VkExternalFenceFeatureFlagBits as VkExternalFenceFeatureFlagBitsKHR;
pub type VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
pub type VkExternalFencePropertiesKHR = VkExternalFenceProperties;
pub type PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalFencePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    );
}
pub type VkFenceImportFlagsKHR = VkFenceImportFlags;
pub use self::VkFenceImportFlagBits as VkFenceImportFlagBitsKHR;
pub type VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportFenceFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub flags: VkFenceImportFlags,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportFenceFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportFenceFdInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkImportFenceFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportFenceFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportFenceFdInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).fence as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).handleType as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImportFenceFdInfoKHR>())).fd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportFenceFdInfoKHR),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFenceGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkFenceGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkFenceGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkFenceGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFenceGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFenceGetFdInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceGetFdInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceGetFdInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceGetFdInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceGetFdInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceGetFdInfoKHR>())).fence as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceGetFdInfoKHR),
            "::",
            stringify!(fence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkFenceGetFdInfoKHR>())).handleType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFenceGetFdInfoKHR),
            "::",
            stringify!(handleType)
        )
    );
}
pub type PFN_vkImportFenceFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetFenceFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkFenceGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkImportFenceFdKHR(
        device: VkDevice,
        pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkFenceGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR:
    VkPerformanceCounterUnitKHR = 0;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR:
    VkPerformanceCounterUnitKHR = 1;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR:
    VkPerformanceCounterUnitKHR = 2;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR:
    VkPerformanceCounterUnitKHR = 3;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR:
    VkPerformanceCounterUnitKHR = 4;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR:
    VkPerformanceCounterUnitKHR = 5;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR:
    VkPerformanceCounterUnitKHR = 6;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR:
    VkPerformanceCounterUnitKHR = 7;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR:
    VkPerformanceCounterUnitKHR = 8;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR:
    VkPerformanceCounterUnitKHR = 9;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR:
    VkPerformanceCounterUnitKHR = 10;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR:
    VkPerformanceCounterUnitKHR = 0;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR:
    VkPerformanceCounterUnitKHR = 10;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR:
    VkPerformanceCounterUnitKHR = 11;
pub const VkPerformanceCounterUnitKHR_VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR:
    VkPerformanceCounterUnitKHR = 2147483647;
pub type VkPerformanceCounterUnitKHR = ::std::os::raw::c_uint;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR:
    VkPerformanceCounterScopeKHR = 0;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR:
    VkPerformanceCounterScopeKHR = 1;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR:
    VkPerformanceCounterScopeKHR = 2;
pub const VkPerformanceCounterScopeKHR_VK_QUERY_SCOPE_COMMAND_BUFFER_KHR:
    VkPerformanceCounterScopeKHR = 0;
pub const VkPerformanceCounterScopeKHR_VK_QUERY_SCOPE_RENDER_PASS_KHR:
    VkPerformanceCounterScopeKHR = 1;
pub const VkPerformanceCounterScopeKHR_VK_QUERY_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR = 2;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR:
    VkPerformanceCounterScopeKHR = 0;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR:
    VkPerformanceCounterScopeKHR = 2;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR:
    VkPerformanceCounterScopeKHR = 3;
pub const VkPerformanceCounterScopeKHR_VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR:
    VkPerformanceCounterScopeKHR = 2147483647;
pub type VkPerformanceCounterScopeKHR = ::std::os::raw::c_uint;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR:
    VkPerformanceCounterStorageKHR = 0;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR:
    VkPerformanceCounterStorageKHR = 1;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR:
    VkPerformanceCounterStorageKHR = 2;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR:
    VkPerformanceCounterStorageKHR = 3;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR:
    VkPerformanceCounterStorageKHR = 4;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR:
    VkPerformanceCounterStorageKHR = 5;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR:
    VkPerformanceCounterStorageKHR = 0;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR:
    VkPerformanceCounterStorageKHR = 5;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR:
    VkPerformanceCounterStorageKHR = 6;
pub const VkPerformanceCounterStorageKHR_VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR:
    VkPerformanceCounterStorageKHR = 2147483647;
pub type VkPerformanceCounterStorageKHR = ::std::os::raw::c_uint;
pub const VkPerformanceCounterDescriptionFlagBitsKHR_VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR : VkPerformanceCounterDescriptionFlagBitsKHR = 1 ;
pub const VkPerformanceCounterDescriptionFlagBitsKHR_VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR : VkPerformanceCounterDescriptionFlagBitsKHR = 2 ;
pub const VkPerformanceCounterDescriptionFlagBitsKHR_VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR : VkPerformanceCounterDescriptionFlagBitsKHR = 2147483647 ;
pub type VkPerformanceCounterDescriptionFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkPerformanceCounterDescriptionFlagsKHR = VkFlags;
pub const VkAcquireProfilingLockFlagBitsKHR_VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR:
    VkAcquireProfilingLockFlagBitsKHR = 2147483647;
pub type VkAcquireProfilingLockFlagBitsKHR = ::std::os::raw::c_uint;
pub type VkAcquireProfilingLockFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub performanceCounterQueryPools: VkBool32,
    pub performanceCounterMultipleQueryPools: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePerformanceQueryFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePerformanceQueryFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePerformanceQueryFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryFeaturesKHR>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryFeaturesKHR>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryFeaturesKHR>()))
                .performanceCounterQueryPools as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
            "::",
            stringify!(performanceCounterQueryPools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryFeaturesKHR>()))
                .performanceCounterMultipleQueryPools as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
            "::",
            stringify!(performanceCounterMultipleQueryPools)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub allowCommandBufferQueryCopies: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePerformanceQueryPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePerformanceQueryPropertiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePerformanceQueryPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryPropertiesKHR>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryPropertiesKHR>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePerformanceQueryPropertiesKHR>()))
                .allowCommandBufferQueryCopies as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
            "::",
            stringify!(allowCommandBufferQueryCopies)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceCounterKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub unit: VkPerformanceCounterUnitKHR,
    pub scope: VkPerformanceCounterScopeKHR,
    pub storage: VkPerformanceCounterStorageKHR,
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterKHR>(),
        48usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceCounterKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).unit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).scope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).storage as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceCounterKHR>())).uuid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterKHR),
            "::",
            stringify!(uuid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceCounterDescriptionKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPerformanceCounterDescriptionFlagsKHR,
    pub name: [::std::os::raw::c_char; 256usize],
    pub category: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterDescriptionKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterDescriptionKHR>(),
        792usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterDescriptionKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterDescriptionKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceCounterDescriptionKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).name as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).category as *const _
                as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterDescriptionKHR>())).description as *const _
                as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterDescriptionKHR),
            "::",
            stringify!(description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolPerformanceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub queueFamilyIndex: u32,
    pub counterIndexCount: u32,
    pub pCounterIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkQueryPoolPerformanceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolPerformanceCreateInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkQueryPoolPerformanceCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolPerformanceCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolPerformanceCreateInfoKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolPerformanceCreateInfoKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolPerformanceCreateInfoKHR>())).queueFamilyIndex
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR),
            "::",
            stringify!(queueFamilyIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolPerformanceCreateInfoKHR>())).counterIndexCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR),
            "::",
            stringify!(counterIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolPerformanceCreateInfoKHR>())).pCounterIndices
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR),
            "::",
            stringify!(pCounterIndices)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterResultKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterResultKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterResultKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterResultKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceCounterResultKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).int32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(int32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).int64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(int64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).uint32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(uint32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(uint64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).float32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(float32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceCounterResultKHR>())).float64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceCounterResultKHR),
            "::",
            stringify!(float64)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAcquireProfilingLockInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkAcquireProfilingLockFlagsKHR,
    pub timeout: u64,
}
#[test]
fn bindgen_test_layout_VkAcquireProfilingLockInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAcquireProfilingLockInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkAcquireProfilingLockInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAcquireProfilingLockInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAcquireProfilingLockInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireProfilingLockInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireProfilingLockInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireProfilingLockInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireProfilingLockInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireProfilingLockInfoKHR>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireProfilingLockInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAcquireProfilingLockInfoKHR>())).timeout as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAcquireProfilingLockInfoKHR),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceQuerySubmitInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub counterPassIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPerformanceQuerySubmitInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceQuerySubmitInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceQuerySubmitInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceQuerySubmitInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceQuerySubmitInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceQuerySubmitInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceQuerySubmitInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceQuerySubmitInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceQuerySubmitInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceQuerySubmitInfoKHR>())).counterPassIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceQuerySubmitInfoKHR),
            "::",
            stringify!(counterPassIndex)
        )
    );
}
pub type PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR =
    ::std::option::Option<
        unsafe extern "C" fn(
            physicalDevice: VkPhysicalDevice,
            queueFamilyIndex: u32,
            pCounterCount: *mut u32,
            pCounters: *mut VkPerformanceCounterKHR,
            pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR,
        ) -> VkResult,
    >;
pub type PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
        pNumPasses: *mut u32,
    ),
>;
pub type PFN_vkAcquireProfilingLockKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkAcquireProfilingLockInfoKHR) -> VkResult,
>;
pub type PFN_vkReleaseProfilingLockKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice)>;
extern "C" {
    pub fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        pCounterCount: *mut u32,
        pCounters: *mut VkPerformanceCounterKHR,
        pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
        physicalDevice: VkPhysicalDevice,
        pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
        pNumPasses: *mut u32,
    );
}
extern "C" {
    pub fn vkAcquireProfilingLockKHR(
        device: VkDevice,
        pInfo: *const VkAcquireProfilingLockInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkReleaseProfilingLockKHR(device: VkDevice);
}
pub use self::VkPointClippingBehavior as VkPointClippingBehaviorKHR;
pub use self::VkTessellationDomainOrigin as VkTessellationDomainOriginKHR;
pub type VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
pub type VkRenderPassInputAttachmentAspectCreateInfoKHR =
    VkRenderPassInputAttachmentAspectCreateInfo;
pub type VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
pub type VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
pub type VkPipelineTessellationDomainOriginStateCreateInfoKHR =
    VkPipelineTessellationDomainOriginStateCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surface: VkSurfaceKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSurfaceInfo2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSurfaceInfo2KHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSurfaceInfo2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSurfaceInfo2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceSurfaceInfo2KHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSurfaceInfo2KHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSurfaceInfo2KHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSurfaceInfo2KHR>())).surface as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
            "::",
            stringify!(surface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilities2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilities2KHR>(),
        72usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilities2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilities2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilities2KHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceCapabilities2KHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceCapabilities2KHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2KHR>())).surfaceCapabilities as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2KHR),
            "::",
            stringify!(surfaceCapabilities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceFormat2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceFormat: VkSurfaceFormatKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormat2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceFormat2KHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkSurfaceFormat2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceFormat2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceFormat2KHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceFormat2KHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceFormat2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceFormat2KHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceFormat2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceFormat2KHR>())).surfaceFormat as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceFormat2KHR),
            "::",
            stringify!(surfaceFormat)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormat2KHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormats2KHR(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormat2KHR,
    ) -> VkResult;
}
pub type VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub type VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayProperties: VkDisplayPropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayProperties2KHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkDisplayProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayProperties2KHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayProperties2KHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayProperties2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayProperties2KHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayProperties2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayProperties2KHR>())).displayProperties as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayProperties2KHR),
            "::",
            stringify!(displayProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayPlaneProperties: VkDisplayPlanePropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneProperties2KHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneProperties2KHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneProperties2KHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneProperties2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneProperties2KHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneProperties2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneProperties2KHR>())).displayPlaneProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneProperties2KHR),
            "::",
            stringify!(displayPlaneProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayModeProperties: VkDisplayModePropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModeProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeProperties2KHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkDisplayModeProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModeProperties2KHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeProperties2KHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeProperties2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeProperties2KHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeProperties2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayModeProperties2KHR>())).displayModeProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayModeProperties2KHR),
            "::",
            stringify!(displayModeProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub mode: VkDisplayModeKHR,
    pub planeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneInfo2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneInfo2KHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneInfo2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneInfo2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneInfo2KHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPlaneInfo2KHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneInfo2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPlaneInfo2KHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneInfo2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPlaneInfo2KHR>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneInfo2KHR),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneInfo2KHR>())).planeIndex as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneInfo2KHR),
            "::",
            stringify!(planeIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneCapabilities2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub capabilities: VkDisplayPlaneCapabilitiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneCapabilities2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneCapabilities2KHR>(),
        88usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneCapabilities2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneCapabilities2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneCapabilities2KHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilities2KHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilities2KHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilities2KHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilities2KHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPlaneCapabilities2KHR>())).capabilities as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPlaneCapabilities2KHR),
            "::",
            stringify!(capabilities)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceDisplayProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlaneProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayModeProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModeProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneCapabilities2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
        pCapabilities: *mut VkDisplayPlaneCapabilities2KHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlaneProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayModeProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModeProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneCapabilities2KHR(
        physicalDevice: VkPhysicalDevice,
        pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
        pCapabilities: *mut VkDisplayPlaneCapabilities2KHR,
    ) -> VkResult;
}
pub type VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
pub type VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
pub type VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
pub type VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
pub type VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
pub type VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
pub type PFN_vkGetImageMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
extern "C" {
    pub fn vkGetImageMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
pub type VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
pub type VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
pub use self::VkChromaLocation as VkChromaLocationKHR;
pub use self::VkSamplerYcbcrModelConversion as VkSamplerYcbcrModelConversionKHR;
pub use self::VkSamplerYcbcrRange as VkSamplerYcbcrRangeKHR;
pub type VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
pub type VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
pub type VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
pub type VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
pub type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR =
    VkPhysicalDeviceSamplerYcbcrConversionFeatures;
pub type VkSamplerYcbcrConversionImageFormatPropertiesKHR =
    VkSamplerYcbcrConversionImageFormatProperties;
pub type PFN_vkCreateSamplerYcbcrConversionKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult,
>;
pub type PFN_vkDestroySamplerYcbcrConversionKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
extern "C" {
    pub fn vkCreateSamplerYcbcrConversionKHR(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySamplerYcbcrConversionKHR(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    );
}
pub type VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
pub type VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
pub type PFN_vkBindBufferMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkBindBufferMemory2KHR(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory2KHR(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult;
}
pub type VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
pub type VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
pub type PFN_vkGetDescriptorSetLayoutSupportKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    ),
>;
extern "C" {
    pub fn vkGetDescriptorSetLayoutSupportKHR(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    );
}
pub type PFN_vkCmdDrawIndirectCountKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCountKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawIndirectCountKHR(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCountKHR(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
pub type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR =
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub type VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
pub type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderClockFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSubgroupClock: VkBool32,
    pub shaderDeviceClock: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderClockFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderClockFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderClockFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderClockFeaturesKHR>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderClockFeaturesKHR>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderClockFeaturesKHR>())).shaderSubgroupClock
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
            "::",
            stringify!(shaderSubgroupClock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderClockFeaturesKHR>())).shaderDeviceClock
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
            "::",
            stringify!(shaderDeviceClock)
        )
    );
}
pub use self::VkDriverId as VkDriverIdKHR;
pub type VkConformanceVersionKHR = VkConformanceVersion;
pub type VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
pub use self::VkShaderFloatControlsIndependence as VkShaderFloatControlsIndependenceKHR;
pub type VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
pub use self::VkResolveModeFlagBits as VkResolveModeFlagBitsKHR;
pub type VkResolveModeFlagsKHR = VkResolveModeFlags;
pub type VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
pub type VkPhysicalDeviceDepthStencilResolvePropertiesKHR =
    VkPhysicalDeviceDepthStencilResolveProperties;
pub use self::VkSemaphoreType as VkSemaphoreTypeKHR;
pub use self::VkSemaphoreWaitFlagBits as VkSemaphoreWaitFlagBitsKHR;
pub type VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;
pub type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
pub type VkPhysicalDeviceTimelineSemaphorePropertiesKHR =
    VkPhysicalDeviceTimelineSemaphoreProperties;
pub type VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
pub type VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
pub type VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
pub type VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
pub type PFN_vkGetSemaphoreCounterValueKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut u64) -> VkResult,
>;
pub type PFN_vkWaitSemaphoresKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkSignalSemaphoreKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult,
>;
extern "C" {
    pub fn vkGetSemaphoreCounterValueKHR(
        device: VkDevice,
        semaphore: VkSemaphore,
        pValue: *mut u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWaitSemaphoresKHR(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSignalSemaphoreKHR(
        device: VkDevice,
        pSignalInfo: *const VkSemaphoreSignalInfo,
    ) -> VkResult;
}
pub type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceProtectedCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub supportsProtected: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSurfaceProtectedCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceProtectedCapabilitiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkSurfaceProtectedCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceProtectedCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSurfaceProtectedCapabilitiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceProtectedCapabilitiesKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceProtectedCapabilitiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceProtectedCapabilitiesKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceProtectedCapabilitiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceProtectedCapabilitiesKHR>())).supportsProtected
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceProtectedCapabilitiesKHR),
            "::",
            stringify!(supportsProtected)
        )
    );
}
pub type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR =
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub type VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
pub type VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
pub type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR =
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
pub type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR =
    VkPhysicalDeviceBufferDeviceAddressFeatures;
pub type VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
pub type VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
pub type VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
pub type VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
pub type PFN_vkGetBufferDeviceAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
pub type PFN_vkGetBufferOpaqueCaptureAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64,
>;
pub type PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64,
>;
extern "C" {
    pub fn vkGetBufferDeviceAddressKHR(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
extern "C" {
    pub fn vkGetBufferOpaqueCaptureAddressKHR(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> u64;
}
extern "C" {
    pub fn vkGetDeviceMemoryOpaqueCaptureAddressKHR(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64;
}
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR : VkPipelineExecutableStatisticFormatKHR = 0 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR : VkPipelineExecutableStatisticFormatKHR = 1 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR : VkPipelineExecutableStatisticFormatKHR = 2 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR : VkPipelineExecutableStatisticFormatKHR = 3 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR : VkPipelineExecutableStatisticFormatKHR = 0 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR : VkPipelineExecutableStatisticFormatKHR = 3 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR : VkPipelineExecutableStatisticFormatKHR = 4 ;
pub const VkPipelineExecutableStatisticFormatKHR_VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR : VkPipelineExecutableStatisticFormatKHR = 2147483647 ;
pub type VkPipelineExecutableStatisticFormatKHR = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineExecutableInfo: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>()))
                .sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>()))
                .pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>()))
                .pipelineExecutableInfo as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
            "::",
            stringify!(pipelineExecutableInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipeline: VkPipeline,
}
#[test]
fn bindgen_test_layout_VkPipelineInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPipelineInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPipelineInfoKHR>())).pipeline as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineInfoKHR),
            "::",
            stringify!(pipeline)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutablePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stages: VkShaderStageFlags,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub subgroupSize: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutablePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutablePropertiesKHR>(),
        536usize,
        concat!("Size of: ", stringify!(VkPipelineExecutablePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutablePropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutablePropertiesKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).stages as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(stages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).name as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).description as *const _
                as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutablePropertiesKHR>())).subgroupSize as *const _
                as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutablePropertiesKHR),
            "::",
            stringify!(subgroupSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineExecutableInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipeline: VkPipeline,
    pub executableIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineExecutableInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineExecutableInfoKHR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInfoKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInfoKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInfoKHR>())).pipeline as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInfoKHR),
            "::",
            stringify!(pipeline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInfoKHR>())).executableIndex as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInfoKHR),
            "::",
            stringify!(executableIndex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPipelineExecutableStatisticValueKHR {
    pub b32: VkBool32,
    pub i64_: i64,
    pub u64_: u64,
    pub f64_: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableStatisticValueKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableStatisticValueKHR>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineExecutableStatisticValueKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableStatisticValueKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableStatisticValueKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticValueKHR>())).b32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticValueKHR),
            "::",
            stringify!(b32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticValueKHR>())).i64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticValueKHR),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticValueKHR>())).u64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticValueKHR),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticValueKHR>())).f64_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticValueKHR),
            "::",
            stringify!(f64_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableStatisticKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub format: VkPipelineExecutableStatisticFormatKHR,
    pub value: VkPipelineExecutableStatisticValueKHR,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableStatisticKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableStatisticKHR>(),
        544usize,
        concat!("Size of: ", stringify!(VkPipelineExecutableStatisticKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableStatisticKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableStatisticKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).description as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).format as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableStatisticKHR>())).value as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableStatisticKHR),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableInternalRepresentationKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub isText: VkBool32,
    pub dataSize: size_t,
    pub pData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableInternalRepresentationKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableInternalRepresentationKHR>(),
        552usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableInternalRepresentationKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).name
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).description
                as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).isText
                as *const _ as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(isText)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).dataSize
                as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineExecutableInternalRepresentationKHR>())).pData
                as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR),
            "::",
            stringify!(pData)
        )
    );
}
pub type PFN_vkGetPipelineExecutablePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoKHR,
        pExecutableCount: *mut u32,
        pProperties: *mut VkPipelineExecutablePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPipelineExecutableStatisticsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pStatisticCount: *mut u32,
        pStatistics: *mut VkPipelineExecutableStatisticKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPipelineExecutableInternalRepresentationsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pInternalRepresentationCount: *mut u32,
        pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPipelineExecutablePropertiesKHR(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoKHR,
        pExecutableCount: *mut u32,
        pProperties: *mut VkPipelineExecutablePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPipelineExecutableStatisticsKHR(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pStatisticCount: *mut u32,
        pStatistics: *mut VkPipelineExecutableStatisticKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPipelineExecutableInternalRepresentationsKHR(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pInternalRepresentationCount: *mut u32,
        pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugReportCallbackEXT_T {
    _unused: [u8; 0],
}
pub type VkDebugReportCallbackEXT = *mut VkDebugReportCallbackEXT_T;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
    VkDebugReportObjectTypeEXT = 0;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
    VkDebugReportObjectTypeEXT = 1;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
    VkDebugReportObjectTypeEXT = 2;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
    VkDebugReportObjectTypeEXT = 3;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
    VkDebugReportObjectTypeEXT = 4;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
    VkDebugReportObjectTypeEXT = 5;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
    VkDebugReportObjectTypeEXT = 6;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
    VkDebugReportObjectTypeEXT = 7;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
    VkDebugReportObjectTypeEXT = 8;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
    VkDebugReportObjectTypeEXT = 9;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
    VkDebugReportObjectTypeEXT = 10;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
    VkDebugReportObjectTypeEXT = 11;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
    VkDebugReportObjectTypeEXT = 12;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
    VkDebugReportObjectTypeEXT = 13;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
    VkDebugReportObjectTypeEXT = 14;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
    VkDebugReportObjectTypeEXT = 15;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
    VkDebugReportObjectTypeEXT = 16;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
    VkDebugReportObjectTypeEXT = 17;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
    VkDebugReportObjectTypeEXT = 18;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
    VkDebugReportObjectTypeEXT = 19;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
    VkDebugReportObjectTypeEXT = 20;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
    VkDebugReportObjectTypeEXT = 21;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
    VkDebugReportObjectTypeEXT = 22;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
    VkDebugReportObjectTypeEXT = 23;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
    VkDebugReportObjectTypeEXT = 24;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
    VkDebugReportObjectTypeEXT = 25;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
    VkDebugReportObjectTypeEXT = 26;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
    VkDebugReportObjectTypeEXT = 27;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:
    VkDebugReportObjectTypeEXT = 28;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:
    VkDebugReportObjectTypeEXT = 29;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:
    VkDebugReportObjectTypeEXT = 30;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT:
    VkDebugReportObjectTypeEXT = 31;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT : VkDebugReportObjectTypeEXT = 32 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT:
    VkDebugReportObjectTypeEXT = 33;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT:
    VkDebugReportObjectTypeEXT = 1000156000;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT:
    VkDebugReportObjectTypeEXT = 1000085000;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT:
    VkDebugReportObjectTypeEXT = 1000165000;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT:
    VkDebugReportObjectTypeEXT = 28;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT:
    VkDebugReportObjectTypeEXT = 33;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT : VkDebugReportObjectTypeEXT = 1000085000 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT : VkDebugReportObjectTypeEXT = 1000156000 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT:
    VkDebugReportObjectTypeEXT = 0;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT:
    VkDebugReportObjectTypeEXT = 33;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT:
    VkDebugReportObjectTypeEXT = 34;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT:
    VkDebugReportObjectTypeEXT = 2147483647;
pub type VkDebugReportObjectTypeEXT = ::std::os::raw::c_uint;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_INFORMATION_BIT_EXT: VkDebugReportFlagBitsEXT =
    1;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT = 2;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT:
    VkDebugReportFlagBitsEXT = 4;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_ERROR_BIT_EXT: VkDebugReportFlagBitsEXT = 8;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_DEBUG_BIT_EXT: VkDebugReportFlagBitsEXT = 16;
pub const VkDebugReportFlagBitsEXT_VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT:
    VkDebugReportFlagBitsEXT = 2147483647;
pub type VkDebugReportFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkDebugReportFlagsEXT = VkFlags;
pub type PFN_vkDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: size_t,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> VkBool32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugReportCallbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugReportFlagsEXT,
    pub pfnCallback: PFN_vkDebugReportCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugReportCallbackCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugReportCallbackCreateInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugReportCallbackCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugReportCallbackCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugReportCallbackCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugReportCallbackCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugReportCallbackCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugReportCallbackCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugReportCallbackCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugReportCallbackCreateInfoEXT>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugReportCallbackCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugReportCallbackCreateInfoEXT>())).pfnCallback as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugReportCallbackCreateInfoEXT),
            "::",
            stringify!(pfnCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugReportCallbackCreateInfoEXT>())).pUserData as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugReportCallbackCreateInfoEXT),
            "::",
            stringify!(pUserData)
        )
    );
}
pub type PFN_vkCreateDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkDebugReportMessageEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: size_t,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn vkCreateDebugReportCallbackEXT(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDebugReportCallbackEXT(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkDebugReportMessageEXT(
        instance: VkInstance,
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: size_t,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
    );
}
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_STRICT_AMD: VkRasterizationOrderAMD = 0;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_RELAXED_AMD: VkRasterizationOrderAMD = 1;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD: VkRasterizationOrderAMD =
    0;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_END_RANGE_AMD: VkRasterizationOrderAMD = 1;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD: VkRasterizationOrderAMD =
    2;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_MAX_ENUM_AMD: VkRasterizationOrderAMD =
    2147483647;
pub type VkRasterizationOrderAMD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub rasterizationOrder: VkRasterizationOrderAMD,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateRasterizationOrderAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateRasterizationOrderAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateRasterizationOrderAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateRasterizationOrderAMD>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateRasterizationOrderAMD>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateRasterizationOrderAMD>()))
                .rasterizationOrder as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
            "::",
            stringify!(rasterizationOrder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerObjectNameInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub pObjectName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectNameInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerObjectNameInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugMarkerObjectNameInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerObjectNameInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerObjectNameInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectNameInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectNameInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectNameInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectNameInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectNameInfoEXT>())).objectType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectNameInfoEXT),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectNameInfoEXT>())).object as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectNameInfoEXT),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectNameInfoEXT>())).pObjectName as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectNameInfoEXT),
            "::",
            stringify!(pObjectName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerObjectTagInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub tagName: u64,
    pub tagSize: size_t,
    pub pTag: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectTagInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerObjectTagInfoEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkDebugMarkerObjectTagInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerObjectTagInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerObjectTagInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).objectType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).object as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).tagName as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(tagName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).tagSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(tagSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerObjectTagInfoEXT>())).pTag as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerObjectTagInfoEXT),
            "::",
            stringify!(pTag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerMarkerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pMarkerName: *const ::std::os::raw::c_char,
    pub color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkDebugMarkerMarkerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerMarkerInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugMarkerMarkerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerMarkerInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerMarkerInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerMarkerInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerMarkerInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerMarkerInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerMarkerInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerMarkerInfoEXT>())).pMarkerName as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerMarkerInfoEXT),
            "::",
            stringify!(pMarkerName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugMarkerMarkerInfoEXT>())).color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugMarkerMarkerInfoEXT),
            "::",
            stringify!(color)
        )
    );
}
pub type PFN_vkDebugMarkerSetObjectTagEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkDebugMarkerSetObjectNameEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkCmdDebugMarkerBeginEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    ),
>;
pub type PFN_vkCmdDebugMarkerEndEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdDebugMarkerInsertEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    ),
>;
extern "C" {
    pub fn vkDebugMarkerSetObjectTagEXT(
        device: VkDevice,
        pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDebugMarkerSetObjectNameEXT(
        device: VkDevice,
        pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdDebugMarkerBeginEXT(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdDebugMarkerEndEXT(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdDebugMarkerInsertEXT(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationImageCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationImageCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationImageCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationImageCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationImageCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationImageCreateInfoNV>())).dedicatedAllocation
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV),
            "::",
            stringify!(dedicatedAllocation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationBufferCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationBufferCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationBufferCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationBufferCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationBufferCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationBufferCreateInfoNV>())).dedicatedAllocation
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV),
            "::",
            stringify!(dedicatedAllocation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationMemoryAllocateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationMemoryAllocateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationMemoryAllocateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationMemoryAllocateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationMemoryAllocateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationMemoryAllocateInfoNV>())).image as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDedicatedAllocationMemoryAllocateInfoNV>())).buffer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
            "::",
            stringify!(buffer)
        )
    );
}
pub type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub transformFeedback: VkBool32,
    pub geometryStreams: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTransformFeedbackFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>()))
                .transformFeedback as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
            "::",
            stringify!(transformFeedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>())).geometryStreams
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
            "::",
            stringify!(geometryStreams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxTransformFeedbackStreams: u32,
    pub maxTransformFeedbackBuffers: u32,
    pub maxTransformFeedbackBufferSize: VkDeviceSize,
    pub maxTransformFeedbackStreamDataSize: u32,
    pub maxTransformFeedbackBufferDataSize: u32,
    pub maxTransformFeedbackBufferDataStride: u32,
    pub transformFeedbackQueries: VkBool32,
    pub transformFeedbackStreamsLinesTriangles: VkBool32,
    pub transformFeedbackRasterizationStreamSelect: VkBool32,
    pub transformFeedbackDraw: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTransformFeedbackPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackStreams as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackStreams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackBuffers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackBuffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackBufferSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackStreamDataSize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackStreamDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackBufferDataSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackBufferDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .maxTransformFeedbackBufferDataStride as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(maxTransformFeedbackBufferDataStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .transformFeedbackQueries as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(transformFeedbackQueries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .transformFeedbackStreamsLinesTriangles as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(transformFeedbackStreamsLinesTriangles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .transformFeedbackRasterizationStreamSelect as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(transformFeedbackRasterizationStreamSelect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>()))
                .transformFeedbackDraw as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
            "::",
            stringify!(transformFeedbackDraw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateStreamCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterizationStream: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateStreamCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateStreamCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateStreamCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateStreamCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateStreamCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateStreamCreateInfoEXT>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationStateStreamCreateInfoEXT>()))
                .rasterizationStream as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
            "::",
            stringify!(rasterizationStream)
        )
    );
}
pub type PFN_vkCmdBindTransformFeedbackBuffersEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdBeginTransformFeedbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdEndTransformFeedbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdBeginQueryIndexedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
        index: u32,
    ),
>;
pub type PFN_vkCmdEndQueryIndexedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        index: u32,
    ),
>;
pub type PFN_vkCmdDrawIndirectByteCountEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        instanceCount: u32,
        firstInstance: u32,
        counterBuffer: VkBuffer,
        counterBufferOffset: VkDeviceSize,
        counterOffset: u32,
        vertexStride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdBindTransformFeedbackBuffersEXT(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdBeginTransformFeedbackEXT(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdEndTransformFeedbackEXT(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdBeginQueryIndexedEXT(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
        index: u32,
    );
}
extern "C" {
    pub fn vkCmdEndQueryIndexedEXT(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        index: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndirectByteCountEXT(
        commandBuffer: VkCommandBuffer,
        instanceCount: u32,
        firstInstance: u32,
        counterBuffer: VkBuffer,
        counterBufferOffset: VkDeviceSize,
        counterOffset: u32,
        vertexStride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewHandleInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
    pub descriptorType: VkDescriptorType,
    pub sampler: VkSampler,
}
#[test]
fn bindgen_test_layout_VkImageViewHandleInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewHandleInfoNVX>(),
        40usize,
        concat!("Size of: ", stringify!(VkImageViewHandleInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewHandleInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewHandleInfoNVX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewHandleInfoNVX>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewHandleInfoNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkImageViewHandleInfoNVX>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewHandleInfoNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewHandleInfoNVX>())).imageView as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewHandleInfoNVX),
            "::",
            stringify!(imageView)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewHandleInfoNVX>())).descriptorType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewHandleInfoNVX),
            "::",
            stringify!(descriptorType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewHandleInfoNVX>())).sampler as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewHandleInfoNVX),
            "::",
            stringify!(sampler)
        )
    );
}
pub type PFN_vkGetImageViewHandleNVX = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32,
>;
extern "C" {
    pub fn vkGetImageViewHandleNVX(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX)
        -> u32;
}
pub type PFN_vkCmdDrawIndirectCountAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCountAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawIndirectCountAMD(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCountAMD(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkTextureLODGatherFormatPropertiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportsTextureGatherLODBiasAMD: VkBool32,
}
#[test]
fn bindgen_test_layout_VkTextureLODGatherFormatPropertiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkTextureLODGatherFormatPropertiesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkTextureLODGatherFormatPropertiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTextureLODGatherFormatPropertiesAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTextureLODGatherFormatPropertiesAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkTextureLODGatherFormatPropertiesAMD>()))
                .supportsTextureGatherLODBiasAMD as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD),
            "::",
            stringify!(supportsTextureGatherLODBiasAMD)
        )
    );
}
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_STATISTICS_AMD: VkShaderInfoTypeAMD = 0;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_BINARY_AMD: VkShaderInfoTypeAMD = 1;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD: VkShaderInfoTypeAMD = 2;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD: VkShaderInfoTypeAMD = 0;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_END_RANGE_AMD: VkShaderInfoTypeAMD = 2;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD: VkShaderInfoTypeAMD = 3;
pub const VkShaderInfoTypeAMD_VK_SHADER_INFO_TYPE_MAX_ENUM_AMD: VkShaderInfoTypeAMD = 2147483647;
pub type VkShaderInfoTypeAMD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderResourceUsageAMD {
    pub numUsedVgprs: u32,
    pub numUsedSgprs: u32,
    pub ldsSizePerLocalWorkGroup: u32,
    pub ldsUsageSizeInBytes: size_t,
    pub scratchMemUsageInBytes: size_t,
}
#[test]
fn bindgen_test_layout_VkShaderResourceUsageAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderResourceUsageAMD>(),
        32usize,
        concat!("Size of: ", stringify!(VkShaderResourceUsageAMD))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderResourceUsageAMD>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderResourceUsageAMD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderResourceUsageAMD>())).numUsedVgprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderResourceUsageAMD),
            "::",
            stringify!(numUsedVgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderResourceUsageAMD>())).numUsedSgprs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderResourceUsageAMD),
            "::",
            stringify!(numUsedSgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderResourceUsageAMD>())).ldsSizePerLocalWorkGroup
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderResourceUsageAMD),
            "::",
            stringify!(ldsSizePerLocalWorkGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderResourceUsageAMD>())).ldsUsageSizeInBytes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderResourceUsageAMD),
            "::",
            stringify!(ldsUsageSizeInBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderResourceUsageAMD>())).scratchMemUsageInBytes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderResourceUsageAMD),
            "::",
            stringify!(scratchMemUsageInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderStatisticsInfoAMD {
    pub shaderStageMask: VkShaderStageFlags,
    pub resourceUsage: VkShaderResourceUsageAMD,
    pub numPhysicalVgprs: u32,
    pub numPhysicalSgprs: u32,
    pub numAvailableVgprs: u32,
    pub numAvailableSgprs: u32,
    pub computeWorkGroupSize: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_VkShaderStatisticsInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderStatisticsInfoAMD>(),
        72usize,
        concat!("Size of: ", stringify!(VkShaderStatisticsInfoAMD))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderStatisticsInfoAMD>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderStatisticsInfoAMD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).shaderStageMask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(shaderStageMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).resourceUsage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(resourceUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).numPhysicalVgprs as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(numPhysicalVgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).numPhysicalSgprs as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(numPhysicalSgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).numAvailableVgprs as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(numAvailableVgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).numAvailableSgprs as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(numAvailableSgprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderStatisticsInfoAMD>())).computeWorkGroupSize as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderStatisticsInfoAMD),
            "::",
            stringify!(computeWorkGroupSize)
        )
    );
}
pub type PFN_vkGetShaderInfoAMD = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        shaderStage: VkShaderStageFlagBits,
        infoType: VkShaderInfoTypeAMD,
        pInfoSize: *mut size_t,
        pInfo: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetShaderInfoAMD(
        device: VkDevice,
        pipeline: VkPipeline,
        shaderStage: VkShaderStageFlagBits,
        infoType: VkShaderInfoTypeAMD,
        pInfoSize: *mut size_t,
        pInfo: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cornerSampledImage: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCornerSampledImageFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCornerSampledImageFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCornerSampledImageFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCornerSampledImageFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCornerSampledImageFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCornerSampledImageFeaturesNV>()))
                .cornerSampledImage as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
            "::",
            stringify!(cornerSampledImage)
        )
    );
}
pub const VkExternalMemoryHandleTypeFlagBitsNV_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV : VkExternalMemoryHandleTypeFlagBitsNV = 1 ;
pub const VkExternalMemoryHandleTypeFlagBitsNV_VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV : VkExternalMemoryHandleTypeFlagBitsNV = 2 ;
pub const VkExternalMemoryHandleTypeFlagBitsNV_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV:
    VkExternalMemoryHandleTypeFlagBitsNV = 4;
pub const VkExternalMemoryHandleTypeFlagBitsNV_VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV : VkExternalMemoryHandleTypeFlagBitsNV = 8 ;
pub const VkExternalMemoryHandleTypeFlagBitsNV_VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV : VkExternalMemoryHandleTypeFlagBitsNV = 2147483647 ;
pub type VkExternalMemoryHandleTypeFlagBitsNV = ::std::os::raw::c_uint;
pub type VkExternalMemoryHandleTypeFlagsNV = VkFlags;
pub const VkExternalMemoryFeatureFlagBitsNV_VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV:
    VkExternalMemoryFeatureFlagBitsNV = 1;
pub const VkExternalMemoryFeatureFlagBitsNV_VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV:
    VkExternalMemoryFeatureFlagBitsNV = 2;
pub const VkExternalMemoryFeatureFlagBitsNV_VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV:
    VkExternalMemoryFeatureFlagBitsNV = 4;
pub const VkExternalMemoryFeatureFlagBitsNV_VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV:
    VkExternalMemoryFeatureFlagBitsNV = 2147483647;
pub type VkExternalMemoryFeatureFlagBitsNV = ::std::os::raw::c_uint;
pub type VkExternalMemoryFeatureFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalImageFormatPropertiesNV {
    pub imageFormatProperties: VkImageFormatProperties,
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalImageFormatPropertiesNV>(),
        48usize,
        concat!("Size of: ", stringify!(VkExternalImageFormatPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalImageFormatPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalImageFormatPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatPropertiesNV>())).imageFormatProperties
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatPropertiesNV),
            "::",
            stringify!(imageFormatProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatPropertiesNV>())).externalMemoryFeatures
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatPropertiesNV),
            "::",
            stringify!(externalMemoryFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatPropertiesNV>()))
                .exportFromImportedHandleTypes as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatPropertiesNV),
            "::",
            stringify!(exportFromImportedHandleTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalImageFormatPropertiesNV>())).compatibleHandleTypes
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalImageFormatPropertiesNV),
            "::",
            stringify!(compatibleHandleTypes)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        externalHandleType: VkExternalMemoryHandleTypeFlagsNV,
        pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        externalHandleType: VkExternalMemoryHandleTypeFlagsNV,
        pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryImageCreateInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryImageCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryImageCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalMemoryImageCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfoNV>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfoNV>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExternalMemoryImageCreateInfoNV>())).handleTypes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExternalMemoryImageCreateInfoNV),
            "::",
            stringify!(handleTypes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExportMemoryAllocateInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportMemoryAllocateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportMemoryAllocateInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportMemoryAllocateInfoNV))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfoNV>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfoNV>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkExportMemoryAllocateInfoNV>())).handleTypes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkExportMemoryAllocateInfoNV),
            "::",
            stringify!(handleTypes)
        )
    );
}
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_ALL_EXT: VkValidationCheckEXT = 0;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_SHADERS_EXT: VkValidationCheckEXT = 1;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_BEGIN_RANGE_EXT: VkValidationCheckEXT = 0;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_END_RANGE_EXT: VkValidationCheckEXT = 1;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_RANGE_SIZE_EXT: VkValidationCheckEXT = 2;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_MAX_ENUM_EXT: VkValidationCheckEXT = 2147483647;
pub type VkValidationCheckEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationFlagsEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub disabledValidationCheckCount: u32,
    pub pDisabledValidationChecks: *const VkValidationCheckEXT,
}
#[test]
fn bindgen_test_layout_VkValidationFlagsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationFlagsEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkValidationFlagsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationFlagsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationFlagsEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkValidationFlagsEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFlagsEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkValidationFlagsEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFlagsEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFlagsEXT>())).disabledValidationCheckCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFlagsEXT),
            "::",
            stringify!(disabledValidationCheckCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFlagsEXT>())).pDisabledValidationChecks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFlagsEXT),
            "::",
            stringify!(pDisabledValidationChecks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub textureCompressionASTC_HDR: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>()))
                .textureCompressionASTC_HDR as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT),
            "::",
            stringify!(textureCompressionASTC_HDR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewASTCDecodeModeEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub decodeMode: VkFormat,
}
#[test]
fn bindgen_test_layout_VkImageViewASTCDecodeModeEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewASTCDecodeModeEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageViewASTCDecodeModeEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewASTCDecodeModeEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewASTCDecodeModeEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewASTCDecodeModeEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewASTCDecodeModeEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewASTCDecodeModeEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewASTCDecodeModeEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageViewASTCDecodeModeEXT>())).decodeMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageViewASTCDecodeModeEXT),
            "::",
            stringify!(decodeMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub decodeModeSharedExponent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceASTCDecodeFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceASTCDecodeFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceASTCDecodeFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceASTCDecodeFeaturesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceASTCDecodeFeaturesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceASTCDecodeFeaturesEXT>()))
                .decodeModeSharedExponent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
            "::",
            stringify!(decodeModeSharedExponent)
        )
    );
}
pub const VkConditionalRenderingFlagBitsEXT_VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT:
    VkConditionalRenderingFlagBitsEXT = 1;
pub const VkConditionalRenderingFlagBitsEXT_VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT:
    VkConditionalRenderingFlagBitsEXT = 2147483647;
pub type VkConditionalRenderingFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkConditionalRenderingFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkConditionalRenderingBeginInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub flags: VkConditionalRenderingFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkConditionalRenderingBeginInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkConditionalRenderingBeginInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkConditionalRenderingBeginInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkConditionalRenderingBeginInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkConditionalRenderingBeginInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkConditionalRenderingBeginInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConditionalRenderingBeginInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkConditionalRenderingBeginInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConditionalRenderingBeginInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkConditionalRenderingBeginInfoEXT>())).buffer as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConditionalRenderingBeginInfoEXT),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkConditionalRenderingBeginInfoEXT>())).offset as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConditionalRenderingBeginInfoEXT),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkConditionalRenderingBeginInfoEXT>())).flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkConditionalRenderingBeginInfoEXT),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub conditionalRendering: VkBool32,
    pub inheritedConditionalRendering: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceConditionalRenderingFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>()))
                .conditionalRendering as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
            "::",
            stringify!(conditionalRendering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>()))
                .inheritedConditionalRendering as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
            "::",
            stringify!(inheritedConditionalRendering)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub conditionalRenderingEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceConditionalRenderingInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>()))
                .conditionalRenderingEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
            "::",
            stringify!(conditionalRenderingEnable)
        )
    );
}
pub type PFN_vkCmdBeginConditionalRenderingEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
    ),
>;
pub type PFN_vkCmdEndConditionalRenderingEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
extern "C" {
    pub fn vkCmdBeginConditionalRenderingEXT(
        commandBuffer: VkCommandBuffer,
        pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdEndConditionalRenderingEXT(commandBuffer: VkCommandBuffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableNVX_T {
    _unused: [u8; 0],
}
pub type VkObjectTableNVX = *mut VkObjectTableNVX_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutNVX_T {
    _unused: [u8; 0],
}
pub type VkIndirectCommandsLayoutNVX = *mut VkIndirectCommandsLayoutNVX_T;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX:
    VkIndirectCommandsTokenTypeNVX = 0;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX:
    VkIndirectCommandsTokenTypeNVX = 1;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX:
    VkIndirectCommandsTokenTypeNVX = 2;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX:
    VkIndirectCommandsTokenTypeNVX = 3;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX:
    VkIndirectCommandsTokenTypeNVX = 4;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX:
    VkIndirectCommandsTokenTypeNVX = 5;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX:
    VkIndirectCommandsTokenTypeNVX = 6;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX:
    VkIndirectCommandsTokenTypeNVX = 7;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX:
    VkIndirectCommandsTokenTypeNVX = 0;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX:
    VkIndirectCommandsTokenTypeNVX = 7;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX:
    VkIndirectCommandsTokenTypeNVX = 8;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX:
    VkIndirectCommandsTokenTypeNVX = 2147483647;
pub type VkIndirectCommandsTokenTypeNVX = ::std::os::raw::c_uint;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX: VkObjectEntryTypeNVX = 0;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX: VkObjectEntryTypeNVX = 1;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX: VkObjectEntryTypeNVX = 2;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX: VkObjectEntryTypeNVX = 3;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX: VkObjectEntryTypeNVX = 4;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX: VkObjectEntryTypeNVX = 0;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX: VkObjectEntryTypeNVX = 4;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX: VkObjectEntryTypeNVX = 5;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX: VkObjectEntryTypeNVX = 2147483647;
pub type VkObjectEntryTypeNVX = ::std::os::raw::c_uint;
pub const VkIndirectCommandsLayoutUsageFlagBitsNVX_VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX : VkIndirectCommandsLayoutUsageFlagBitsNVX = 1 ;
pub const VkIndirectCommandsLayoutUsageFlagBitsNVX_VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX : VkIndirectCommandsLayoutUsageFlagBitsNVX = 2 ;
pub const VkIndirectCommandsLayoutUsageFlagBitsNVX_VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX : VkIndirectCommandsLayoutUsageFlagBitsNVX = 4 ;
pub const VkIndirectCommandsLayoutUsageFlagBitsNVX_VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX : VkIndirectCommandsLayoutUsageFlagBitsNVX = 8 ;
pub const VkIndirectCommandsLayoutUsageFlagBitsNVX_VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX : VkIndirectCommandsLayoutUsageFlagBitsNVX = 2147483647 ;
pub type VkIndirectCommandsLayoutUsageFlagBitsNVX = ::std::os::raw::c_uint;
pub type VkIndirectCommandsLayoutUsageFlagsNVX = VkFlags;
pub const VkObjectEntryUsageFlagBitsNVX_VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX:
    VkObjectEntryUsageFlagBitsNVX = 1;
pub const VkObjectEntryUsageFlagBitsNVX_VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX:
    VkObjectEntryUsageFlagBitsNVX = 2;
pub const VkObjectEntryUsageFlagBitsNVX_VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX:
    VkObjectEntryUsageFlagBitsNVX = 2147483647;
pub type VkObjectEntryUsageFlagBitsNVX = ::std::os::raw::c_uint;
pub type VkObjectEntryUsageFlagsNVX = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGeneratedCommandsFeaturesNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub computeBindingPointSupport: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDeviceGeneratedCommandsFeaturesNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGeneratedCommandsFeaturesNVX>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceGeneratedCommandsFeaturesNVX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGeneratedCommandsFeaturesNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGeneratedCommandsFeaturesNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsFeaturesNVX>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsFeaturesNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsFeaturesNVX>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsFeaturesNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsFeaturesNVX>()))
                .computeBindingPointSupport as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsFeaturesNVX),
            "::",
            stringify!(computeBindingPointSupport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGeneratedCommandsLimitsNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxIndirectCommandsLayoutTokenCount: u32,
    pub maxObjectEntryCounts: u32,
    pub minSequenceCountBufferOffsetAlignment: u32,
    pub minSequenceIndexBufferOffsetAlignment: u32,
    pub minCommandsTokenBufferOffsetAlignment: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGeneratedCommandsLimitsNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGeneratedCommandsLimitsNVX>(),
        40usize,
        concat!("Size of: ", stringify!(VkDeviceGeneratedCommandsLimitsNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGeneratedCommandsLimitsNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>()))
                .maxIndirectCommandsLayoutTokenCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(maxIndirectCommandsLayoutTokenCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>())).maxObjectEntryCounts
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(maxObjectEntryCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>()))
                .minSequenceCountBufferOffsetAlignment as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(minSequenceCountBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>()))
                .minSequenceIndexBufferOffsetAlignment as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(minSequenceIndexBufferOffsetAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceGeneratedCommandsLimitsNVX>()))
                .minCommandsTokenBufferOffsetAlignment as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceGeneratedCommandsLimitsNVX),
            "::",
            stringify!(minCommandsTokenBufferOffsetAlignment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsTokenNVX {
    pub tokenType: VkIndirectCommandsTokenTypeNVX,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsTokenNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsTokenNVX>(),
        24usize,
        concat!("Size of: ", stringify!(VkIndirectCommandsTokenNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsTokenNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkIndirectCommandsTokenNVX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsTokenNVX>())).tokenType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsTokenNVX),
            "::",
            stringify!(tokenType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsTokenNVX>())).buffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsTokenNVX),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsTokenNVX>())).offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsTokenNVX),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutTokenNVX {
    pub tokenType: VkIndirectCommandsTokenTypeNVX,
    pub bindingUnit: u32,
    pub dynamicCount: u32,
    pub divisor: u32,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutTokenNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsLayoutTokenNVX>(),
        16usize,
        concat!("Size of: ", stringify!(VkIndirectCommandsLayoutTokenNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsLayoutTokenNVX>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkIndirectCommandsLayoutTokenNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutTokenNVX>())).tokenType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutTokenNVX),
            "::",
            stringify!(tokenType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutTokenNVX>())).bindingUnit as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutTokenNVX),
            "::",
            stringify!(bindingUnit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutTokenNVX>())).dynamicCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutTokenNVX),
            "::",
            stringify!(dynamicCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutTokenNVX>())).divisor as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutTokenNVX),
            "::",
            stringify!(divisor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub flags: VkIndirectCommandsLayoutUsageFlagsNVX,
    pub tokenCount: u32,
    pub pTokens: *const VkIndirectCommandsLayoutTokenNVX,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutCreateInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsLayoutCreateInfoNVX>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsLayoutCreateInfoNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).pipelineBindPoint
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(pipelineBindPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).flags as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).tokenCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(tokenCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkIndirectCommandsLayoutCreateInfoNVX>())).pTokens as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNVX),
            "::",
            stringify!(pTokens)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCmdProcessCommandsInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectTable: VkObjectTableNVX,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    pub indirectCommandsTokenCount: u32,
    pub pIndirectCommandsTokens: *const VkIndirectCommandsTokenNVX,
    pub maxSequencesCount: u32,
    pub targetCommandBuffer: VkCommandBuffer,
    pub sequencesCountBuffer: VkBuffer,
    pub sequencesCountOffset: VkDeviceSize,
    pub sequencesIndexBuffer: VkBuffer,
    pub sequencesIndexOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkCmdProcessCommandsInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkCmdProcessCommandsInfoNVX>(),
        96usize,
        concat!("Size of: ", stringify!(VkCmdProcessCommandsInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCmdProcessCommandsInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCmdProcessCommandsInfoNVX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).objectTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(objectTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).indirectCommandsLayout
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(indirectCommandsLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).indirectCommandsTokenCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(indirectCommandsTokenCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).pIndirectCommandsTokens
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(pIndirectCommandsTokens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).maxSequencesCount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(maxSequencesCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).targetCommandBuffer as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(targetCommandBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).sequencesCountBuffer as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(sequencesCountBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).sequencesCountOffset as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(sequencesCountOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).sequencesIndexBuffer as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(sequencesIndexBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdProcessCommandsInfoNVX>())).sequencesIndexOffset as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdProcessCommandsInfoNVX),
            "::",
            stringify!(sequencesIndexOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCmdReserveSpaceForCommandsInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectTable: VkObjectTableNVX,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    pub maxSequencesCount: u32,
}
#[test]
fn bindgen_test_layout_VkCmdReserveSpaceForCommandsInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkCmdReserveSpaceForCommandsInfoNVX>(),
        40usize,
        concat!("Size of: ", stringify!(VkCmdReserveSpaceForCommandsInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCmdReserveSpaceForCommandsInfoNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdReserveSpaceForCommandsInfoNVX>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdReserveSpaceForCommandsInfoNVX>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdReserveSpaceForCommandsInfoNVX>())).objectTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX),
            "::",
            stringify!(objectTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdReserveSpaceForCommandsInfoNVX>())).indirectCommandsLayout
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX),
            "::",
            stringify!(indirectCommandsLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCmdReserveSpaceForCommandsInfoNVX>())).maxSequencesCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCmdReserveSpaceForCommandsInfoNVX),
            "::",
            stringify!(maxSequencesCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectCount: u32,
    pub pObjectEntryTypes: *const VkObjectEntryTypeNVX,
    pub pObjectEntryCounts: *const u32,
    pub pObjectEntryUsageFlags: *const VkObjectEntryUsageFlagsNVX,
    pub maxUniformBuffersPerDescriptor: u32,
    pub maxStorageBuffersPerDescriptor: u32,
    pub maxStorageImagesPerDescriptor: u32,
    pub maxSampledImagesPerDescriptor: u32,
    pub maxPipelineLayouts: u32,
}
#[test]
fn bindgen_test_layout_VkObjectTableCreateInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTableCreateInfoNVX>(),
        72usize,
        concat!("Size of: ", stringify!(VkObjectTableCreateInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTableCreateInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkObjectTableCreateInfoNVX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).objectCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(objectCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).pObjectEntryTypes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(pObjectEntryTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).pObjectEntryCounts as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(pObjectEntryCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).pObjectEntryUsageFlags
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(pObjectEntryUsageFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).maxUniformBuffersPerDescriptor
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(maxUniformBuffersPerDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).maxStorageBuffersPerDescriptor
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(maxStorageBuffersPerDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).maxStorageImagesPerDescriptor
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(maxStorageImagesPerDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).maxSampledImagesPerDescriptor
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(maxSampledImagesPerDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableCreateInfoNVX>())).maxPipelineLayouts as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableCreateInfoNVX),
            "::",
            stringify!(maxPipelineLayouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
}
#[test]
fn bindgen_test_layout_VkObjectTableEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTableEntryNVX>(),
        8usize,
        concat!("Size of: ", stringify!(VkObjectTableEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTableEntryNVX>(),
        4usize,
        concat!("Alignment of ", stringify!(VkObjectTableEntryNVX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkObjectTableEntryNVX>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkObjectTableEntryNVX>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableEntryNVX),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTablePipelineEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipeline: VkPipeline,
}
#[test]
fn bindgen_test_layout_VkObjectTablePipelineEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTablePipelineEntryNVX>(),
        16usize,
        concat!("Size of: ", stringify!(VkObjectTablePipelineEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTablePipelineEntryNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkObjectTablePipelineEntryNVX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePipelineEntryNVX>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePipelineEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePipelineEntryNVX>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePipelineEntryNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePipelineEntryNVX>())).pipeline as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePipelineEntryNVX),
            "::",
            stringify!(pipeline)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableDescriptorSetEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipelineLayout: VkPipelineLayout,
    pub descriptorSet: VkDescriptorSet,
}
#[test]
fn bindgen_test_layout_VkObjectTableDescriptorSetEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTableDescriptorSetEntryNVX>(),
        24usize,
        concat!("Size of: ", stringify!(VkObjectTableDescriptorSetEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTableDescriptorSetEntryNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkObjectTableDescriptorSetEntryNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableDescriptorSetEntryNVX>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableDescriptorSetEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableDescriptorSetEntryNVX>())).flags as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableDescriptorSetEntryNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableDescriptorSetEntryNVX>())).pipelineLayout
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableDescriptorSetEntryNVX),
            "::",
            stringify!(pipelineLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableDescriptorSetEntryNVX>())).descriptorSet as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableDescriptorSetEntryNVX),
            "::",
            stringify!(descriptorSet)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableVertexBufferEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkObjectTableVertexBufferEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTableVertexBufferEntryNVX>(),
        16usize,
        concat!("Size of: ", stringify!(VkObjectTableVertexBufferEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTableVertexBufferEntryNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkObjectTableVertexBufferEntryNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableVertexBufferEntryNVX>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableVertexBufferEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableVertexBufferEntryNVX>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableVertexBufferEntryNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableVertexBufferEntryNVX>())).buffer as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableVertexBufferEntryNVX),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableIndexBufferEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub buffer: VkBuffer,
    pub indexType: VkIndexType,
}
#[test]
fn bindgen_test_layout_VkObjectTableIndexBufferEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTableIndexBufferEntryNVX>(),
        24usize,
        concat!("Size of: ", stringify!(VkObjectTableIndexBufferEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTableIndexBufferEntryNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkObjectTableIndexBufferEntryNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableIndexBufferEntryNVX>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableIndexBufferEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableIndexBufferEntryNVX>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableIndexBufferEntryNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableIndexBufferEntryNVX>())).buffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableIndexBufferEntryNVX),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTableIndexBufferEntryNVX>())).indexType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTableIndexBufferEntryNVX),
            "::",
            stringify!(indexType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTablePushConstantEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipelineLayout: VkPipelineLayout,
    pub stageFlags: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkObjectTablePushConstantEntryNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkObjectTablePushConstantEntryNVX>(),
        24usize,
        concat!("Size of: ", stringify!(VkObjectTablePushConstantEntryNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkObjectTablePushConstantEntryNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkObjectTablePushConstantEntryNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePushConstantEntryNVX>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePushConstantEntryNVX),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePushConstantEntryNVX>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePushConstantEntryNVX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePushConstantEntryNVX>())).pipelineLayout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePushConstantEntryNVX),
            "::",
            stringify!(pipelineLayout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkObjectTablePushConstantEntryNVX>())).stageFlags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkObjectTablePushConstantEntryNVX),
            "::",
            stringify!(stageFlags)
        )
    );
}
pub type PFN_vkCmdProcessCommandsNVX = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pProcessCommandsInfo: *const VkCmdProcessCommandsInfoNVX,
    ),
>;
pub type PFN_vkCmdReserveSpaceForCommandsNVX = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pReserveSpaceInfo: *const VkCmdReserveSpaceForCommandsInfoNVX,
    ),
>;
pub type PFN_vkCreateIndirectCommandsLayoutNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNVX,
    ) -> VkResult,
>;
pub type PFN_vkDestroyIndirectCommandsLayoutNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateObjectTableNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkObjectTableCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pObjectTable: *mut VkObjectTableNVX,
    ) -> VkResult,
>;
pub type PFN_vkDestroyObjectTableNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkRegisterObjectsNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        objectCount: u32,
        ppObjectTableEntries: *const *const VkObjectTableEntryNVX,
        pObjectIndices: *const u32,
    ) -> VkResult,
>;
pub type PFN_vkUnregisterObjectsNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        objectCount: u32,
        pObjectEntryTypes: *const VkObjectEntryTypeNVX,
        pObjectIndices: *const u32,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkDeviceGeneratedCommandsFeaturesNVX,
        pLimits: *mut VkDeviceGeneratedCommandsLimitsNVX,
    ),
>;
extern "C" {
    pub fn vkCmdProcessCommandsNVX(
        commandBuffer: VkCommandBuffer,
        pProcessCommandsInfo: *const VkCmdProcessCommandsInfoNVX,
    );
}
extern "C" {
    pub fn vkCmdReserveSpaceForCommandsNVX(
        commandBuffer: VkCommandBuffer,
        pReserveSpaceInfo: *const VkCmdReserveSpaceForCommandsInfoNVX,
    );
}
extern "C" {
    pub fn vkCreateIndirectCommandsLayoutNVX(
        device: VkDevice,
        pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNVX,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyIndirectCommandsLayoutNVX(
        device: VkDevice,
        indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateObjectTableNVX(
        device: VkDevice,
        pCreateInfo: *const VkObjectTableCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pObjectTable: *mut VkObjectTableNVX,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyObjectTableNVX(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkRegisterObjectsNVX(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        objectCount: u32,
        ppObjectTableEntries: *const *const VkObjectTableEntryNVX,
        pObjectIndices: *const u32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUnregisterObjectsNVX(
        device: VkDevice,
        objectTable: VkObjectTableNVX,
        objectCount: u32,
        pObjectEntryTypes: *const VkObjectEntryTypeNVX,
        pObjectIndices: *const u32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkDeviceGeneratedCommandsFeaturesNVX,
        pLimits: *mut VkDeviceGeneratedCommandsLimitsNVX,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
#[test]
fn bindgen_test_layout_VkViewportWScalingNV() {
    assert_eq!(
        ::std::mem::size_of::<VkViewportWScalingNV>(),
        8usize,
        concat!("Size of: ", stringify!(VkViewportWScalingNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewportWScalingNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewportWScalingNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportWScalingNV>())).xcoeff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportWScalingNV),
            "::",
            stringify!(xcoeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportWScalingNV>())).ycoeff as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportWScalingNV),
            "::",
            stringify!(ycoeff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewportWScalingEnable: VkBool32,
    pub viewportCount: u32,
    pub pViewportWScalings: *const VkViewportWScalingNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportWScalingStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportWScalingStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportWScalingStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportWScalingStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportWScalingStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportWScalingStateCreateInfoNV>()))
                .viewportWScalingEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
            "::",
            stringify!(viewportWScalingEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportWScalingStateCreateInfoNV>())).viewportCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
            "::",
            stringify!(viewportCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportWScalingStateCreateInfoNV>()))
                .pViewportWScalings as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
            "::",
            stringify!(pViewportWScalings)
        )
    );
}
pub type PFN_vkCmdSetViewportWScalingNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportWScalings: *const VkViewportWScalingNV,
    ),
>;
extern "C" {
    pub fn vkCmdSetViewportWScalingNV(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportWScalings: *const VkViewportWScalingNV,
    );
}
pub type PFN_vkReleaseDisplayEXT = ::std::option::Option<
    unsafe extern "C" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult,
>;
extern "C" {
    pub fn vkReleaseDisplayEXT(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR)
        -> VkResult;
}
pub const VkSurfaceCounterFlagBitsEXT_VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT =
    1;
pub const VkSurfaceCounterFlagBitsEXT_VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT:
    VkSurfaceCounterFlagBitsEXT = 2147483647;
pub type VkSurfaceCounterFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkSurfaceCounterFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilities2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
    pub supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilities2EXT>(),
        72usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilities2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilities2EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilities2EXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).minImageCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(minImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).maxImageCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(maxImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).currentExtent as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(currentExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).minImageExtent as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(minImageExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).maxImageExtent as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(maxImageExtent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).maxImageArrayLayers as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(maxImageArrayLayers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).supportedTransforms as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(supportedTransforms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).currentTransform as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(currentTransform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).supportedCompositeAlpha
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(supportedCompositeAlpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).supportedUsageFlags as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(supportedUsageFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSurfaceCapabilities2EXT>())).supportedSurfaceCounters
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSurfaceCapabilities2EXT),
            "::",
            stringify!(supportedSurfaceCounters)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT,
    ) -> VkResult;
}
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_OFF_EXT: VkDisplayPowerStateEXT = 0;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_SUSPEND_EXT: VkDisplayPowerStateEXT = 1;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_ON_EXT: VkDisplayPowerStateEXT = 2;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT: VkDisplayPowerStateEXT = 0;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_END_RANGE_EXT: VkDisplayPowerStateEXT = 2;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT: VkDisplayPowerStateEXT = 3;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT: VkDisplayPowerStateEXT =
    2147483647;
pub type VkDisplayPowerStateEXT = ::std::os::raw::c_uint;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT: VkDeviceEventTypeEXT = 0;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT: VkDeviceEventTypeEXT = 0;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_END_RANGE_EXT: VkDeviceEventTypeEXT = 0;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT: VkDeviceEventTypeEXT = 1;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT: VkDeviceEventTypeEXT = 2147483647;
pub type VkDeviceEventTypeEXT = ::std::os::raw::c_uint;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT: VkDisplayEventTypeEXT =
    0;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT: VkDisplayEventTypeEXT = 0;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT: VkDisplayEventTypeEXT = 0;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT: VkDisplayEventTypeEXT = 1;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT: VkDisplayEventTypeEXT =
    2147483647;
pub type VkDisplayEventTypeEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPowerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub powerState: VkDisplayPowerStateEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayPowerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPowerInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayPowerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPowerInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPowerInfoEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPowerInfoEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPowerInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayPowerInfoEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPowerInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayPowerInfoEXT>())).powerState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayPowerInfoEXT),
            "::",
            stringify!(powerState)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceEvent: VkDeviceEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDeviceEventInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceEventInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceEventInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceEventInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceEventInfoEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceEventInfoEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceEventInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDeviceEventInfoEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceEventInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceEventInfoEXT>())).deviceEvent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceEventInfoEXT),
            "::",
            stringify!(deviceEvent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayEvent: VkDisplayEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayEventInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayEventInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayEventInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayEventInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayEventInfoEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayEventInfoEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayEventInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDisplayEventInfoEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayEventInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayEventInfoEXT>())).displayEvent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayEventInfoEXT),
            "::",
            stringify!(displayEvent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainCounterCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSwapchainCounterCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainCounterCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkSwapchainCounterCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainCounterCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSwapchainCounterCreateInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCounterCreateInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCounterCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCounterCreateInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCounterCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainCounterCreateInfoEXT>())).surfaceCounters as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainCounterCreateInfoEXT),
            "::",
            stringify!(surfaceCounters)
        )
    );
}
pub type PFN_vkDisplayPowerControlEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkRegisterDeviceEventEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pDeviceEventInfo: *const VkDeviceEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkRegisterDisplayEventEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayEventInfo: *const VkDisplayEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkGetSwapchainCounterEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        counter: VkSurfaceCounterFlagBitsEXT,
        pCounterValue: *mut u64,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkDisplayPowerControlEXT(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkRegisterDeviceEventEXT(
        device: VkDevice,
        pDeviceEventInfo: *const VkDeviceEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkRegisterDisplayEventEXT(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayEventInfo: *const VkDisplayEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetSwapchainCounterEXT(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        counter: VkSurfaceCounterFlagBitsEXT,
        pCounterValue: *mut u64,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRefreshCycleDurationGOOGLE {
    pub refreshDuration: u64,
}
#[test]
fn bindgen_test_layout_VkRefreshCycleDurationGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkRefreshCycleDurationGOOGLE>(),
        8usize,
        concat!("Size of: ", stringify!(VkRefreshCycleDurationGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRefreshCycleDurationGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRefreshCycleDurationGOOGLE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRefreshCycleDurationGOOGLE>())).refreshDuration as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRefreshCycleDurationGOOGLE),
            "::",
            stringify!(refreshDuration)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPastPresentationTimingGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
    pub actualPresentTime: u64,
    pub earliestPresentTime: u64,
    pub presentMargin: u64,
}
#[test]
fn bindgen_test_layout_VkPastPresentationTimingGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPastPresentationTimingGOOGLE>(),
        40usize,
        concat!("Size of: ", stringify!(VkPastPresentationTimingGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPastPresentationTimingGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPastPresentationTimingGOOGLE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPastPresentationTimingGOOGLE>())).presentID as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPastPresentationTimingGOOGLE),
            "::",
            stringify!(presentID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPastPresentationTimingGOOGLE>())).desiredPresentTime
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPastPresentationTimingGOOGLE),
            "::",
            stringify!(desiredPresentTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPastPresentationTimingGOOGLE>())).actualPresentTime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPastPresentationTimingGOOGLE),
            "::",
            stringify!(actualPresentTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPastPresentationTimingGOOGLE>())).earliestPresentTime
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPastPresentationTimingGOOGLE),
            "::",
            stringify!(earliestPresentTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPastPresentationTimingGOOGLE>())).presentMargin as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPastPresentationTimingGOOGLE),
            "::",
            stringify!(presentMargin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentTimeGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
}
#[test]
fn bindgen_test_layout_VkPresentTimeGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentTimeGOOGLE>(),
        16usize,
        concat!("Size of: ", stringify!(VkPresentTimeGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentTimeGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentTimeGOOGLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentTimeGOOGLE>())).presentID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimeGOOGLE),
            "::",
            stringify!(presentID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentTimeGOOGLE>())).desiredPresentTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimeGOOGLE),
            "::",
            stringify!(desiredPresentTime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentTimesInfoGOOGLE {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pTimes: *const VkPresentTimeGOOGLE,
}
#[test]
fn bindgen_test_layout_VkPresentTimesInfoGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentTimesInfoGOOGLE>(),
        32usize,
        concat!("Size of: ", stringify!(VkPresentTimesInfoGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentTimesInfoGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentTimesInfoGOOGLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentTimesInfoGOOGLE>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimesInfoGOOGLE),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentTimesInfoGOOGLE>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimesInfoGOOGLE),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPresentTimesInfoGOOGLE>())).swapchainCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimesInfoGOOGLE),
            "::",
            stringify!(swapchainCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPresentTimesInfoGOOGLE>())).pTimes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPresentTimesInfoGOOGLE),
            "::",
            stringify!(pTimes)
        )
    );
}
pub type PFN_vkGetRefreshCycleDurationGOOGLE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE,
    ) -> VkResult,
>;
pub type PFN_vkGetPastPresentationTimingGOOGLE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pPresentationTimingCount: *mut u32,
        pPresentationTimings: *mut VkPastPresentationTimingGOOGLE,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetRefreshCycleDurationGOOGLE(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPastPresentationTimingGOOGLE(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pPresentationTimingCount: *mut u32,
        pPresentationTimings: *mut VkPastPresentationTimingGOOGLE,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub perViewPositionAllComponents: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>()))
                .sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>()))
                .pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>()))
                .perViewPositionAllComponents as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
            "::",
            stringify!(perViewPositionAllComponents)
        )
    );
}
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV:
    VkViewportCoordinateSwizzleNV = 0;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV:
    VkViewportCoordinateSwizzleNV = 1;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV:
    VkViewportCoordinateSwizzleNV = 2;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV:
    VkViewportCoordinateSwizzleNV = 3;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV:
    VkViewportCoordinateSwizzleNV = 4;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV:
    VkViewportCoordinateSwizzleNV = 5;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV:
    VkViewportCoordinateSwizzleNV = 6;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV:
    VkViewportCoordinateSwizzleNV = 7;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV:
    VkViewportCoordinateSwizzleNV = 0;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV:
    VkViewportCoordinateSwizzleNV = 7;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV:
    VkViewportCoordinateSwizzleNV = 8;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV:
    VkViewportCoordinateSwizzleNV = 2147483647;
pub type VkViewportCoordinateSwizzleNV = ::std::os::raw::c_uint;
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkViewportSwizzleNV {
    pub x: VkViewportCoordinateSwizzleNV,
    pub y: VkViewportCoordinateSwizzleNV,
    pub z: VkViewportCoordinateSwizzleNV,
    pub w: VkViewportCoordinateSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkViewportSwizzleNV() {
    assert_eq!(
        ::std::mem::size_of::<VkViewportSwizzleNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkViewportSwizzleNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewportSwizzleNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewportSwizzleNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportSwizzleNV>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportSwizzleNV),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportSwizzleNV>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportSwizzleNV),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportSwizzleNV>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportSwizzleNV),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkViewportSwizzleNV>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkViewportSwizzleNV),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
    pub viewportCount: u32,
    pub pViewportSwizzles: *const VkViewportSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportSwizzleStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportSwizzleStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportSwizzleStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportSwizzleStateCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportSwizzleStateCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportSwizzleStateCreateInfoNV>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportSwizzleStateCreateInfoNV>())).viewportCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
            "::",
            stringify!(viewportCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportSwizzleStateCreateInfoNV>())).pViewportSwizzles
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
            "::",
            stringify!(pViewportSwizzles)
        )
    );
}
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT:
    VkDiscardRectangleModeEXT = 0;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT:
    VkDiscardRectangleModeEXT = 1;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT:
    VkDiscardRectangleModeEXT = 0;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT:
    VkDiscardRectangleModeEXT = 1;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT:
    VkDiscardRectangleModeEXT = 2;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT:
    VkDiscardRectangleModeEXT = 2147483647;
pub type VkDiscardRectangleModeEXT = ::std::os::raw::c_uint;
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxDiscardRectangles: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>()))
                .maxDiscardRectangles as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
            "::",
            stringify!(maxDiscardRectangles)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
    pub discardRectangleMode: VkDiscardRectangleModeEXT,
    pub discardRectangleCount: u32,
    pub pDiscardRectangles: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineDiscardRectangleStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>()))
                .discardRectangleMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(discardRectangleMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>()))
                .discardRectangleCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(discardRectangleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineDiscardRectangleStateCreateInfoEXT>()))
                .pDiscardRectangles as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
            "::",
            stringify!(pDiscardRectangles)
        )
    );
}
pub type PFN_vkCmdSetDiscardRectangleEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstDiscardRectangle: u32,
        discardRectangleCount: u32,
        pDiscardRectangles: *const VkRect2D,
    ),
>;
extern "C" {
    pub fn vkCmdSetDiscardRectangleEXT(
        commandBuffer: VkCommandBuffer,
        firstDiscardRectangle: u32,
        discardRectangleCount: u32,
        pDiscardRectangles: *const VkRect2D,
    );
}
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT:
    VkConservativeRasterizationModeEXT = 0;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT:
    VkConservativeRasterizationModeEXT = 1;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT : VkConservativeRasterizationModeEXT = 2 ;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_BEGIN_RANGE_EXT:
    VkConservativeRasterizationModeEXT = 0;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_END_RANGE_EXT:
    VkConservativeRasterizationModeEXT = 2;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_RANGE_SIZE_EXT:
    VkConservativeRasterizationModeEXT = 3;
pub const VkConservativeRasterizationModeEXT_VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT:
    VkConservativeRasterizationModeEXT = 2147483647;
pub type VkConservativeRasterizationModeEXT = ::std::os::raw::c_uint;
pub type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub primitiveOverestimationSize: f32,
    pub maxExtraPrimitiveOverestimationSize: f32,
    pub extraPrimitiveOverestimationSizeGranularity: f32,
    pub primitiveUnderestimation: VkBool32,
    pub conservativePointAndLineRasterization: VkBool32,
    pub degenerateTrianglesRasterized: VkBool32,
    pub degenerateLinesRasterized: VkBool32,
    pub fullyCoveredFragmentShaderInputVariable: VkBool32,
    pub conservativeRasterizationPostDepthCoverage: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .primitiveOverestimationSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(primitiveOverestimationSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .maxExtraPrimitiveOverestimationSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(maxExtraPrimitiveOverestimationSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .extraPrimitiveOverestimationSizeGranularity as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(extraPrimitiveOverestimationSizeGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .primitiveUnderestimation as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(primitiveUnderestimation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .conservativePointAndLineRasterization as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(conservativePointAndLineRasterization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .degenerateTrianglesRasterized as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(degenerateTrianglesRasterized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .degenerateLinesRasterized as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(degenerateLinesRasterized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .fullyCoveredFragmentShaderInputVariable as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(fullyCoveredFragmentShaderInputVariable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>()))
                .conservativeRasterizationPostDepthCoverage as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
            "::",
            stringify!(conservativeRasterizationPostDepthCoverage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT,
    pub conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    pub extraPrimitiveOverestimationSize: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationConservativeStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationConservativeStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationConservativeStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationConservativeStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationConservativeStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationConservativeStateCreateInfoEXT>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationConservativeStateCreateInfoEXT>()))
                .conservativeRasterizationMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
            "::",
            stringify!(conservativeRasterizationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationConservativeStateCreateInfoEXT>()))
                .extraPrimitiveOverestimationSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
            "::",
            stringify!(extraPrimitiveOverestimationSize)
        )
    );
}
pub type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub depthClipEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthClipEnableFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>())).depthClipEnable
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
            "::",
            stringify!(depthClipEnable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depthClipEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationDepthClipStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>()))
                .depthClipEnable as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
            "::",
            stringify!(depthClipEnable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkXYColorEXT {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VkXYColorEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkXYColorEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkXYColorEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkXYColorEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkXYColorEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkXYColorEXT>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXYColorEXT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkXYColorEXT>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXYColorEXT),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkHdrMetadataEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayPrimaryRed: VkXYColorEXT,
    pub displayPrimaryGreen: VkXYColorEXT,
    pub displayPrimaryBlue: VkXYColorEXT,
    pub whitePoint: VkXYColorEXT,
    pub maxLuminance: f32,
    pub minLuminance: f32,
    pub maxContentLightLevel: f32,
    pub maxFrameAverageLightLevel: f32,
}
#[test]
fn bindgen_test_layout_VkHdrMetadataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkHdrMetadataEXT>(),
        64usize,
        concat!("Size of: ", stringify!(VkHdrMetadataEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkHdrMetadataEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkHdrMetadataEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkHdrMetadataEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkHdrMetadataEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHdrMetadataEXT>())).displayPrimaryRed as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(displayPrimaryRed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHdrMetadataEXT>())).displayPrimaryGreen as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(displayPrimaryGreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHdrMetadataEXT>())).displayPrimaryBlue as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(displayPrimaryBlue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkHdrMetadataEXT>())).whitePoint as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(whitePoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkHdrMetadataEXT>())).maxLuminance as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(maxLuminance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkHdrMetadataEXT>())).minLuminance as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(minLuminance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHdrMetadataEXT>())).maxContentLightLevel as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(maxContentLightLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHdrMetadataEXT>())).maxFrameAverageLightLevel as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHdrMetadataEXT),
            "::",
            stringify!(maxFrameAverageLightLevel)
        )
    );
}
pub type PFN_vkSetHdrMetadataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchainCount: u32,
        pSwapchains: *const VkSwapchainKHR,
        pMetadata: *const VkHdrMetadataEXT,
    ),
>;
extern "C" {
    pub fn vkSetHdrMetadataEXT(
        device: VkDevice,
        swapchainCount: u32,
        pSwapchains: *const VkSwapchainKHR,
        pMetadata: *const VkHdrMetadataEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerEXT_T {
    _unused: [u8; 0],
}
pub type VkDebugUtilsMessengerEXT = *mut VkDebugUtilsMessengerEXT_T;
pub type VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
pub type VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT:
    VkDebugUtilsMessageSeverityFlagBitsEXT = 1;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT:
    VkDebugUtilsMessageSeverityFlagBitsEXT = 16;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT:
    VkDebugUtilsMessageSeverityFlagBitsEXT = 256;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT:
    VkDebugUtilsMessageSeverityFlagBitsEXT = 4096;
pub const VkDebugUtilsMessageSeverityFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT : VkDebugUtilsMessageSeverityFlagBitsEXT = 2147483647 ;
pub type VkDebugUtilsMessageSeverityFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;
pub const VkDebugUtilsMessageTypeFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT:
    VkDebugUtilsMessageTypeFlagBitsEXT = 1;
pub const VkDebugUtilsMessageTypeFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT:
    VkDebugUtilsMessageTypeFlagBitsEXT = 2;
pub const VkDebugUtilsMessageTypeFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT:
    VkDebugUtilsMessageTypeFlagBitsEXT = 4;
pub const VkDebugUtilsMessageTypeFlagBitsEXT_VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT:
    VkDebugUtilsMessageTypeFlagBitsEXT = 2147483647;
pub type VkDebugUtilsMessageTypeFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkDebugUtilsMessageTypeFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsObjectNameInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkObjectType,
    pub objectHandle: u64,
    pub pObjectName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsObjectNameInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsObjectNameInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugUtilsObjectNameInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsObjectNameInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsObjectNameInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectNameInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectNameInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectNameInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectNameInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectNameInfoEXT>())).objectType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectNameInfoEXT),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectNameInfoEXT>())).objectHandle as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectNameInfoEXT),
            "::",
            stringify!(objectHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectNameInfoEXT>())).pObjectName as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectNameInfoEXT),
            "::",
            stringify!(pObjectName)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsObjectTagInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkObjectType,
    pub objectHandle: u64,
    pub tagName: u64,
    pub tagSize: size_t,
    pub pTag: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsObjectTagInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsObjectTagInfoEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkDebugUtilsObjectTagInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsObjectTagInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsObjectTagInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).objectType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).objectHandle as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(objectHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).tagName as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(tagName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).tagSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(tagSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsObjectTagInfoEXT>())).pTag as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsObjectTagInfoEXT),
            "::",
            stringify!(pTag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsLabelEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pLabelName: *const ::std::os::raw::c_char,
    pub color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkDebugUtilsLabelEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsLabelEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugUtilsLabelEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsLabelEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsLabelEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDebugUtilsLabelEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsLabelEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDebugUtilsLabelEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsLabelEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDebugUtilsLabelEXT>())).pLabelName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsLabelEXT),
            "::",
            stringify!(pLabelName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkDebugUtilsLabelEXT>())).color as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsLabelEXT),
            "::",
            stringify!(color)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerCallbackDataEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
    pub pMessageIdName: *const ::std::os::raw::c_char,
    pub messageIdNumber: i32,
    pub pMessage: *const ::std::os::raw::c_char,
    pub queueLabelCount: u32,
    pub pQueueLabels: *const VkDebugUtilsLabelEXT,
    pub cmdBufLabelCount: u32,
    pub pCmdBufLabels: *const VkDebugUtilsLabelEXT,
    pub objectCount: u32,
    pub pObjects: *const VkDebugUtilsObjectNameInfoEXT,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsMessengerCallbackDataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsMessengerCallbackDataEXT>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsMessengerCallbackDataEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pMessageIdName
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pMessageIdName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).messageIdNumber
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(messageIdNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pMessage as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).queueLabelCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(queueLabelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pQueueLabels
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pQueueLabels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).cmdBufLabelCount
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(cmdBufLabelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pCmdBufLabels
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pCmdBufLabels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).objectCount as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(objectCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCallbackDataEXT>())).pObjects as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT),
            "::",
            stringify!(pObjects)
        )
    );
}
pub type PFN_vkDebugUtilsMessengerCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> VkBool32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugUtilsMessengerCreateFlagsEXT,
    pub messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    pub messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pub pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsMessengerCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsMessengerCreateInfoEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkDebugUtilsMessengerCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsMessengerCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).messageSeverity
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(messageSeverity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).messageType as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(messageType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).pfnUserCallback
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(pfnUserCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDebugUtilsMessengerCreateInfoEXT>())).pUserData as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT),
            "::",
            stringify!(pUserData)
        )
    );
}
pub type PFN_vkSetDebugUtilsObjectNameEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkSetDebugUtilsObjectTagEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkQueueBeginDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkQueueEndDebugUtilsLabelEXT =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue)>;
pub type PFN_vkQueueInsertDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCmdBeginDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCmdEndDebugUtilsLabelEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdInsertDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCreateDebugUtilsMessengerEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMessenger: *mut VkDebugUtilsMessengerEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDebugUtilsMessengerEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        messenger: VkDebugUtilsMessengerEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkSubmitDebugUtilsMessageEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    ),
>;
extern "C" {
    pub fn vkSetDebugUtilsObjectNameEXT(
        device: VkDevice,
        pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSetDebugUtilsObjectTagEXT(
        device: VkDevice,
        pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueBeginDebugUtilsLabelEXT(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
}
extern "C" {
    pub fn vkQueueEndDebugUtilsLabelEXT(queue: VkQueue);
}
extern "C" {
    pub fn vkQueueInsertDebugUtilsLabelEXT(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
}
extern "C" {
    pub fn vkCmdBeginDebugUtilsLabelEXT(
        commandBuffer: VkCommandBuffer,
        pLabelInfo: *const VkDebugUtilsLabelEXT,
    );
}
extern "C" {
    pub fn vkCmdEndDebugUtilsLabelEXT(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdInsertDebugUtilsLabelEXT(
        commandBuffer: VkCommandBuffer,
        pLabelInfo: *const VkDebugUtilsLabelEXT,
    );
}
extern "C" {
    pub fn vkCreateDebugUtilsMessengerEXT(
        instance: VkInstance,
        pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMessenger: *mut VkDebugUtilsMessengerEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDebugUtilsMessengerEXT(
        instance: VkInstance,
        messenger: VkDebugUtilsMessengerEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkSubmitDebugUtilsMessageEXT(
        instance: VkInstance,
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    );
}
pub use self::VkSamplerReductionMode as VkSamplerReductionModeEXT;
pub type VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
pub type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT =
    VkPhysicalDeviceSamplerFilterMinmaxProperties;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub inlineUniformBlock: VkBool32,
    pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInlineUniformBlockFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>()))
                .inlineUniformBlock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT),
            "::",
            stringify!(inlineUniformBlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>()))
                .descriptorBindingInlineUniformBlockUpdateAfterBind as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeaturesEXT),
            "::",
            stringify!(descriptorBindingInlineUniformBlockUpdateAfterBind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxInlineUniformBlockSize: u32,
    pub maxPerStageDescriptorInlineUniformBlocks: u32,
    pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
    pub maxDescriptorSetInlineUniformBlocks: u32,
    pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInlineUniformBlockPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>()))
                .maxInlineUniformBlockSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(maxInlineUniformBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>()))
                .maxPerStageDescriptorInlineUniformBlocks as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(maxPerStageDescriptorInlineUniformBlocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>()))
                .maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>()))
                .maxDescriptorSetInlineUniformBlocks as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(maxDescriptorSetInlineUniformBlocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>()))
                .maxDescriptorSetUpdateAfterBindInlineUniformBlocks as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockPropertiesEXT),
            "::",
            stringify!(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSetInlineUniformBlockEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dataSize: u32,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSetInlineUniformBlockEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSetInlineUniformBlockEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSetInlineUniformBlockEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetInlineUniformBlockEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetInlineUniformBlockEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetInlineUniformBlockEXT>())).dataSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetInlineUniformBlockEXT>())).pData as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlockEXT),
            "::",
            stringify!(pData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxInlineUniformBlockBindings: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolInlineUniformBlockCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>()))
                .maxInlineUniformBlockBindings as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfoEXT),
            "::",
            stringify!(maxInlineUniformBlockBindings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VkSampleLocationEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSampleLocationEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkSampleLocationEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSampleLocationEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSampleLocationEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSampleLocationEXT>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationEXT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSampleLocationEXT>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationEXT),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampleLocationsInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleLocationsPerPixel: VkSampleCountFlagBits,
    pub sampleLocationGridSize: VkExtent2D,
    pub sampleLocationsCount: u32,
    pub pSampleLocations: *const VkSampleLocationEXT,
}
#[test]
fn bindgen_test_layout_VkSampleLocationsInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSampleLocationsInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkSampleLocationsInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSampleLocationsInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSampleLocationsInfoEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).sampleLocationsPerPixel as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(sampleLocationsPerPixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).sampleLocationGridSize as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(sampleLocationGridSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).sampleLocationsCount as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(sampleLocationsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSampleLocationsInfoEXT>())).pSampleLocations as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSampleLocationsInfoEXT),
            "::",
            stringify!(pSampleLocations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentSampleLocationsEXT {
    pub attachmentIndex: u32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkAttachmentSampleLocationsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentSampleLocationsEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkAttachmentSampleLocationsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentSampleLocationsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentSampleLocationsEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentSampleLocationsEXT>())).attachmentIndex as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentSampleLocationsEXT),
            "::",
            stringify!(attachmentIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAttachmentSampleLocationsEXT>())).sampleLocationsInfo
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAttachmentSampleLocationsEXT),
            "::",
            stringify!(sampleLocationsInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassSampleLocationsEXT {
    pub subpassIndex: u32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkSubpassSampleLocationsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassSampleLocationsEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkSubpassSampleLocationsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassSampleLocationsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassSampleLocationsEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassSampleLocationsEXT>())).subpassIndex as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassSampleLocationsEXT),
            "::",
            stringify!(subpassIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSubpassSampleLocationsEXT>())).sampleLocationsInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSubpassSampleLocationsEXT),
            "::",
            stringify!(sampleLocationsInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassSampleLocationsBeginInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentInitialSampleLocationsCount: u32,
    pub pAttachmentInitialSampleLocations: *const VkAttachmentSampleLocationsEXT,
    pub postSubpassSampleLocationsCount: u32,
    pub pPostSubpassSampleLocations: *const VkSubpassSampleLocationsEXT,
}
#[test]
fn bindgen_test_layout_VkRenderPassSampleLocationsBeginInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassSampleLocationsBeginInfoEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassSampleLocationsBeginInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>()))
                .attachmentInitialSampleLocationsCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(attachmentInitialSampleLocationsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>()))
                .pAttachmentInitialSampleLocations as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(pAttachmentInitialSampleLocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>()))
                .postSubpassSampleLocationsCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(postSubpassSampleLocationsCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassSampleLocationsBeginInfoEXT>()))
                .pPostSubpassSampleLocations as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
            "::",
            stringify!(pPostSubpassSampleLocations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineSampleLocationsStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleLocationsEnable: VkBool32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineSampleLocationsStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineSampleLocationsStateCreateInfoEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineSampleLocationsStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineSampleLocationsStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineSampleLocationsStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineSampleLocationsStateCreateInfoEXT>()))
                .sampleLocationsEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
            "::",
            stringify!(sampleLocationsEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineSampleLocationsStateCreateInfoEXT>()))
                .sampleLocationsInfo as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
            "::",
            stringify!(sampleLocationsInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sampleLocationSampleCounts: VkSampleCountFlags,
    pub maxSampleLocationGridSize: VkExtent2D,
    pub sampleLocationCoordinateRange: [f32; 2usize],
    pub sampleLocationSubPixelBits: u32,
    pub variableSampleLocations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSampleLocationsPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSampleLocationsPropertiesEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSampleLocationsPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>()))
                .sampleLocationSampleCounts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(sampleLocationSampleCounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>()))
                .maxSampleLocationGridSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(maxSampleLocationGridSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>()))
                .sampleLocationCoordinateRange as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(sampleLocationCoordinateRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>()))
                .sampleLocationSubPixelBits as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(sampleLocationSubPixelBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSampleLocationsPropertiesEXT>()))
                .variableSampleLocations as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
            "::",
            stringify!(variableSampleLocations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMultisamplePropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxSampleLocationGridSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkMultisamplePropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMultisamplePropertiesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMultisamplePropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultisamplePropertiesEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMultisamplePropertiesEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMultisamplePropertiesEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMultisamplePropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMultisamplePropertiesEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMultisamplePropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMultisamplePropertiesEXT>())).maxSampleLocationGridSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMultisamplePropertiesEXT),
            "::",
            stringify!(maxSampleLocationGridSize)
        )
    );
}
pub type PFN_vkCmdSetSampleLocationsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        samples: VkSampleCountFlagBits,
        pMultisampleProperties: *mut VkMultisamplePropertiesEXT,
    ),
>;
extern "C" {
    pub fn vkCmdSetSampleLocationsEXT(
        commandBuffer: VkCommandBuffer,
        pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMultisamplePropertiesEXT(
        physicalDevice: VkPhysicalDevice,
        samples: VkSampleCountFlagBits,
        pMultisampleProperties: *mut VkMultisamplePropertiesEXT,
    );
}
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_UNCORRELATED_EXT: VkBlendOverlapEXT = 0;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_DISJOINT_EXT: VkBlendOverlapEXT = 1;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_CONJOINT_EXT: VkBlendOverlapEXT = 2;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_BEGIN_RANGE_EXT: VkBlendOverlapEXT = 0;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_END_RANGE_EXT: VkBlendOverlapEXT = 2;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_RANGE_SIZE_EXT: VkBlendOverlapEXT = 3;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_MAX_ENUM_EXT: VkBlendOverlapEXT = 2147483647;
pub type VkBlendOverlapEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendCoherentOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>()))
                .advancedBlendCoherentOperations as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
            "::",
            stringify!(advancedBlendCoherentOperations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendMaxColorAttachments: u32,
    pub advancedBlendIndependentBlend: VkBool32,
    pub advancedBlendNonPremultipliedSrcColor: VkBool32,
    pub advancedBlendNonPremultipliedDstColor: VkBool32,
    pub advancedBlendCorrelatedOverlap: VkBool32,
    pub advancedBlendAllOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendMaxColorAttachments as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendMaxColorAttachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendIndependentBlend as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendIndependentBlend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendNonPremultipliedSrcColor as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendNonPremultipliedSrcColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendNonPremultipliedDstColor as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendNonPremultipliedDstColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendCorrelatedOverlap as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendCorrelatedOverlap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()))
                .advancedBlendAllOperations as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
            "::",
            stringify!(advancedBlendAllOperations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcPremultiplied: VkBool32,
    pub dstPremultiplied: VkBool32,
    pub blendOverlap: VkBlendOverlapEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>()))
                .srcPremultiplied as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
            "::",
            stringify!(srcPremultiplied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>()))
                .dstPremultiplied as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
            "::",
            stringify!(dstPremultiplied)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>())).blendOverlap
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
            "::",
            stringify!(blendOverlap)
        )
    );
}
pub type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageToColorStateCreateFlagsNV,
    pub coverageToColorEnable: VkBool32,
    pub coverageToColorLocation: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageToColorStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageToColorStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageToColorStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageToColorStateCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageToColorStateCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageToColorStateCreateInfoNV>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageToColorStateCreateInfoNV>()))
                .coverageToColorEnable as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
            "::",
            stringify!(coverageToColorEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageToColorStateCreateInfoNV>()))
                .coverageToColorLocation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
            "::",
            stringify!(coverageToColorLocation)
        )
    );
}
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_NONE_NV:
    VkCoverageModulationModeNV = 0;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_RGB_NV:
    VkCoverageModulationModeNV = 1;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_ALPHA_NV:
    VkCoverageModulationModeNV = 2;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_RGBA_NV:
    VkCoverageModulationModeNV = 3;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV:
    VkCoverageModulationModeNV = 0;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_END_RANGE_NV:
    VkCoverageModulationModeNV = 3;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV:
    VkCoverageModulationModeNV = 4;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV:
    VkCoverageModulationModeNV = 2147483647;
pub type VkCoverageModulationModeNV = ::std::os::raw::c_uint;
pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageModulationStateCreateFlagsNV,
    pub coverageModulationMode: VkCoverageModulationModeNV,
    pub coverageModulationTableEnable: VkBool32,
    pub coverageModulationTableCount: u32,
    pub pCoverageModulationTable: *const f32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageModulationStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageModulationStateCreateInfoNV>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageModulationStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>()))
                .coverageModulationMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(coverageModulationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>()))
                .coverageModulationTableEnable as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(coverageModulationTableEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>()))
                .coverageModulationTableCount as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(coverageModulationTableCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageModulationStateCreateInfoNV>()))
                .pCoverageModulationTable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
            "::",
            stringify!(pCoverageModulationTable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSMCount: u32,
    pub shaderWarpsPerSM: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>())).shaderSMCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
            "::",
            stringify!(shaderSMCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>()))
                .shaderWarpsPerSM as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
            "::",
            stringify!(shaderWarpsPerSM)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSMBuiltins: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>())).shaderSMBuiltins
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
            "::",
            stringify!(shaderSMBuiltins)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesEXT {
    pub drmFormatModifier: u64,
    pub drmFormatModifierPlaneCount: u32,
    pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierPropertiesEXT>(),
        16usize,
        concat!("Size of: ", stringify!(VkDrmFormatModifierPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesEXT>())).drmFormatModifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(drmFormatModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesEXT>())).drmFormatModifierPlaneCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(drmFormatModifierPlaneCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesEXT>()))
                .drmFormatModifierTilingFeatures as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(drmFormatModifierTilingFeatures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesListEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub drmFormatModifierCount: u32,
    pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierPropertiesEXT,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierPropertiesListEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierPropertiesListEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierPropertiesListEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierPropertiesListEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesListEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesListEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesListEXT>())).drmFormatModifierCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT),
            "::",
            stringify!(drmFormatModifierCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrmFormatModifierPropertiesListEXT>()))
                .pDrmFormatModifierProperties as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT),
            "::",
            stringify!(pDrmFormatModifierProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageDrmFormatModifierInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>()))
                .drmFormatModifier as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(drmFormatModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>())).sharingMode
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(sharingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>()))
                .queueFamilyIndexCount as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(queueFamilyIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>()))
                .pQueueFamilyIndices as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
            "::",
            stringify!(pQueueFamilyIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierListCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifierCount: u32,
    pub pDrmFormatModifiers: *const u64,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierListCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierListCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierListCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierListCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierListCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierListCreateInfoEXT>()))
                .drmFormatModifierCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
            "::",
            stringify!(drmFormatModifierCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierListCreateInfoEXT>()))
                .pDrmFormatModifiers as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
            "::",
            stringify!(pDrmFormatModifiers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
    pub drmFormatModifierPlaneCount: u32,
    pub pPlaneLayouts: *const VkSubresourceLayout,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierExplicitCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierExplicitCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierExplicitCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierExplicitCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierExplicitCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierExplicitCreateInfoEXT>()))
                .drmFormatModifier as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
            "::",
            stringify!(drmFormatModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierExplicitCreateInfoEXT>()))
                .drmFormatModifierPlaneCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
            "::",
            stringify!(drmFormatModifierPlaneCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierExplicitCreateInfoEXT>())).pPlaneLayouts
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
            "::",
            stringify!(pPlaneLayouts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierPropertiesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierPropertiesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImageDrmFormatModifierPropertiesEXT>())).drmFormatModifier
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT),
            "::",
            stringify!(drmFormatModifier)
        )
    );
}
pub type PFN_vkGetImageDrmFormatModifierPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pProperties: *mut VkImageDrmFormatModifierPropertiesEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetImageDrmFormatModifierPropertiesEXT(
        device: VkDevice,
        image: VkImage,
        pProperties: *mut VkImageDrmFormatModifierPropertiesEXT,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationCacheEXT_T {
    _unused: [u8; 0],
}
pub type VkValidationCacheEXT = *mut VkValidationCacheEXT_T;
pub const VkValidationCacheHeaderVersionEXT_VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT:
    VkValidationCacheHeaderVersionEXT = 1;
pub const VkValidationCacheHeaderVersionEXT_VK_VALIDATION_CACHE_HEADER_VERSION_BEGIN_RANGE_EXT:
    VkValidationCacheHeaderVersionEXT = 1;
pub const VkValidationCacheHeaderVersionEXT_VK_VALIDATION_CACHE_HEADER_VERSION_END_RANGE_EXT:
    VkValidationCacheHeaderVersionEXT = 1;
pub const VkValidationCacheHeaderVersionEXT_VK_VALIDATION_CACHE_HEADER_VERSION_RANGE_SIZE_EXT:
    VkValidationCacheHeaderVersionEXT = 1;
pub const VkValidationCacheHeaderVersionEXT_VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT:
    VkValidationCacheHeaderVersionEXT = 2147483647;
pub type VkValidationCacheHeaderVersionEXT = ::std::os::raw::c_uint;
pub type VkValidationCacheCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationCacheCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkValidationCacheCreateFlagsEXT,
    pub initialDataSize: size_t,
    pub pInitialData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkValidationCacheCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationCacheCreateInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkValidationCacheCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationCacheCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationCacheCreateInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationCacheCreateInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationCacheCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationCacheCreateInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationCacheCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationCacheCreateInfoEXT>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationCacheCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationCacheCreateInfoEXT>())).initialDataSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationCacheCreateInfoEXT),
            "::",
            stringify!(initialDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationCacheCreateInfoEXT>())).pInitialData as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationCacheCreateInfoEXT),
            "::",
            stringify!(pInitialData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModuleValidationCacheCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub validationCache: VkValidationCacheEXT,
}
#[test]
fn bindgen_test_layout_VkShaderModuleValidationCacheCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderModuleValidationCacheCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderModuleValidationCacheCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderModuleValidationCacheCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderModuleValidationCacheCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShaderModuleValidationCacheCreateInfoEXT>())).validationCache
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
            "::",
            stringify!(validationCache)
        )
    );
}
pub type PFN_vkCreateValidationCacheEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkValidationCacheCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pValidationCache: *mut VkValidationCacheEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyValidationCacheEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMergeValidationCachesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        dstCache: VkValidationCacheEXT,
        srcCacheCount: u32,
        pSrcCaches: *const VkValidationCacheEXT,
    ) -> VkResult,
>;
pub type PFN_vkGetValidationCacheDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pDataSize: *mut size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateValidationCacheEXT(
        device: VkDevice,
        pCreateInfo: *const VkValidationCacheCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pValidationCache: *mut VkValidationCacheEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyValidationCacheEXT(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkMergeValidationCachesEXT(
        device: VkDevice,
        dstCache: VkValidationCacheEXT,
        srcCacheCount: u32,
        pSrcCaches: *const VkValidationCacheEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetValidationCacheDataEXT(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pDataSize: *mut size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
pub use self::VkDescriptorBindingFlagBits as VkDescriptorBindingFlagBitsEXT;
pub type VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;
pub type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT =
    VkDescriptorSetLayoutBindingFlagsCreateInfo;
pub type VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
pub type VkPhysicalDeviceDescriptorIndexingPropertiesEXT =
    VkPhysicalDeviceDescriptorIndexingProperties;
pub type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT =
    VkDescriptorSetVariableDescriptorCountAllocateInfo;
pub type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT =
    VkDescriptorSetVariableDescriptorCountLayoutSupport;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV:
    VkShadingRatePaletteEntryNV = 0;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV:
    VkShadingRatePaletteEntryNV = 1;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV:
    VkShadingRatePaletteEntryNV = 2;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV:
    VkShadingRatePaletteEntryNV = 3;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV:
    VkShadingRatePaletteEntryNV = 4;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV:
    VkShadingRatePaletteEntryNV = 5;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV : VkShadingRatePaletteEntryNV = 6 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV : VkShadingRatePaletteEntryNV = 7 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV : VkShadingRatePaletteEntryNV = 8 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV : VkShadingRatePaletteEntryNV = 9 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV : VkShadingRatePaletteEntryNV = 10 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV : VkShadingRatePaletteEntryNV = 11 ;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_BEGIN_RANGE_NV:
    VkShadingRatePaletteEntryNV = 0;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_END_RANGE_NV:
    VkShadingRatePaletteEntryNV = 11;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_RANGE_SIZE_NV:
    VkShadingRatePaletteEntryNV = 12;
pub const VkShadingRatePaletteEntryNV_VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV:
    VkShadingRatePaletteEntryNV = 2147483647;
pub type VkShadingRatePaletteEntryNV = ::std::os::raw::c_uint;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV:
    VkCoarseSampleOrderTypeNV = 0;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV:
    VkCoarseSampleOrderTypeNV = 1;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV:
    VkCoarseSampleOrderTypeNV = 2;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV:
    VkCoarseSampleOrderTypeNV = 3;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_BEGIN_RANGE_NV:
    VkCoarseSampleOrderTypeNV = 0;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_END_RANGE_NV:
    VkCoarseSampleOrderTypeNV = 3;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV:
    VkCoarseSampleOrderTypeNV = 4;
pub const VkCoarseSampleOrderTypeNV_VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV:
    VkCoarseSampleOrderTypeNV = 2147483647;
pub type VkCoarseSampleOrderTypeNV = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShadingRatePaletteNV {
    pub shadingRatePaletteEntryCount: u32,
    pub pShadingRatePaletteEntries: *const VkShadingRatePaletteEntryNV,
}
#[test]
fn bindgen_test_layout_VkShadingRatePaletteNV() {
    assert_eq!(
        ::std::mem::size_of::<VkShadingRatePaletteNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkShadingRatePaletteNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShadingRatePaletteNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShadingRatePaletteNV))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShadingRatePaletteNV>())).shadingRatePaletteEntryCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShadingRatePaletteNV),
            "::",
            stringify!(shadingRatePaletteEntryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkShadingRatePaletteNV>())).pShadingRatePaletteEntries
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkShadingRatePaletteNV),
            "::",
            stringify!(pShadingRatePaletteEntries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub shadingRateImageEnable: VkBool32,
    pub viewportCount: u32,
    pub pShadingRatePalettes: *const VkShadingRatePaletteNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportShadingRateImageStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportShadingRateImageStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportShadingRateImageStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportShadingRateImageStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportShadingRateImageStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportShadingRateImageStateCreateInfoNV>()))
                .shadingRateImageEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
            "::",
            stringify!(shadingRateImageEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportShadingRateImageStateCreateInfoNV>()))
                .viewportCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
            "::",
            stringify!(viewportCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportShadingRateImageStateCreateInfoNV>()))
                .pShadingRatePalettes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
            "::",
            stringify!(pShadingRatePalettes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShadingRateImageFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shadingRateImage: VkBool32,
    pub shadingRateCoarseSampleOrder: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShadingRateImageFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShadingRateImageFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShadingRateImageFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImageFeaturesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImageFeaturesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImageFeaturesNV>())).shadingRateImage
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
            "::",
            stringify!(shadingRateImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImageFeaturesNV>()))
                .shadingRateCoarseSampleOrder as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
            "::",
            stringify!(shadingRateCoarseSampleOrder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShadingRateImagePropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shadingRateTexelSize: VkExtent2D,
    pub shadingRatePaletteSize: u32,
    pub shadingRateMaxCoarseSamples: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShadingRateImagePropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShadingRateImagePropertiesNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShadingRateImagePropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImagePropertiesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImagePropertiesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImagePropertiesNV>()))
                .shadingRateTexelSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
            "::",
            stringify!(shadingRateTexelSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImagePropertiesNV>()))
                .shadingRatePaletteSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
            "::",
            stringify!(shadingRatePaletteSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShadingRateImagePropertiesNV>()))
                .shadingRateMaxCoarseSamples as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
            "::",
            stringify!(shadingRateMaxCoarseSamples)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCoarseSampleLocationNV {
    pub pixelX: u32,
    pub pixelY: u32,
    pub sample: u32,
}
#[test]
fn bindgen_test_layout_VkCoarseSampleLocationNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCoarseSampleLocationNV>(),
        12usize,
        concat!("Size of: ", stringify!(VkCoarseSampleLocationNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCoarseSampleLocationNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkCoarseSampleLocationNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCoarseSampleLocationNV>())).pixelX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleLocationNV),
            "::",
            stringify!(pixelX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCoarseSampleLocationNV>())).pixelY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleLocationNV),
            "::",
            stringify!(pixelY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCoarseSampleLocationNV>())).sample as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleLocationNV),
            "::",
            stringify!(sample)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCoarseSampleOrderCustomNV {
    pub shadingRate: VkShadingRatePaletteEntryNV,
    pub sampleCount: u32,
    pub sampleLocationCount: u32,
    pub pSampleLocations: *const VkCoarseSampleLocationNV,
}
#[test]
fn bindgen_test_layout_VkCoarseSampleOrderCustomNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCoarseSampleOrderCustomNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkCoarseSampleOrderCustomNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCoarseSampleOrderCustomNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCoarseSampleOrderCustomNV))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCoarseSampleOrderCustomNV>())).shadingRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleOrderCustomNV),
            "::",
            stringify!(shadingRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCoarseSampleOrderCustomNV>())).sampleCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleOrderCustomNV),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCoarseSampleOrderCustomNV>())).sampleLocationCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleOrderCustomNV),
            "::",
            stringify!(sampleLocationCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCoarseSampleOrderCustomNV>())).pSampleLocations as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCoarseSampleOrderCustomNV),
            "::",
            stringify!(pSampleLocations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleOrderType: VkCoarseSampleOrderTypeNV,
    pub customSampleOrderCount: u32,
    pub pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>()))
                .sampleOrderType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
            "::",
            stringify!(sampleOrderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>()))
                .customSampleOrderCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
            "::",
            stringify!(customSampleOrderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>()))
                .pCustomSampleOrders as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
            "::",
            stringify!(pCustomSampleOrders)
        )
    );
}
pub type PFN_vkCmdBindShadingRateImageNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    ),
>;
pub type PFN_vkCmdSetViewportShadingRatePaletteNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pShadingRatePalettes: *const VkShadingRatePaletteNV,
    ),
>;
pub type PFN_vkCmdSetCoarseSampleOrderNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        sampleOrderType: VkCoarseSampleOrderTypeNV,
        customSampleOrderCount: u32,
        pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
    ),
>;
extern "C" {
    pub fn vkCmdBindShadingRateImageNV(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    );
}
extern "C" {
    pub fn vkCmdSetViewportShadingRatePaletteNV(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pShadingRatePalettes: *const VkShadingRatePaletteNV,
    );
}
extern "C" {
    pub fn vkCmdSetCoarseSampleOrderNV(
        commandBuffer: VkCommandBuffer,
        sampleOrderType: VkCoarseSampleOrderTypeNV,
        customSampleOrderCount: u32,
        pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureNV_T {
    _unused: [u8; 0],
}
pub type VkAccelerationStructureNV = *mut VkAccelerationStructureNV_T;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV:
    VkAccelerationStructureTypeNV = 0;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV:
    VkAccelerationStructureTypeNV = 1;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV:
    VkAccelerationStructureTypeNV = 0;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV:
    VkAccelerationStructureTypeNV = 1;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV:
    VkAccelerationStructureTypeNV = 2;
pub const VkAccelerationStructureTypeNV_VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV:
    VkAccelerationStructureTypeNV = 2147483647;
pub type VkAccelerationStructureTypeNV = ::std::os::raw::c_uint;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV:
    VkRayTracingShaderGroupTypeNV = 0;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV:
    VkRayTracingShaderGroupTypeNV = 1;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV:
    VkRayTracingShaderGroupTypeNV = 2;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV:
    VkRayTracingShaderGroupTypeNV = 0;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV:
    VkRayTracingShaderGroupTypeNV = 2;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV:
    VkRayTracingShaderGroupTypeNV = 3;
pub const VkRayTracingShaderGroupTypeNV_VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV:
    VkRayTracingShaderGroupTypeNV = 2147483647;
pub type VkRayTracingShaderGroupTypeNV = ::std::os::raw::c_uint;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeNV = 0;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeNV = 1;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_BEGIN_RANGE_NV: VkGeometryTypeNV = 0;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_END_RANGE_NV: VkGeometryTypeNV = 1;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_RANGE_SIZE_NV: VkGeometryTypeNV = 2;
pub const VkGeometryTypeNV_VK_GEOMETRY_TYPE_MAX_ENUM_NV: VkGeometryTypeNV = 2147483647;
pub type VkGeometryTypeNV = ::std::os::raw::c_uint;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV:
    VkCopyAccelerationStructureModeNV = 0;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV:
    VkCopyAccelerationStructureModeNV = 1;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV:
    VkCopyAccelerationStructureModeNV = 0;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV:
    VkCopyAccelerationStructureModeNV = 1;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV:
    VkCopyAccelerationStructureModeNV = 2;
pub const VkCopyAccelerationStructureModeNV_VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV:
    VkCopyAccelerationStructureModeNV = 2147483647;
pub type VkCopyAccelerationStructureModeNV = ::std::os::raw::c_uint;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 0 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 1 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 2 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 0 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 2 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 3 ;
pub const VkAccelerationStructureMemoryRequirementsTypeNV_VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV : VkAccelerationStructureMemoryRequirementsTypeNV = 2147483647 ;
pub type VkAccelerationStructureMemoryRequirementsTypeNV = ::std::os::raw::c_uint;
pub const VkGeometryFlagBitsNV_VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsNV = 1;
pub const VkGeometryFlagBitsNV_VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV:
    VkGeometryFlagBitsNV = 2;
pub const VkGeometryFlagBitsNV_VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV: VkGeometryFlagBitsNV = 2147483647;
pub type VkGeometryFlagBitsNV = ::std::os::raw::c_uint;
pub type VkGeometryFlagsNV = VkFlags;
pub const VkGeometryInstanceFlagBitsNV_VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV:
    VkGeometryInstanceFlagBitsNV = 1;
pub const VkGeometryInstanceFlagBitsNV_VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV : VkGeometryInstanceFlagBitsNV = 2 ;
pub const VkGeometryInstanceFlagBitsNV_VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV:
    VkGeometryInstanceFlagBitsNV = 4;
pub const VkGeometryInstanceFlagBitsNV_VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV:
    VkGeometryInstanceFlagBitsNV = 8;
pub const VkGeometryInstanceFlagBitsNV_VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV:
    VkGeometryInstanceFlagBitsNV = 2147483647;
pub type VkGeometryInstanceFlagBitsNV = ::std::os::raw::c_uint;
pub type VkGeometryInstanceFlagsNV = VkFlags;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV : VkBuildAccelerationStructureFlagBitsNV = 1 ;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV : VkBuildAccelerationStructureFlagBitsNV = 2 ;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV : VkBuildAccelerationStructureFlagBitsNV = 4 ;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV : VkBuildAccelerationStructureFlagBitsNV = 8 ;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV : VkBuildAccelerationStructureFlagBitsNV = 16 ;
pub const VkBuildAccelerationStructureFlagBitsNV_VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV : VkBuildAccelerationStructureFlagBitsNV = 2147483647 ;
pub type VkBuildAccelerationStructureFlagBitsNV = ::std::os::raw::c_uint;
pub type VkBuildAccelerationStructureFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingShaderGroupCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkRayTracingShaderGroupTypeNV,
    pub generalShader: u32,
    pub closestHitShader: u32,
    pub anyHitShader: u32,
    pub intersectionShader: u32,
}
#[test]
fn bindgen_test_layout_VkRayTracingShaderGroupCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingShaderGroupCreateInfoNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkRayTracingShaderGroupCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingShaderGroupCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).type_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).generalShader
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(generalShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).closestHitShader
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(closestHitShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).anyHitShader as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(anyHitShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingShaderGroupCreateInfoNV>())).intersectionShader
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV),
            "::",
            stringify!(intersectionShader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub groupCount: u32,
    pub pGroups: *const VkRayTracingShaderGroupCreateInfoNV,
    pub maxRecursionDepth: u32,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkRayTracingPipelineCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingPipelineCreateInfoNV>(),
        80usize,
        concat!("Size of: ", stringify!(VkRayTracingPipelineCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingPipelineCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingPipelineCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).stageCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(stageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).pStages as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(pStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).groupCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(groupCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).pGroups as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(pGroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).maxRecursionDepth
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(maxRecursionDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).layout as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).basePipelineHandle
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(basePipelineHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRayTracingPipelineCreateInfoNV>())).basePipelineIndex
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRayTracingPipelineCreateInfoNV),
            "::",
            stringify!(basePipelineIndex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryTrianglesNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexData: VkBuffer,
    pub vertexOffset: VkDeviceSize,
    pub vertexCount: u32,
    pub vertexStride: VkDeviceSize,
    pub vertexFormat: VkFormat,
    pub indexData: VkBuffer,
    pub indexOffset: VkDeviceSize,
    pub indexCount: u32,
    pub indexType: VkIndexType,
    pub transformData: VkBuffer,
    pub transformOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkGeometryTrianglesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryTrianglesNV>(),
        96usize,
        concat!("Size of: ", stringify!(VkGeometryTrianglesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryTrianglesNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryTrianglesNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).vertexData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(vertexData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).vertexOffset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(vertexOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).vertexCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(vertexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).vertexStride as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(vertexStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).vertexFormat as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(vertexFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).indexData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(indexData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).indexOffset as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(indexOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).indexCount as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(indexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).indexType as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(indexType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).transformData as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(transformData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkGeometryTrianglesNV>())).transformOffset as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryTrianglesNV),
            "::",
            stringify!(transformOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryAABBNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub aabbData: VkBuffer,
    pub numAABBs: u32,
    pub stride: u32,
    pub offset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkGeometryAABBNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryAABBNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkGeometryAABBNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryAABBNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryAABBNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).aabbData as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(aabbData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).numAABBs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(numAABBs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).stride as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryAABBNV>())).offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryAABBNV),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryDataNV {
    pub triangles: VkGeometryTrianglesNV,
    pub aabbs: VkGeometryAABBNV,
}
#[test]
fn bindgen_test_layout_VkGeometryDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryDataNV>(),
        136usize,
        concat!("Size of: ", stringify!(VkGeometryDataNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryDataNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryDataNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryDataNV>())).triangles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryDataNV),
            "::",
            stringify!(triangles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryDataNV>())).aabbs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryDataNV),
            "::",
            stringify!(aabbs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub geometryType: VkGeometryTypeNV,
    pub geometry: VkGeometryDataNV,
    pub flags: VkGeometryFlagsNV,
}
#[test]
fn bindgen_test_layout_VkGeometryNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryNV>(),
        168usize,
        concat!("Size of: ", stringify!(VkGeometryNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryNV>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryNV>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryNV>())).geometryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryNV),
            "::",
            stringify!(geometryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryNV>())).geometry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryNV),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkGeometryNV>())).flags as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(VkGeometryNV),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkAccelerationStructureTypeNV,
    pub flags: VkBuildAccelerationStructureFlagsNV,
    pub instanceCount: u32,
    pub geometryCount: u32,
    pub pGeometries: *const VkGeometryNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureInfoNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAccelerationStructureInfoNV))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).flags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).instanceCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(instanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).geometryCount as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(geometryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureInfoNV>())).pGeometries as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureInfoNV),
            "::",
            stringify!(pGeometries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub compactedSize: VkDeviceSize,
    pub info: VkAccelerationStructureInfoNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureCreateInfoNV>(),
        64usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureCreateInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureCreateInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureCreateInfoNV>())).compactedSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureCreateInfoNV),
            "::",
            stringify!(compactedSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureCreateInfoNV>())).info as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureCreateInfoNV),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindAccelerationStructureMemoryInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructure: VkAccelerationStructureNV,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBindAccelerationStructureMemoryInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkBindAccelerationStructureMemoryInfoNV>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindAccelerationStructureMemoryInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>()))
                .accelerationStructure as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(accelerationStructure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).memory as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).memoryOffset
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(memoryOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).deviceIndexCount
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(deviceIndexCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBindAccelerationStructureMemoryInfoNV>())).pDeviceIndices
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV),
            "::",
            stringify!(pDeviceIndices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSetAccelerationStructureNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructureCount: u32,
    pub pAccelerationStructures: *const VkAccelerationStructureNV,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSetAccelerationStructureNV() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSetAccelerationStructureNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSetAccelerationStructureNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetAccelerationStructureNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetAccelerationStructureNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetAccelerationStructureNV>()))
                .accelerationStructureCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV),
            "::",
            stringify!(accelerationStructureCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkWriteDescriptorSetAccelerationStructureNV>()))
                .pAccelerationStructures as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV),
            "::",
            stringify!(pAccelerationStructures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkAccelerationStructureMemoryRequirementsTypeNV,
    pub accelerationStructure: VkAccelerationStructureNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMemoryRequirementsInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMemoryRequirementsInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMemoryRequirementsInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureMemoryRequirementsInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureMemoryRequirementsInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureMemoryRequirementsInfoNV>())).type_
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkAccelerationStructureMemoryRequirementsInfoNV>()))
                .accelerationStructure as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
            "::",
            stringify!(accelerationStructure)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderGroupHandleSize: u32,
    pub maxRecursionDepth: u32,
    pub maxShaderGroupStride: u32,
    pub shaderGroupBaseAlignment: u32,
    pub maxGeometryCount: u64,
    pub maxInstanceCount: u64,
    pub maxTriangleCount: u64,
    pub maxDescriptorSetAccelerationStructures: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingPropertiesNV>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).shaderGroupHandleSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(shaderGroupHandleSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).maxRecursionDepth
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxRecursionDepth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).maxShaderGroupStride
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxShaderGroupStride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>()))
                .shaderGroupBaseAlignment as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(shaderGroupBaseAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).maxGeometryCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxGeometryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).maxInstanceCount
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxInstanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>())).maxTriangleCount
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxTriangleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRayTracingPropertiesNV>()))
                .maxDescriptorSetAccelerationStructures as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
            "::",
            stringify!(maxDescriptorSetAccelerationStructures)
        )
    );
}
pub type PFN_vkCreateAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureNV,
    ) -> VkResult,
>;
pub type PFN_vkDestroyAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetAccelerationStructureMemoryRequirementsNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkBindAccelerationStructureMemoryNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV,
    ) -> VkResult,
>;
pub type PFN_vkCmdBuildAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkAccelerationStructureInfoNV,
        instanceData: VkBuffer,
        instanceOffset: VkDeviceSize,
        update: VkBool32,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        scratch: VkBuffer,
        scratchOffset: VkDeviceSize,
    ),
>;
pub type PFN_vkCmdCopyAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        mode: VkCopyAccelerationStructureModeNV,
    ),
>;
pub type PFN_vkCmdTraceRaysNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        raygenShaderBindingTableBuffer: VkBuffer,
        raygenShaderBindingOffset: VkDeviceSize,
        missShaderBindingTableBuffer: VkBuffer,
        missShaderBindingOffset: VkDeviceSize,
        missShaderBindingStride: VkDeviceSize,
        hitShaderBindingTableBuffer: VkBuffer,
        hitShaderBindingOffset: VkDeviceSize,
        hitShaderBindingStride: VkDeviceSize,
        callableShaderBindingTableBuffer: VkBuffer,
        callableShaderBindingOffset: VkDeviceSize,
        callableShaderBindingStride: VkDeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    ),
>;
pub type PFN_vkCreateRayTracingPipelinesNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkGetRayTracingShaderGroupHandlesNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetAccelerationStructureHandleNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkCmdWriteAccelerationStructuresPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureNV,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    ),
>;
pub type PFN_vkCompileDeferredNV = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult,
>;
extern "C" {
    pub fn vkCreateAccelerationStructureNV(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyAccelerationStructureNV(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetAccelerationStructureMemoryRequirementsNV(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    );
}
extern "C" {
    pub fn vkBindAccelerationStructureMemoryNV(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBuildAccelerationStructureNV(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkAccelerationStructureInfoNV,
        instanceData: VkBuffer,
        instanceOffset: VkDeviceSize,
        update: VkBool32,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        scratch: VkBuffer,
        scratchOffset: VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdCopyAccelerationStructureNV(
        commandBuffer: VkCommandBuffer,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        mode: VkCopyAccelerationStructureModeNV,
    );
}
extern "C" {
    pub fn vkCmdTraceRaysNV(
        commandBuffer: VkCommandBuffer,
        raygenShaderBindingTableBuffer: VkBuffer,
        raygenShaderBindingOffset: VkDeviceSize,
        missShaderBindingTableBuffer: VkBuffer,
        missShaderBindingOffset: VkDeviceSize,
        missShaderBindingStride: VkDeviceSize,
        hitShaderBindingTableBuffer: VkBuffer,
        hitShaderBindingOffset: VkDeviceSize,
        hitShaderBindingStride: VkDeviceSize,
        callableShaderBindingTableBuffer: VkBuffer,
        callableShaderBindingOffset: VkDeviceSize,
        callableShaderBindingStride: VkDeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    );
}
extern "C" {
    pub fn vkCreateRayTracingPipelinesNV(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetRayTracingShaderGroupHandlesNV(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetAccelerationStructureHandleNV(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        dataSize: size_t,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdWriteAccelerationStructuresPropertiesNV(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureNV,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    );
}
extern "C" {
    pub fn vkCompileDeferredNV(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub representativeFragmentTest: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>()))
                .representativeFragmentTest as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
            "::",
            stringify!(representativeFragmentTest)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub representativeFragmentTestEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineRepresentativeFragmentTestStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>()))
                .representativeFragmentTestEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
            "::",
            stringify!(representativeFragmentTestEnable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageViewType: VkImageViewType,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageViewImageFormatInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageViewImageFormatInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageViewImageFormatInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageViewImageFormatInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageViewImageFormatInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceImageViewImageFormatInfoEXT>())).imageViewType
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
            "::",
            stringify!(imageViewType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFilterCubicImageViewImageFormatPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub filterCubic: VkBool32,
    pub filterCubicMinmax: VkBool32,
}
#[test]
fn bindgen_test_layout_VkFilterCubicImageViewImageFormatPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkFilterCubicImageViewImageFormatPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkFilterCubicImageViewImageFormatPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFilterCubicImageViewImageFormatPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFilterCubicImageViewImageFormatPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFilterCubicImageViewImageFormatPropertiesEXT>())).filterCubic
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
            "::",
            stringify!(filterCubic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFilterCubicImageViewImageFormatPropertiesEXT>()))
                .filterCubicMinmax as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
            "::",
            stringify!(filterCubicMinmax)
        )
    );
}
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriorityEXT = 128;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriorityEXT =
    256;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriorityEXT =
    512;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriorityEXT =
    1024;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT:
    VkQueueGlobalPriorityEXT = 128;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT:
    VkQueueGlobalPriorityEXT = 1024;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT:
    VkQueueGlobalPriorityEXT = 897;
pub const VkQueueGlobalPriorityEXT_VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT: VkQueueGlobalPriorityEXT =
    2147483647;
pub type VkQueueGlobalPriorityEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueGlobalPriorityCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub globalPriority: VkQueueGlobalPriorityEXT,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueGlobalPriorityCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueGlobalPriorityCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueGlobalPriorityCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueGlobalPriorityCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueGlobalPriorityCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceQueueGlobalPriorityCreateInfoEXT>())).globalPriority
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoEXT),
            "::",
            stringify!(globalPriority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportMemoryHostPointerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
    pub pHostPointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkImportMemoryHostPointerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImportMemoryHostPointerInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkImportMemoryHostPointerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportMemoryHostPointerInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImportMemoryHostPointerInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportMemoryHostPointerInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryHostPointerInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportMemoryHostPointerInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryHostPointerInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportMemoryHostPointerInfoEXT>())).handleType as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryHostPointerInfoEXT),
            "::",
            stringify!(handleType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkImportMemoryHostPointerInfoEXT>())).pHostPointer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkImportMemoryHostPointerInfoEXT),
            "::",
            stringify!(pHostPointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryHostPointerPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryHostPointerPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryHostPointerPropertiesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryHostPointerPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryHostPointerPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMemoryHostPointerPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryHostPointerPropertiesEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHostPointerPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryHostPointerPropertiesEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHostPointerPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryHostPointerPropertiesEXT>())).memoryTypeBits as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryHostPointerPropertiesEXT),
            "::",
            stringify!(memoryTypeBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minImportedHostPointerAlignment: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>()))
                .minImportedHostPointerAlignment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
            "::",
            stringify!(minImportedHostPointerAlignment)
        )
    );
}
pub type PFN_vkGetMemoryHostPointerPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        pHostPointer: *const ::std::os::raw::c_void,
        pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetMemoryHostPointerPropertiesEXT(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        pHostPointer: *const ::std::os::raw::c_void,
        pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT,
    ) -> VkResult;
}
pub type PFN_vkCmdWriteBufferMarkerAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    ),
>;
extern "C" {
    pub fn vkCmdWriteBufferMarkerAMD(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    );
}
pub const VkPipelineCompilerControlFlagBitsAMD_VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD : VkPipelineCompilerControlFlagBitsAMD = 2147483647 ;
pub type VkPipelineCompilerControlFlagBitsAMD = ::std::os::raw::c_uint;
pub type VkPipelineCompilerControlFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCompilerControlCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub compilerControlFlags: VkPipelineCompilerControlFlagsAMD,
}
#[test]
fn bindgen_test_layout_VkPipelineCompilerControlCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCompilerControlCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCompilerControlCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCompilerControlCreateInfoAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCompilerControlCreateInfoAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCompilerControlCreateInfoAMD>())).compilerControlFlags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD),
            "::",
            stringify!(compilerControlFlags)
        )
    );
}
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainEXT = 0;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainEXT = 1;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainEXT = 2;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainEXT = 3;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_BEGIN_RANGE_EXT: VkTimeDomainEXT = 0;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_END_RANGE_EXT: VkTimeDomainEXT = 3;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_RANGE_SIZE_EXT: VkTimeDomainEXT = 4;
pub const VkTimeDomainEXT_VK_TIME_DOMAIN_MAX_ENUM_EXT: VkTimeDomainEXT = 2147483647;
pub type VkTimeDomainEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCalibratedTimestampInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub timeDomain: VkTimeDomainEXT,
}
#[test]
fn bindgen_test_layout_VkCalibratedTimestampInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCalibratedTimestampInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkCalibratedTimestampInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCalibratedTimestampInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCalibratedTimestampInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCalibratedTimestampInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCalibratedTimestampInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCalibratedTimestampInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCalibratedTimestampInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCalibratedTimestampInfoEXT>())).timeDomain as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCalibratedTimestampInfoEXT),
            "::",
            stringify!(timeDomain)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pTimeDomainCount: *mut u32,
        pTimeDomains: *mut VkTimeDomainEXT,
    ) -> VkResult,
>;
pub type PFN_vkGetCalibratedTimestampsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        timestampCount: u32,
        pTimestampInfos: *const VkCalibratedTimestampInfoEXT,
        pTimestamps: *mut u64,
        pMaxDeviation: *mut u64,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
        physicalDevice: VkPhysicalDevice,
        pTimeDomainCount: *mut u32,
        pTimeDomains: *mut VkTimeDomainEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetCalibratedTimestampsEXT(
        device: VkDevice,
        timestampCount: u32,
        pTimestampInfos: *const VkCalibratedTimestampInfoEXT,
        pTimestamps: *mut u64,
        pMaxDeviation: *mut u64,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCorePropertiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderEngineCount: u32,
    pub shaderArraysPerEngineCount: u32,
    pub computeUnitsPerShaderArray: u32,
    pub simdPerComputeUnit: u32,
    pub wavefrontsPerSimd: u32,
    pub wavefrontSize: u32,
    pub sgprsPerSimd: u32,
    pub minSgprAllocation: u32,
    pub maxSgprAllocation: u32,
    pub sgprAllocationGranularity: u32,
    pub vgprsPerSimd: u32,
    pub minVgprAllocation: u32,
    pub maxVgprAllocation: u32,
    pub vgprAllocationGranularity: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCorePropertiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCorePropertiesAMD>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCorePropertiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).shaderEngineCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(shaderEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>()))
                .shaderArraysPerEngineCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(shaderArraysPerEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>()))
                .computeUnitsPerShaderArray as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(computeUnitsPerShaderArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).simdPerComputeUnit
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(simdPerComputeUnit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).wavefrontsPerSimd
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(wavefrontsPerSimd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).wavefrontSize
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(wavefrontSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).sgprsPerSimd
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(sgprsPerSimd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).minSgprAllocation
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(minSgprAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).maxSgprAllocation
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(maxSgprAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>()))
                .sgprAllocationGranularity as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(sgprAllocationGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).vgprsPerSimd
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(vgprsPerSimd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).minVgprAllocation
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(minVgprAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>())).maxVgprAllocation
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(maxVgprAllocation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCorePropertiesAMD>()))
                .vgprAllocationGranularity as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
            "::",
            stringify!(vgprAllocationGranularity)
        )
    );
}
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD:
    VkMemoryOverallocationBehaviorAMD = 0;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD:
    VkMemoryOverallocationBehaviorAMD = 1;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD:
    VkMemoryOverallocationBehaviorAMD = 2;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD:
    VkMemoryOverallocationBehaviorAMD = 0;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD:
    VkMemoryOverallocationBehaviorAMD = 2;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD:
    VkMemoryOverallocationBehaviorAMD = 3;
pub const VkMemoryOverallocationBehaviorAMD_VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD:
    VkMemoryOverallocationBehaviorAMD = 2147483647;
pub type VkMemoryOverallocationBehaviorAMD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemoryOverallocationCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
}
#[test]
fn bindgen_test_layout_VkDeviceMemoryOverallocationCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceMemoryOverallocationCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceMemoryOverallocationCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOverallocationCreateInfoAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOverallocationCreateInfoAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDeviceMemoryOverallocationCreateInfoAMD>()))
                .overallocationBehavior as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
            "::",
            stringify!(overallocationBehavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxVertexAttribDivisor: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>()))
                .maxVertexAttribDivisor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
            "::",
            stringify!(maxVertexAttribDivisor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDivisorDescriptionEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputBindingDivisorDescriptionEXT>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputBindingDivisorDescriptionEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputBindingDivisorDescriptionEXT>())).binding
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkVertexInputBindingDivisorDescriptionEXT>())).divisor
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT),
            "::",
            stringify!(divisor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexBindingDivisorCount: u32,
    pub pVertexBindingDivisors: *const VkVertexInputBindingDivisorDescriptionEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineVertexInputDivisorStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineVertexInputDivisorStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineVertexInputDivisorStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputDivisorStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputDivisorStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputDivisorStateCreateInfoEXT>()))
                .vertexBindingDivisorCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
            "::",
            stringify!(vertexBindingDivisorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineVertexInputDivisorStateCreateInfoEXT>()))
                .pVertexBindingDivisors as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
            "::",
            stringify!(pVertexBindingDivisors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub vertexAttributeInstanceRateDivisor: VkBool32,
    pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>()))
                .vertexAttributeInstanceRateDivisor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
            "::",
            stringify!(vertexAttributeInstanceRateDivisor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>()))
                .vertexAttributeInstanceRateZeroDivisor as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
            "::",
            stringify!(vertexAttributeInstanceRateZeroDivisor)
        )
    );
}
pub const VkPipelineCreationFeedbackFlagBitsEXT_VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT:
    VkPipelineCreationFeedbackFlagBitsEXT = 1;
pub const VkPipelineCreationFeedbackFlagBitsEXT_VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT : VkPipelineCreationFeedbackFlagBitsEXT = 2 ;
pub const VkPipelineCreationFeedbackFlagBitsEXT_VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT : VkPipelineCreationFeedbackFlagBitsEXT = 4 ;
pub const VkPipelineCreationFeedbackFlagBitsEXT_VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT : VkPipelineCreationFeedbackFlagBitsEXT = 2147483647 ;
pub type VkPipelineCreationFeedbackFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkPipelineCreationFeedbackFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCreationFeedbackEXT {
    pub flags: VkPipelineCreationFeedbackFlagsEXT,
    pub duration: u64,
}
#[test]
fn bindgen_test_layout_VkPipelineCreationFeedbackEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCreationFeedbackEXT>(),
        16usize,
        concat!("Size of: ", stringify!(VkPipelineCreationFeedbackEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCreationFeedbackEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineCreationFeedbackEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackEXT>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackEXT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackEXT>())).duration as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackEXT),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCreationFeedbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pPipelineCreationFeedback: *mut VkPipelineCreationFeedbackEXT,
    pub pipelineStageCreationFeedbackCount: u32,
    pub pPipelineStageCreationFeedbacks: *mut VkPipelineCreationFeedbackEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineCreationFeedbackCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCreationFeedbackCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCreationFeedbackCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackCreateInfoEXT>()))
                .pPipelineCreationFeedback as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT),
            "::",
            stringify!(pPipelineCreationFeedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackCreateInfoEXT>()))
                .pipelineStageCreationFeedbackCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT),
            "::",
            stringify!(pipelineStageCreationFeedbackCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCreationFeedbackCreateInfoEXT>()))
                .pPipelineStageCreationFeedbacks as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCreationFeedbackCreateInfoEXT),
            "::",
            stringify!(pPipelineStageCreationFeedbacks)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub computeDerivativeGroupQuads: VkBool32,
    pub computeDerivativeGroupLinear: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>()))
                .computeDerivativeGroupQuads as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
            "::",
            stringify!(computeDerivativeGroupQuads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>()))
                .computeDerivativeGroupLinear as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
            "::",
            stringify!(computeDerivativeGroupLinear)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub taskShader: VkBool32,
    pub meshShader: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderFeaturesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderFeaturesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderFeaturesNV>())).taskShader as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
            "::",
            stringify!(taskShader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderFeaturesNV>())).meshShader as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
            "::",
            stringify!(meshShader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxDrawMeshTasksCount: u32,
    pub maxTaskWorkGroupInvocations: u32,
    pub maxTaskWorkGroupSize: [u32; 3usize],
    pub maxTaskTotalMemorySize: u32,
    pub maxTaskOutputCount: u32,
    pub maxMeshWorkGroupInvocations: u32,
    pub maxMeshWorkGroupSize: [u32; 3usize],
    pub maxMeshTotalMemorySize: u32,
    pub maxMeshOutputVertices: u32,
    pub maxMeshOutputPrimitives: u32,
    pub maxMeshMultiviewViewCount: u32,
    pub meshOutputPerVertexGranularity: u32,
    pub meshOutputPerPrimitiveGranularity: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderPropertiesNV>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).maxDrawMeshTasksCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxDrawMeshTasksCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxTaskWorkGroupInvocations as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxTaskWorkGroupInvocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).maxTaskWorkGroupSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxTaskWorkGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxTaskTotalMemorySize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxTaskTotalMemorySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).maxTaskOutputCount
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxTaskOutputCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxMeshWorkGroupInvocations as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshWorkGroupInvocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).maxMeshWorkGroupSize
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshWorkGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxMeshTotalMemorySize as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshTotalMemorySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>())).maxMeshOutputVertices
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshOutputVertices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxMeshOutputPrimitives as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshOutputPrimitives)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .maxMeshMultiviewViewCount as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(maxMeshMultiviewViewCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .meshOutputPerVertexGranularity as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(meshOutputPerVertexGranularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMeshShaderPropertiesNV>()))
                .meshOutputPerPrimitiveGranularity as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
            "::",
            stringify!(meshOutputPerPrimitiveGranularity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrawMeshTasksIndirectCommandNV {
    pub taskCount: u32,
    pub firstTask: u32,
}
#[test]
fn bindgen_test_layout_VkDrawMeshTasksIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawMeshTasksIndirectCommandNV>(),
        8usize,
        concat!("Size of: ", stringify!(VkDrawMeshTasksIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawMeshTasksIndirectCommandNV>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrawMeshTasksIndirectCommandNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawMeshTasksIndirectCommandNV>())).taskCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawMeshTasksIndirectCommandNV),
            "::",
            stringify!(taskCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDrawMeshTasksIndirectCommandNV>())).firstTask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDrawMeshTasksIndirectCommandNV),
            "::",
            stringify!(firstTask)
        )
    );
}
pub type PFN_vkCmdDrawMeshTasksNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectCountNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawMeshTasksNV(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32);
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectNV(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectCountNV(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentShaderBarycentric: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>()))
                .fragmentShaderBarycentric as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV),
            "::",
            stringify!(fragmentShaderBarycentric)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageFootprint: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderImageFootprintFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>()))
                .imageFootprint as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
            "::",
            stringify!(imageFootprint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub exclusiveScissorCount: u32,
    pub pExclusiveScissors: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportExclusiveScissorStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>()))
                .exclusiveScissorCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
            "::",
            stringify!(exclusiveScissorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>()))
                .pExclusiveScissors as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
            "::",
            stringify!(pExclusiveScissors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exclusiveScissor: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExclusiveScissorFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExclusiveScissorFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExclusiveScissorFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExclusiveScissorFeaturesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExclusiveScissorFeaturesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceExclusiveScissorFeaturesNV>())).exclusiveScissor
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
            "::",
            stringify!(exclusiveScissor)
        )
    );
}
pub type PFN_vkCmdSetExclusiveScissorNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstExclusiveScissor: u32,
        exclusiveScissorCount: u32,
        pExclusiveScissors: *const VkRect2D,
    ),
>;
extern "C" {
    pub fn vkCmdSetExclusiveScissorNV(
        commandBuffer: VkCommandBuffer,
        firstExclusiveScissor: u32,
        exclusiveScissorCount: u32,
        pExclusiveScissors: *const VkRect2D,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyCheckpointPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub checkpointExecutionStageMask: VkPipelineStageFlags,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyCheckpointPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyCheckpointPropertiesNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkQueueFamilyCheckpointPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyCheckpointPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueueFamilyCheckpointPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyCheckpointPropertiesNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyCheckpointPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyCheckpointPropertiesNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyCheckpointPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueueFamilyCheckpointPropertiesNV>()))
                .checkpointExecutionStageMask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueueFamilyCheckpointPropertiesNV),
            "::",
            stringify!(checkpointExecutionStageMask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCheckpointDataNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stage: VkPipelineStageFlagBits,
    pub pCheckpointMarker: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkCheckpointDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCheckpointDataNV>(),
        32usize,
        concat!("Size of: ", stringify!(VkCheckpointDataNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCheckpointDataNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCheckpointDataNV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCheckpointDataNV>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCheckpointDataNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCheckpointDataNV>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCheckpointDataNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkCheckpointDataNV>())).stage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCheckpointDataNV),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCheckpointDataNV>())).pCheckpointMarker as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCheckpointDataNV),
            "::",
            stringify!(pCheckpointMarker)
        )
    );
}
pub type PFN_vkCmdSetCheckpointNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCheckpointMarker: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkGetQueueCheckpointDataNV = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointDataNV,
    ),
>;
extern "C" {
    pub fn vkCmdSetCheckpointNV(
        commandBuffer: VkCommandBuffer,
        pCheckpointMarker: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkGetQueueCheckpointDataNV(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointDataNV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderIntegerFunctions2: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>()))
                .shaderIntegerFunctions2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
            "::",
            stringify!(shaderIntegerFunctions2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceConfigurationINTEL_T {
    _unused: [u8; 0],
}
pub type VkPerformanceConfigurationINTEL = *mut VkPerformanceConfigurationINTEL_T;
pub const VkPerformanceConfigurationTypeINTEL_VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL : VkPerformanceConfigurationTypeINTEL = 0 ;
pub const VkPerformanceConfigurationTypeINTEL_VK_PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL : VkPerformanceConfigurationTypeINTEL = 0 ;
pub const VkPerformanceConfigurationTypeINTEL_VK_PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL:
    VkPerformanceConfigurationTypeINTEL = 0;
pub const VkPerformanceConfigurationTypeINTEL_VK_PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL:
    VkPerformanceConfigurationTypeINTEL = 1;
pub const VkPerformanceConfigurationTypeINTEL_VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL:
    VkPerformanceConfigurationTypeINTEL = 2147483647;
pub type VkPerformanceConfigurationTypeINTEL = ::std::os::raw::c_uint;
pub const VkQueryPoolSamplingModeINTEL_VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL:
    VkQueryPoolSamplingModeINTEL = 0;
pub const VkQueryPoolSamplingModeINTEL_VK_QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL:
    VkQueryPoolSamplingModeINTEL = 0;
pub const VkQueryPoolSamplingModeINTEL_VK_QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL:
    VkQueryPoolSamplingModeINTEL = 0;
pub const VkQueryPoolSamplingModeINTEL_VK_QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL:
    VkQueryPoolSamplingModeINTEL = 1;
pub const VkQueryPoolSamplingModeINTEL_VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL:
    VkQueryPoolSamplingModeINTEL = 2147483647;
pub type VkQueryPoolSamplingModeINTEL = ::std::os::raw::c_uint;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL:
    VkPerformanceOverrideTypeINTEL = 0;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL:
    VkPerformanceOverrideTypeINTEL = 1;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL:
    VkPerformanceOverrideTypeINTEL = 0;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL:
    VkPerformanceOverrideTypeINTEL = 1;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL:
    VkPerformanceOverrideTypeINTEL = 2;
pub const VkPerformanceOverrideTypeINTEL_VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL:
    VkPerformanceOverrideTypeINTEL = 2147483647;
pub type VkPerformanceOverrideTypeINTEL = ::std::os::raw::c_uint;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL : VkPerformanceParameterTypeINTEL = 0 ;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL : VkPerformanceParameterTypeINTEL = 1 ;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL:
    VkPerformanceParameterTypeINTEL = 0;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL:
    VkPerformanceParameterTypeINTEL = 1;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL:
    VkPerformanceParameterTypeINTEL = 2;
pub const VkPerformanceParameterTypeINTEL_VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL:
    VkPerformanceParameterTypeINTEL = 2147483647;
pub type VkPerformanceParameterTypeINTEL = ::std::os::raw::c_uint;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL:
    VkPerformanceValueTypeINTEL = 0;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL:
    VkPerformanceValueTypeINTEL = 1;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL:
    VkPerformanceValueTypeINTEL = 2;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL:
    VkPerformanceValueTypeINTEL = 3;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL:
    VkPerformanceValueTypeINTEL = 4;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL:
    VkPerformanceValueTypeINTEL = 0;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL:
    VkPerformanceValueTypeINTEL = 4;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL:
    VkPerformanceValueTypeINTEL = 5;
pub const VkPerformanceValueTypeINTEL_VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL:
    VkPerformanceValueTypeINTEL = 2147483647;
pub type VkPerformanceValueTypeINTEL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub valueFloat: f32,
    pub valueBool: VkBool32,
    pub valueString: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceValueDataINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceValueDataINTEL>(),
        8usize,
        concat!("Size of: ", stringify!(VkPerformanceValueDataINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceValueDataINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceValueDataINTEL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceValueDataINTEL>())).value32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueDataINTEL),
            "::",
            stringify!(value32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceValueDataINTEL>())).value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueDataINTEL),
            "::",
            stringify!(value64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceValueDataINTEL>())).valueFloat as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueDataINTEL),
            "::",
            stringify!(valueFloat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceValueDataINTEL>())).valueBool as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueDataINTEL),
            "::",
            stringify!(valueBool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceValueDataINTEL>())).valueString as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueDataINTEL),
            "::",
            stringify!(valueString)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceValueINTEL {
    pub type_: VkPerformanceValueTypeINTEL,
    pub data: VkPerformanceValueDataINTEL,
}
#[test]
fn bindgen_test_layout_VkPerformanceValueINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceValueINTEL>(),
        16usize,
        concat!("Size of: ", stringify!(VkPerformanceValueINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceValueINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceValueINTEL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceValueINTEL>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueINTEL),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkPerformanceValueINTEL>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceValueINTEL),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInitializePerformanceApiInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkInitializePerformanceApiInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkInitializePerformanceApiInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkInitializePerformanceApiInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInitializePerformanceApiInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkInitializePerformanceApiInfoINTEL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInitializePerformanceApiInfoINTEL>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInitializePerformanceApiInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInitializePerformanceApiInfoINTEL>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInitializePerformanceApiInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkInitializePerformanceApiInfoINTEL>())).pUserData as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkInitializePerformanceApiInfoINTEL),
            "::",
            stringify!(pUserData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolCreateInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
}
#[test]
fn bindgen_test_layout_VkQueryPoolCreateInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolCreateInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkQueryPoolCreateInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolCreateInfoINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkQueryPoolCreateInfoINTEL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolCreateInfoINTEL>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolCreateInfoINTEL>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkQueryPoolCreateInfoINTEL>())).performanceCountersSampling
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkQueryPoolCreateInfoINTEL),
            "::",
            stringify!(performanceCountersSampling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceMarkerInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub marker: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceMarkerInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceMarkerInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceMarkerInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceMarkerInfoINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceMarkerInfoINTEL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceMarkerInfoINTEL>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceMarkerInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceMarkerInfoINTEL>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceMarkerInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceMarkerInfoINTEL>())).marker as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceMarkerInfoINTEL),
            "::",
            stringify!(marker)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceStreamMarkerInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub marker: u32,
}
#[test]
fn bindgen_test_layout_VkPerformanceStreamMarkerInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceStreamMarkerInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceStreamMarkerInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceStreamMarkerInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceStreamMarkerInfoINTEL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceStreamMarkerInfoINTEL>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceStreamMarkerInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceStreamMarkerInfoINTEL>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceStreamMarkerInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceStreamMarkerInfoINTEL>())).marker as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceStreamMarkerInfoINTEL),
            "::",
            stringify!(marker)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceOverrideInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkPerformanceOverrideTypeINTEL,
    pub enable: VkBool32,
    pub parameter: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceOverrideInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceOverrideInfoINTEL>(),
        32usize,
        concat!("Size of: ", stringify!(VkPerformanceOverrideInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceOverrideInfoINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceOverrideInfoINTEL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceOverrideInfoINTEL>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceOverrideInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceOverrideInfoINTEL>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceOverrideInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceOverrideInfoINTEL>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceOverrideInfoINTEL),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceOverrideInfoINTEL>())).enable as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceOverrideInfoINTEL),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceOverrideInfoINTEL>())).parameter as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceOverrideInfoINTEL),
            "::",
            stringify!(parameter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkPerformanceConfigurationTypeINTEL,
}
#[test]
fn bindgen_test_layout_VkPerformanceConfigurationAcquireInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceConfigurationAcquireInfoINTEL>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceConfigurationAcquireInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceConfigurationAcquireInfoINTEL>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceConfigurationAcquireInfoINTEL>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPerformanceConfigurationAcquireInfoINTEL>())).type_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
            "::",
            stringify!(type_)
        )
    );
}
pub type PFN_vkInitializePerformanceApiINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkUninitializePerformanceApiINTEL =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice)>;
pub type PFN_vkCmdSetPerformanceMarkerINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkCmdSetPerformanceStreamMarkerINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkCmdSetPerformanceOverrideINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkAcquirePerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
        pConfiguration: *mut VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkReleasePerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkQueueSetPerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkGetPerformanceParameterINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        parameter: VkPerformanceParameterTypeINTEL,
        pValue: *mut VkPerformanceValueINTEL,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkInitializePerformanceApiINTEL(
        device: VkDevice,
        pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUninitializePerformanceApiINTEL(device: VkDevice);
}
extern "C" {
    pub fn vkCmdSetPerformanceMarkerINTEL(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSetPerformanceStreamMarkerINTEL(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSetPerformanceOverrideINTEL(
        commandBuffer: VkCommandBuffer,
        pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquirePerformanceConfigurationINTEL(
        device: VkDevice,
        pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
        pConfiguration: *mut VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkReleasePerformanceConfigurationINTEL(
        device: VkDevice,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueSetPerformanceConfigurationINTEL(
        queue: VkQueue,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPerformanceParameterINTEL(
        device: VkDevice,
        parameter: VkPerformanceParameterTypeINTEL,
        pValue: *mut VkPerformanceValueINTEL,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pciDomain: u32,
    pub pciBus: u32,
    pub pciDevice: u32,
    pub pciFunction: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePCIBusInfoPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePCIBusInfoPropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePCIBusInfoPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).pciDomain
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(pciDomain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).pciBus as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(pciBus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).pciDevice
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(pciDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDevicePCIBusInfoPropertiesEXT>())).pciFunction
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
            "::",
            stringify!(pciFunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub localDimmingSupport: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayNativeHdrSurfaceCapabilitiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>())).localDimmingSupport
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
            "::",
            stringify!(localDimmingSupport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub localDimmingEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSwapchainDisplayNativeHdrCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainDisplayNativeHdrCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainDisplayNativeHdrCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainDisplayNativeHdrCreateInfoAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainDisplayNativeHdrCreateInfoAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkSwapchainDisplayNativeHdrCreateInfoAMD>())).localDimmingEnable
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
            "::",
            stringify!(localDimmingEnable)
        )
    );
}
pub type PFN_vkSetLocalDimmingAMD = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32),
>;
extern "C" {
    pub fn vkSetLocalDimmingAMD(
        device: VkDevice,
        swapChain: VkSwapchainKHR,
        localDimmingEnable: VkBool32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentDensityMap: VkBool32,
    pub fragmentDensityMapDynamic: VkBool32,
    pub fragmentDensityMapNonSubsampledImages: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>()))
                .fragmentDensityMap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
            "::",
            stringify!(fragmentDensityMap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>()))
                .fragmentDensityMapDynamic as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
            "::",
            stringify!(fragmentDensityMapDynamic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>()))
                .fragmentDensityMapNonSubsampledImages as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
            "::",
            stringify!(fragmentDensityMapNonSubsampledImages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minFragmentDensityTexelSize: VkExtent2D,
    pub maxFragmentDensityTexelSize: VkExtent2D,
    pub fragmentDensityInvocations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>()))
                .minFragmentDensityTexelSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
            "::",
            stringify!(minFragmentDensityTexelSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>()))
                .maxFragmentDensityTexelSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
            "::",
            stringify!(maxFragmentDensityTexelSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>()))
                .fragmentDensityInvocations as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
            "::",
            stringify!(fragmentDensityInvocations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassFragmentDensityMapCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fragmentDensityMapAttachment: VkAttachmentReference,
}
#[test]
fn bindgen_test_layout_VkRenderPassFragmentDensityMapCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassFragmentDensityMapCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassFragmentDensityMapCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassFragmentDensityMapCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassFragmentDensityMapCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkRenderPassFragmentDensityMapCreateInfoEXT>()))
                .fragmentDensityMapAttachment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
            "::",
            stringify!(fragmentDensityMapAttachment)
        )
    );
}
pub type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subgroupSizeControl: VkBool32,
    pub computeFullSubgroups: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>()))
                .subgroupSizeControl as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT),
            "::",
            stringify!(subgroupSizeControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>()))
                .computeFullSubgroups as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT),
            "::",
            stringify!(computeFullSubgroups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minSubgroupSize: u32,
    pub maxSubgroupSize: u32,
    pub maxComputeWorkgroupSubgroups: u32,
    pub requiredSubgroupSizeStages: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>()))
                .minSubgroupSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(minSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>()))
                .maxSubgroupSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(maxSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>()))
                .maxComputeWorkgroupSubgroups as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(maxComputeWorkgroupSubgroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>()))
                .requiredSubgroupSizeStages as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT),
            "::",
            stringify!(requiredSubgroupSizeStages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub requiredSubgroupSize: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>()))
                .requiredSubgroupSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT),
            "::",
            stringify!(requiredSubgroupSize)
        )
    );
}
pub const VkShaderCorePropertiesFlagBitsAMD_VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD:
    VkShaderCorePropertiesFlagBitsAMD = 2147483647;
pub type VkShaderCorePropertiesFlagBitsAMD = ::std::os::raw::c_uint;
pub type VkShaderCorePropertiesFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCoreProperties2AMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD,
    pub activeComputeUnitCount: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCoreProperties2AMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCoreProperties2AMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCoreProperties2AMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCoreProperties2AMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCoreProperties2AMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCoreProperties2AMD>())).shaderCoreFeatures
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
            "::",
            stringify!(shaderCoreFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderCoreProperties2AMD>()))
                .activeComputeUnitCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
            "::",
            stringify!(activeComputeUnitCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceCoherentMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCoherentMemoryFeaturesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>()))
                .deviceCoherentMemory as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
            "::",
            stringify!(deviceCoherentMemory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub heapBudget: [VkDeviceSize; 16usize],
    pub heapUsage: [VkDeviceSize; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryBudgetPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(),
        272usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>())).heapBudget
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
            "::",
            stringify!(heapBudget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>())).heapUsage
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
            "::",
            stringify!(heapUsage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryPriority: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryPriorityFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>())).memoryPriority
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
            "::",
            stringify!(memoryPriority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryPriorityAllocateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub priority: f32,
}
#[test]
fn bindgen_test_layout_VkMemoryPriorityAllocateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryPriorityAllocateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryPriorityAllocateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryPriorityAllocateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryPriorityAllocateInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryPriorityAllocateInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryPriorityAllocateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryPriorityAllocateInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryPriorityAllocateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkMemoryPriorityAllocateInfoEXT>())).priority as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkMemoryPriorityAllocateInfoEXT),
            "::",
            stringify!(priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub dedicatedAllocationImageAliasing: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>()))
                .sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>()))
                .pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>()))
                .dedicatedAllocationImageAliasing as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
            "::",
            stringify!(dedicatedAllocationImageAliasing)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>()))
                .bufferDeviceAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
            "::",
            stringify!(bufferDeviceAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>()))
                .bufferDeviceAddressCaptureReplay as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
            "::",
            stringify!(bufferDeviceAddressCaptureReplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>()))
                .bufferDeviceAddressMultiDevice as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
            "::",
            stringify!(bufferDeviceAddressMultiDevice)
        )
    );
}
pub type VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub type VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferDeviceAddressCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceAddress: VkDeviceAddress,
}
#[test]
fn bindgen_test_layout_VkBufferDeviceAddressCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferDeviceAddressCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferDeviceAddressCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferDeviceAddressCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBufferDeviceAddressCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferDeviceAddressCreateInfoEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferDeviceAddressCreateInfoEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkBufferDeviceAddressCreateInfoEXT>())).deviceAddress as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkBufferDeviceAddressCreateInfoEXT),
            "::",
            stringify!(deviceAddress)
        )
    );
}
pub type PFN_vkGetBufferDeviceAddressEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
extern "C" {
    pub fn vkGetBufferDeviceAddressEXT(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_VALIDATION_BIT_EXT: VkToolPurposeFlagBitsEXT = 1;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_PROFILING_BIT_EXT: VkToolPurposeFlagBitsEXT = 2;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_TRACING_BIT_EXT: VkToolPurposeFlagBitsEXT = 4;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT:
    VkToolPurposeFlagBitsEXT = 8;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT:
    VkToolPurposeFlagBitsEXT = 16;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT:
    VkToolPurposeFlagBitsEXT = 32;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT: VkToolPurposeFlagBitsEXT =
    64;
pub const VkToolPurposeFlagBitsEXT_VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT:
    VkToolPurposeFlagBitsEXT = 2147483647;
pub type VkToolPurposeFlagBitsEXT = ::std::os::raw::c_uint;
pub type VkToolPurposeFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPhysicalDeviceToolPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub version: [::std::os::raw::c_char; 256usize],
    pub purposes: VkToolPurposeFlagsEXT,
    pub description: [::std::os::raw::c_char; 256usize],
    pub layer: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceToolPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceToolPropertiesEXT>(),
        1048usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceToolPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceToolPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).version as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).purposes as *const _
                as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(purposes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).description as *const _
                as usize
        },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceToolPropertiesEXT>())).layer as *const _ as usize
        },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceToolPropertiesEXT),
            "::",
            stringify!(layer)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceToolPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolPropertiesEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceToolPropertiesEXT(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolPropertiesEXT,
    ) -> VkResult;
}
pub type VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT:
    VkValidationFeatureEnableEXT = 0;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT : VkValidationFeatureEnableEXT = 1 ;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT:
    VkValidationFeatureEnableEXT = 2;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT:
    VkValidationFeatureEnableEXT = 0;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_END_RANGE_EXT:
    VkValidationFeatureEnableEXT = 2;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT:
    VkValidationFeatureEnableEXT = 3;
pub const VkValidationFeatureEnableEXT_VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT:
    VkValidationFeatureEnableEXT = 2147483647;
pub type VkValidationFeatureEnableEXT = ::std::os::raw::c_uint;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_ALL_EXT:
    VkValidationFeatureDisableEXT = 0;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT:
    VkValidationFeatureDisableEXT = 1;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT:
    VkValidationFeatureDisableEXT = 2;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT:
    VkValidationFeatureDisableEXT = 3;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT:
    VkValidationFeatureDisableEXT = 4;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT:
    VkValidationFeatureDisableEXT = 5;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT:
    VkValidationFeatureDisableEXT = 6;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT:
    VkValidationFeatureDisableEXT = 0;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_END_RANGE_EXT:
    VkValidationFeatureDisableEXT = 6;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT:
    VkValidationFeatureDisableEXT = 7;
pub const VkValidationFeatureDisableEXT_VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT:
    VkValidationFeatureDisableEXT = 2147483647;
pub type VkValidationFeatureDisableEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub enabledValidationFeatureCount: u32,
    pub pEnabledValidationFeatures: *const VkValidationFeatureEnableEXT,
    pub disabledValidationFeatureCount: u32,
    pub pDisabledValidationFeatures: *const VkValidationFeatureDisableEXT,
}
#[test]
fn bindgen_test_layout_VkValidationFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationFeaturesEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkValidationFeaturesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationFeaturesEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationFeaturesEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).enabledValidationFeatureCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(enabledValidationFeatureCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).pEnabledValidationFeatures
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(pEnabledValidationFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).disabledValidationFeatureCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(disabledValidationFeatureCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkValidationFeaturesEXT>())).pDisabledValidationFeatures
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkValidationFeaturesEXT),
            "::",
            stringify!(pDisabledValidationFeatures)
        )
    );
}
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeNV = 0;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeNV = 1;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeNV = 2;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeNV = 3;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeNV = 4;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeNV = 5;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeNV = 6;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeNV = 7;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeNV = 8;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeNV = 9;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeNV = 10;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_BEGIN_RANGE_NV: VkComponentTypeNV = 0;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_END_RANGE_NV: VkComponentTypeNV = 10;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_RANGE_SIZE_NV: VkComponentTypeNV = 11;
pub const VkComponentTypeNV_VK_COMPONENT_TYPE_MAX_ENUM_NV: VkComponentTypeNV = 2147483647;
pub type VkComponentTypeNV = ::std::os::raw::c_uint;
pub const VkScopeNV_VK_SCOPE_DEVICE_NV: VkScopeNV = 1;
pub const VkScopeNV_VK_SCOPE_WORKGROUP_NV: VkScopeNV = 2;
pub const VkScopeNV_VK_SCOPE_SUBGROUP_NV: VkScopeNV = 3;
pub const VkScopeNV_VK_SCOPE_QUEUE_FAMILY_NV: VkScopeNV = 5;
pub const VkScopeNV_VK_SCOPE_BEGIN_RANGE_NV: VkScopeNV = 1;
pub const VkScopeNV_VK_SCOPE_END_RANGE_NV: VkScopeNV = 5;
pub const VkScopeNV_VK_SCOPE_RANGE_SIZE_NV: VkScopeNV = 5;
pub const VkScopeNV_VK_SCOPE_MAX_ENUM_NV: VkScopeNV = 2147483647;
pub type VkScopeNV = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCooperativeMatrixPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub MSize: u32,
    pub NSize: u32,
    pub KSize: u32,
    pub AType: VkComponentTypeNV,
    pub BType: VkComponentTypeNV,
    pub CType: VkComponentTypeNV,
    pub DType: VkComponentTypeNV,
    pub scope: VkScopeNV,
}
#[test]
fn bindgen_test_layout_VkCooperativeMatrixPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCooperativeMatrixPropertiesNV>(),
        48usize,
        concat!("Size of: ", stringify!(VkCooperativeMatrixPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCooperativeMatrixPropertiesNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCooperativeMatrixPropertiesNV))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).MSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(MSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).NSize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(NSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).KSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(KSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).AType as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(AType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).BType as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(BType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).CType as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(CType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).DType as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(DType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkCooperativeMatrixPropertiesNV>())).scope as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VkCooperativeMatrixPropertiesNV),
            "::",
            stringify!(scope)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cooperativeMatrix: VkBool32,
    pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCooperativeMatrixFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>()))
                .cooperativeMatrix as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
            "::",
            stringify!(cooperativeMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>()))
                .cooperativeMatrixRobustBufferAccess as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
            "::",
            stringify!(cooperativeMatrixRobustBufferAccess)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCooperativeMatrixPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>()))
                .cooperativeMatrixSupportedStages as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
            "::",
            stringify!(cooperativeMatrixSupportedStages)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkCooperativeMatrixPropertiesNV,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkCooperativeMatrixPropertiesNV,
    ) -> VkResult;
}
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_MERGE_NV: VkCoverageReductionModeNV =
    0;
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV:
    VkCoverageReductionModeNV = 1;
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV:
    VkCoverageReductionModeNV = 0;
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_END_RANGE_NV:
    VkCoverageReductionModeNV = 1;
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV:
    VkCoverageReductionModeNV = 2;
pub const VkCoverageReductionModeNV_VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV:
    VkCoverageReductionModeNV = 2147483647;
pub type VkCoverageReductionModeNV = ::std::os::raw::c_uint;
pub type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub coverageReductionMode: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCoverageReductionModeFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>()))
                .coverageReductionMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
            "::",
            stringify!(coverageReductionMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageReductionStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageReductionStateCreateFlagsNV,
    pub coverageReductionMode: VkCoverageReductionModeNV,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageReductionStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageReductionStateCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageReductionStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageReductionStateCreateInfoNV>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageReductionStateCreateInfoNV>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageReductionStateCreateInfoNV>())).flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineCoverageReductionStateCreateInfoNV>()))
                .coverageReductionMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
            "::",
            stringify!(coverageReductionMode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferMixedSamplesCombinationNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub coverageReductionMode: VkCoverageReductionModeNV,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub depthStencilSamples: VkSampleCountFlags,
    pub colorSamples: VkSampleCountFlags,
}
#[test]
fn bindgen_test_layout_VkFramebufferMixedSamplesCombinationNV() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferMixedSamplesCombinationNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferMixedSamplesCombinationNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferMixedSamplesCombinationNV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).coverageReductionMode
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(coverageReductionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).rasterizationSamples
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(rasterizationSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).depthStencilSamples
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(depthStencilSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkFramebufferMixedSamplesCombinationNV>())).colorSamples
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV),
            "::",
            stringify!(colorSamples)
        )
    );
}
pub type PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV =
    ::std::option::Option<
        unsafe extern "C" fn(
            physicalDevice: VkPhysicalDevice,
            pCombinationCount: *mut u32,
            pCombinations: *mut VkFramebufferMixedSamplesCombinationNV,
        ) -> VkResult,
    >;
extern "C" {
    pub fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
        physicalDevice: VkPhysicalDevice,
        pCombinationCount: *mut u32,
        pCombinations: *mut VkFramebufferMixedSamplesCombinationNV,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentShaderSampleInterlock: VkBool32,
    pub fragmentShaderPixelInterlock: VkBool32,
    pub fragmentShaderShadingRateInterlock: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>()))
                .fragmentShaderSampleInterlock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
            "::",
            stringify!(fragmentShaderSampleInterlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>()))
                .fragmentShaderPixelInterlock as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
            "::",
            stringify!(fragmentShaderPixelInterlock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>()))
                .fragmentShaderShadingRateInterlock as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
            "::",
            stringify!(fragmentShaderShadingRateInterlock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub ycbcrImageArrays: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>())).ycbcrImageArrays
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
            "::",
            stringify!(ycbcrImageArrays)
        )
    );
}
pub type VkHeadlessSurfaceCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkHeadlessSurfaceCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkHeadlessSurfaceCreateFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkHeadlessSurfaceCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkHeadlessSurfaceCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkHeadlessSurfaceCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkHeadlessSurfaceCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkHeadlessSurfaceCreateInfoEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHeadlessSurfaceCreateInfoEXT>())).sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHeadlessSurfaceCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHeadlessSurfaceCreateInfoEXT>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHeadlessSurfaceCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkHeadlessSurfaceCreateInfoEXT>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkHeadlessSurfaceCreateInfoEXT),
            "::",
            stringify!(flags)
        )
    );
}
pub type PFN_vkCreateHeadlessSurfaceEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateHeadlessSurfaceEXT(
        instance: VkInstance,
        pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT:
    VkLineRasterizationModeEXT = 0;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT:
    VkLineRasterizationModeEXT = 1;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT:
    VkLineRasterizationModeEXT = 2;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT:
    VkLineRasterizationModeEXT = 3;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT:
    VkLineRasterizationModeEXT = 0;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_END_RANGE_EXT:
    VkLineRasterizationModeEXT = 3;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT:
    VkLineRasterizationModeEXT = 4;
pub const VkLineRasterizationModeEXT_VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT:
    VkLineRasterizationModeEXT = 2147483647;
pub type VkLineRasterizationModeEXT = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rectangularLines: VkBool32,
    pub bresenhamLines: VkBool32,
    pub smoothLines: VkBool32,
    pub stippledRectangularLines: VkBool32,
    pub stippledBresenhamLines: VkBool32,
    pub stippledSmoothLines: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLineRasterizationFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLineRasterizationFeaturesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLineRasterizationFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>()))
                .rectangularLines as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(rectangularLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>())).bresenhamLines
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(bresenhamLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>())).smoothLines
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(smoothLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>()))
                .stippledRectangularLines as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(stippledRectangularLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>()))
                .stippledBresenhamLines as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(stippledBresenhamLines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationFeaturesEXT>()))
                .stippledSmoothLines as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
            "::",
            stringify!(stippledSmoothLines)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub lineSubPixelPrecisionBits: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLineRasterizationPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLineRasterizationPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLineRasterizationPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceLineRasterizationPropertiesEXT>()))
                .lineSubPixelPrecisionBits as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
            "::",
            stringify!(lineSubPixelPrecisionBits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationLineStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub lineRasterizationMode: VkLineRasterizationModeEXT,
    pub stippledLineEnable: VkBool32,
    pub lineStippleFactor: u32,
    pub lineStipplePattern: u16,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationLineStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationLineStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationLineStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>()))
                .lineRasterizationMode as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(lineRasterizationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>()))
                .stippledLineEnable as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(stippledLineEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>()))
                .lineStippleFactor as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(lineStippleFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPipelineRasterizationLineStateCreateInfoEXT>()))
                .lineStipplePattern as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
            "::",
            stringify!(lineStipplePattern)
        )
    );
}
pub type PFN_vkCmdSetLineStippleEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        lineStippleFactor: u32,
        lineStipplePattern: u16,
    ),
>;
extern "C" {
    pub fn vkCmdSetLineStippleEXT(
        commandBuffer: VkCommandBuffer,
        lineStippleFactor: u32,
        lineStipplePattern: u16,
    );
}
pub type VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
pub type PFN_vkResetQueryPoolEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
extern "C" {
    pub fn vkResetQueryPoolEXT(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub indexTypeUint8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceIndexTypeUint8FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>())).sType as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>())).indexTypeUint8
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
            "::",
            stringify!(indexTypeUint8)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderDemoteToHelperInvocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>()))
                .sType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>()))
                .pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>()))
                .shaderDemoteToHelperInvocation as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT),
            "::",
            stringify!(shaderDemoteToHelperInvocation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub texelBufferAlignment: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>()))
                .texelBufferAlignment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
            "::",
            stringify!(texelBufferAlignment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
    pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>())).sType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>())).pNext
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>()))
                .storageTexelBufferOffsetAlignmentBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(storageTexelBufferOffsetAlignmentBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>()))
                .storageTexelBufferOffsetSingleTexelAlignment as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(storageTexelBufferOffsetSingleTexelAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>()))
                .uniformTexelBufferOffsetAlignmentBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(uniformTexelBufferOffsetAlignmentBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>()))
                .uniformTexelBufferOffsetSingleTexelAlignment as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT),
            "::",
            stringify!(uniformTexelBufferOffsetSingleTexelAlignment)
        )
    );
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_iterator_t {
    pub data: *mut ::std::os::raw::c_void,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_generic_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_raw_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_xcb_raw_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_raw_generic_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_raw_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_raw_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).response_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).event_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_event_t>())).full_sequence as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub resource_id: u32,
    pub minor_code: u16,
    pub major_code: u8,
    pub pad0: u8,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_generic_error_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_generic_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).resource_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).minor_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(minor_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).major_code as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_generic_error_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_generic_error_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_void_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_void_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_void_cookie_t>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_void_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_t>(),
        2usize,
        concat!("Size of: ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_t>())).byte1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_t>())).byte2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_char2b_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_char2b_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_char2b_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_window_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_window_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_window_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_window_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_pixmap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_pixmap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_pixmap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_pixmap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_cursor_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_cursor_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_cursor_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_cursor_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_font_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_font_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_font_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_font_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_gcontext_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_gcontext_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gcontext_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gcontext_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_colormap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_colormap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_atom_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_atom_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_atom_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_atom_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_drawable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_drawable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_drawable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_drawable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_fontable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_bool32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_bool32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bool32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bool32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_visualid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualid_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualid_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualid_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_timestamp_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timestamp_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timestamp_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timestamp_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keysym_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keysym_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keysym_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keysym_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keycode32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keycode32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keycode32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_button_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_button_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_point_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_point_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_point_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_point_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_point_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rectangle_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rectangle_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rectangle_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).angle1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_t>())).angle2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_arc_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_arc_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_arc_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_format_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_format_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).bits_per_pixel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).scanline_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_t>())).pad0 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_format_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_format_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_format_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_GRAY: xcb_visual_class_t = 0;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_GRAY_SCALE: xcb_visual_class_t = 1;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_COLOR: xcb_visual_class_t = 2;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_PSEUDO_COLOR: xcb_visual_class_t = 3;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_TRUE_COLOR: xcb_visual_class_t = 4;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_DIRECT_COLOR: xcb_visual_class_t = 5;
pub type xcb_visual_class_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).visual_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(visual_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>()))._class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visualtype_t>())).bits_per_rgb_value as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(bits_per_rgb_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visualtype_t>())).colormap_entries as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(colormap_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).red_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).green_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).blue_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visualtype_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visualtype_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_visualtype_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).visuals_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(visuals_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_t>())).pad1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_depth_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_depth_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_depth_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_event_mask_t_XCB_EVENT_MASK_NO_EVENT: xcb_event_mask_t = 0;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_PRESS: xcb_event_mask_t = 1;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_RELEASE: xcb_event_mask_t = 2;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_PRESS: xcb_event_mask_t = 4;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_RELEASE: xcb_event_mask_t = 8;
pub const xcb_event_mask_t_XCB_EVENT_MASK_ENTER_WINDOW: xcb_event_mask_t = 16;
pub const xcb_event_mask_t_XCB_EVENT_MASK_LEAVE_WINDOW: xcb_event_mask_t = 32;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION: xcb_event_mask_t = 64;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION_HINT: xcb_event_mask_t = 128;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_1_MOTION: xcb_event_mask_t = 256;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_2_MOTION: xcb_event_mask_t = 512;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_3_MOTION: xcb_event_mask_t = 1024;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_4_MOTION: xcb_event_mask_t = 2048;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_5_MOTION: xcb_event_mask_t = 4096;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_MOTION: xcb_event_mask_t = 8192;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEYMAP_STATE: xcb_event_mask_t = 16384;
pub const xcb_event_mask_t_XCB_EVENT_MASK_EXPOSURE: xcb_event_mask_t = 32768;
pub const xcb_event_mask_t_XCB_EVENT_MASK_VISIBILITY_CHANGE: xcb_event_mask_t = 65536;
pub const xcb_event_mask_t_XCB_EVENT_MASK_STRUCTURE_NOTIFY: xcb_event_mask_t = 131072;
pub const xcb_event_mask_t_XCB_EVENT_MASK_RESIZE_REDIRECT: xcb_event_mask_t = 262144;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY: xcb_event_mask_t = 524288;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT: xcb_event_mask_t = 1048576;
pub const xcb_event_mask_t_XCB_EVENT_MASK_FOCUS_CHANGE: xcb_event_mask_t = 2097152;
pub const xcb_event_mask_t_XCB_EVENT_MASK_PROPERTY_CHANGE: xcb_event_mask_t = 4194304;
pub const xcb_event_mask_t_XCB_EVENT_MASK_COLOR_MAP_CHANGE: xcb_event_mask_t = 8388608;
pub const xcb_event_mask_t_XCB_EVENT_MASK_OWNER_GRAB_BUTTON: xcb_event_mask_t = 16777216;
pub type xcb_event_mask_t = ::std::os::raw::c_uint;
pub const xcb_backing_store_t_XCB_BACKING_STORE_NOT_USEFUL: xcb_backing_store_t = 0;
pub const xcb_backing_store_t_XCB_BACKING_STORE_WHEN_MAPPED: xcb_backing_store_t = 1;
pub const xcb_backing_store_t_XCB_BACKING_STORE_ALWAYS: xcb_backing_store_t = 2;
pub type xcb_backing_store_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).default_colormap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(default_colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).white_pixel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).black_pixel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).current_input_masks as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(current_input_masks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).width_in_pixels as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).height_in_pixels as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_pixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).width_in_millimeters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_millimeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_screen_t>())).height_in_millimeters as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_millimeters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).min_installed_maps as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(min_installed_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).max_installed_maps as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(max_installed_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root_visual as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).backing_stores as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(backing_stores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).save_unders as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).root_depth as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_t>())).allowed_depths_len as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(allowed_depths_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_screen_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_screen_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_screen_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).byte_order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).authorization_protocol_name_len
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_t>())).authorization_protocol_data_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_request_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_request_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_request_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).reason_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(reason_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_failed_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_failed_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_failed_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_authenticate_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_authenticate_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_authenticate_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_setup_authenticate_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_authenticate_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_image_order_t_XCB_IMAGE_ORDER_LSB_FIRST: xcb_image_order_t = 0;
pub const xcb_image_order_t_XCB_IMAGE_ORDER_MSB_FIRST: xcb_image_order_t = 1;
pub type xcb_image_order_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).protocol_major_version as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).protocol_minor_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).release_number as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).resource_id_base as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).resource_id_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).motion_buffer_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(motion_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).vendor_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(vendor_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).maximum_request_length as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(maximum_request_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).roots_len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(roots_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pixmap_formats_len as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pixmap_formats_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).image_byte_order as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(image_byte_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_bit_order as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_bit_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_unit as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_pad as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).min_keycode as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).max_keycode as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_t>())).pad1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_setup_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_setup_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_setup_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_mod_mask_t_XCB_MOD_MASK_SHIFT: xcb_mod_mask_t = 1;
pub const xcb_mod_mask_t_XCB_MOD_MASK_LOCK: xcb_mod_mask_t = 2;
pub const xcb_mod_mask_t_XCB_MOD_MASK_CONTROL: xcb_mod_mask_t = 4;
pub const xcb_mod_mask_t_XCB_MOD_MASK_1: xcb_mod_mask_t = 8;
pub const xcb_mod_mask_t_XCB_MOD_MASK_2: xcb_mod_mask_t = 16;
pub const xcb_mod_mask_t_XCB_MOD_MASK_3: xcb_mod_mask_t = 32;
pub const xcb_mod_mask_t_XCB_MOD_MASK_4: xcb_mod_mask_t = 64;
pub const xcb_mod_mask_t_XCB_MOD_MASK_5: xcb_mod_mask_t = 128;
pub const xcb_mod_mask_t_XCB_MOD_MASK_ANY: xcb_mod_mask_t = 32768;
pub type xcb_mod_mask_t = ::std::os::raw::c_uint;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_SHIFT: xcb_key_but_mask_t = 1;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_LOCK: xcb_key_but_mask_t = 2;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_CONTROL: xcb_key_but_mask_t = 4;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_1: xcb_key_but_mask_t = 8;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_2: xcb_key_but_mask_t = 16;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_3: xcb_key_but_mask_t = 32;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_4: xcb_key_but_mask_t = 64;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_5: xcb_key_but_mask_t = 128;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_1: xcb_key_but_mask_t = 256;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_2: xcb_key_but_mask_t = 512;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_3: xcb_key_but_mask_t = 1024;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_4: xcb_key_but_mask_t = 2048;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_5: xcb_key_but_mask_t = 4096;
pub type xcb_key_but_mask_t = ::std::os::raw::c_uint;
pub const xcb_window_enum_t_XCB_WINDOW_NONE: xcb_window_enum_t = 0;
pub type xcb_window_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_key_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_key_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_key_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).event_y as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_key_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_key_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_1: xcb_button_mask_t = 256;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_2: xcb_button_mask_t = 512;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_3: xcb_button_mask_t = 1024;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_4: xcb_button_mask_t = 2048;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_5: xcb_button_mask_t = 4096;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_ANY: xcb_button_mask_t = 32768;
pub type xcb_button_mask_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_button_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_button_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_button_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_button_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
pub const xcb_motion_t_XCB_MOTION_NORMAL: xcb_motion_t = 0;
pub const xcb_motion_t_XCB_MOTION_HINT: xcb_motion_t = 1;
pub type xcb_motion_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_motion_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_motion_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).detail as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).root_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_motion_notify_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_ANCESTOR: xcb_notify_detail_t = 0;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_VIRTUAL: xcb_notify_detail_t = 1;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_INFERIOR: xcb_notify_detail_t = 2;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR: xcb_notify_detail_t = 3;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL: xcb_notify_detail_t = 4;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER: xcb_notify_detail_t = 5;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER_ROOT: xcb_notify_detail_t = 6;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONE: xcb_notify_detail_t = 7;
pub type xcb_notify_detail_t = ::std::os::raw::c_uint;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_NORMAL: xcb_notify_mode_t = 0;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_GRAB: xcb_notify_mode_t = 1;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_UNGRAB: xcb_notify_mode_t = 2;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_WHILE_GRABBED: xcb_notify_mode_t = 3;
pub type xcb_notify_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_enter_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_enter_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).mode as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_enter_notify_event_t>())).same_screen_focus as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(same_screen_focus)
        )
    );
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_focus_in_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_focus_in_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_focus_in_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_focus_in_event_t>())).pad0 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_keymap_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_keymap_notify_event_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_keymap_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_keymap_notify_event_t>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_expose_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_expose_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_expose_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_expose_event_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_graphics_exposure_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_graphics_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).minor_opcode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).major_opcode as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_graphics_exposure_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_no_exposure_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_exposure_event_t>())).pad1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_visibility_t_XCB_VISIBILITY_UNOBSCURED: xcb_visibility_t = 0;
pub const xcb_visibility_t_XCB_VISIBILITY_PARTIALLY_OBSCURED: xcb_visibility_t = 1;
pub const xcb_visibility_t_XCB_VISIBILITY_FULLY_OBSCURED: xcb_visibility_t = 2;
pub type xcb_visibility_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_visibility_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_visibility_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_visibility_notify_event_t>())).pad1 as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_notify_event_t>())).override_redirect as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_notify_event_t>())).pad1 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).from_configure as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(from_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_notify_event_t>())).override_redirect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_request_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).parent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_request_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).parent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).override_redirect as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_notify_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_notify_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).above_sibling as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(above_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).override_redirect as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_notify_event_t>())).pad1 as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).stack_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(stack_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).sibling as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_request_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_configure_request_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_request_event_t>())).value_mask as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_gravity_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_gravity_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_gravity_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_resize_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_resize_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_resize_request_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_resize_request_event_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(height)
        )
    );
}
pub const xcb_place_t_XCB_PLACE_ON_TOP: xcb_place_t = 0;
pub const xcb_place_t_XCB_PLACE_ON_BOTTOM: xcb_place_t = 1;
pub type xcb_place_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).place as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(place)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_notify_event_t>())).pad2 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad2)
        )
    );
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
pub const xcb_property_t_XCB_PROPERTY_NEW_VALUE: xcb_property_t = 0;
pub const xcb_property_t_XCB_PROPERTY_DELETE: xcb_property_t = 1;
pub type xcb_property_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_property_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_property_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).atom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_property_notify_event_t>())).pad1 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_clear_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_clear_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_clear_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(selection)
        )
    );
}
pub const xcb_time_t_XCB_TIME_CURRENT_TIME: xcb_time_t = 0;
pub type xcb_time_t = ::std::os::raw::c_uint;
pub const xcb_atom_enum_t_XCB_ATOM_NONE: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_PRIMARY: xcb_atom_enum_t = 1;
pub const xcb_atom_enum_t_XCB_ATOM_SECONDARY: xcb_atom_enum_t = 2;
pub const xcb_atom_enum_t_XCB_ATOM_ARC: xcb_atom_enum_t = 3;
pub const xcb_atom_enum_t_XCB_ATOM_ATOM: xcb_atom_enum_t = 4;
pub const xcb_atom_enum_t_XCB_ATOM_BITMAP: xcb_atom_enum_t = 5;
pub const xcb_atom_enum_t_XCB_ATOM_CARDINAL: xcb_atom_enum_t = 6;
pub const xcb_atom_enum_t_XCB_ATOM_COLORMAP: xcb_atom_enum_t = 7;
pub const xcb_atom_enum_t_XCB_ATOM_CURSOR: xcb_atom_enum_t = 8;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER0: xcb_atom_enum_t = 9;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER1: xcb_atom_enum_t = 10;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER2: xcb_atom_enum_t = 11;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER3: xcb_atom_enum_t = 12;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER4: xcb_atom_enum_t = 13;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER5: xcb_atom_enum_t = 14;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER6: xcb_atom_enum_t = 15;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER7: xcb_atom_enum_t = 16;
pub const xcb_atom_enum_t_XCB_ATOM_DRAWABLE: xcb_atom_enum_t = 17;
pub const xcb_atom_enum_t_XCB_ATOM_FONT: xcb_atom_enum_t = 18;
pub const xcb_atom_enum_t_XCB_ATOM_INTEGER: xcb_atom_enum_t = 19;
pub const xcb_atom_enum_t_XCB_ATOM_PIXMAP: xcb_atom_enum_t = 20;
pub const xcb_atom_enum_t_XCB_ATOM_POINT: xcb_atom_enum_t = 21;
pub const xcb_atom_enum_t_XCB_ATOM_RECTANGLE: xcb_atom_enum_t = 22;
pub const xcb_atom_enum_t_XCB_ATOM_RESOURCE_MANAGER: xcb_atom_enum_t = 23;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_COLOR_MAP: xcb_atom_enum_t = 24;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BEST_MAP: xcb_atom_enum_t = 25;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BLUE_MAP: xcb_atom_enum_t = 26;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_DEFAULT_MAP: xcb_atom_enum_t = 27;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GRAY_MAP: xcb_atom_enum_t = 28;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GREEN_MAP: xcb_atom_enum_t = 29;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_RED_MAP: xcb_atom_enum_t = 30;
pub const xcb_atom_enum_t_XCB_ATOM_STRING: xcb_atom_enum_t = 31;
pub const xcb_atom_enum_t_XCB_ATOM_VISUALID: xcb_atom_enum_t = 32;
pub const xcb_atom_enum_t_XCB_ATOM_WINDOW: xcb_atom_enum_t = 33;
pub const xcb_atom_enum_t_XCB_ATOM_WM_COMMAND: xcb_atom_enum_t = 34;
pub const xcb_atom_enum_t_XCB_ATOM_WM_HINTS: xcb_atom_enum_t = 35;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLIENT_MACHINE: xcb_atom_enum_t = 36;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_NAME: xcb_atom_enum_t = 37;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_SIZE: xcb_atom_enum_t = 38;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NAME: xcb_atom_enum_t = 39;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NORMAL_HINTS: xcb_atom_enum_t = 40;
pub const xcb_atom_enum_t_XCB_ATOM_WM_SIZE_HINTS: xcb_atom_enum_t = 41;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ZOOM_HINTS: xcb_atom_enum_t = 42;
pub const xcb_atom_enum_t_XCB_ATOM_MIN_SPACE: xcb_atom_enum_t = 43;
pub const xcb_atom_enum_t_XCB_ATOM_NORM_SPACE: xcb_atom_enum_t = 44;
pub const xcb_atom_enum_t_XCB_ATOM_MAX_SPACE: xcb_atom_enum_t = 45;
pub const xcb_atom_enum_t_XCB_ATOM_END_SPACE: xcb_atom_enum_t = 46;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_X: xcb_atom_enum_t = 47;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_Y: xcb_atom_enum_t = 48;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_X: xcb_atom_enum_t = 49;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_Y: xcb_atom_enum_t = 50;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_POSITION: xcb_atom_enum_t = 51;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_THICKNESS: xcb_atom_enum_t = 52;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_ASCENT: xcb_atom_enum_t = 53;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_DESCENT: xcb_atom_enum_t = 54;
pub const xcb_atom_enum_t_XCB_ATOM_ITALIC_ANGLE: xcb_atom_enum_t = 55;
pub const xcb_atom_enum_t_XCB_ATOM_X_HEIGHT: xcb_atom_enum_t = 56;
pub const xcb_atom_enum_t_XCB_ATOM_QUAD_WIDTH: xcb_atom_enum_t = 57;
pub const xcb_atom_enum_t_XCB_ATOM_WEIGHT: xcb_atom_enum_t = 58;
pub const xcb_atom_enum_t_XCB_ATOM_POINT_SIZE: xcb_atom_enum_t = 59;
pub const xcb_atom_enum_t_XCB_ATOM_RESOLUTION: xcb_atom_enum_t = 60;
pub const xcb_atom_enum_t_XCB_ATOM_COPYRIGHT: xcb_atom_enum_t = 61;
pub const xcb_atom_enum_t_XCB_ATOM_NOTICE: xcb_atom_enum_t = 62;
pub const xcb_atom_enum_t_XCB_ATOM_FONT_NAME: xcb_atom_enum_t = 63;
pub const xcb_atom_enum_t_XCB_ATOM_FAMILY_NAME: xcb_atom_enum_t = 64;
pub const xcb_atom_enum_t_XCB_ATOM_FULL_NAME: xcb_atom_enum_t = 65;
pub const xcb_atom_enum_t_XCB_ATOM_CAP_HEIGHT: xcb_atom_enum_t = 66;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLASS: xcb_atom_enum_t = 67;
pub const xcb_atom_enum_t_XCB_ATOM_WM_TRANSIENT_FOR: xcb_atom_enum_t = 68;
pub type xcb_atom_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).requestor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).selection as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).target as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_request_event_t>())).property as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(property)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_selection_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_selection_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).requestor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).target as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_selection_notify_event_t>())).property as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_UNINSTALLED: xcb_colormap_state_t = 0;
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_INSTALLED: xcb_colormap_state_t = 1;
pub type xcb_colormap_state_t = ::std::os::raw::c_uint;
pub const xcb_colormap_enum_t_XCB_COLORMAP_NONE: xcb_colormap_enum_t = 0;
pub type xcb_colormap_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_colormap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_colormap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).colormap as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>()))._new as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).state as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_colormap_notify_event_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xcb_client_message_data_t {
    pub data8: [u8; 20usize],
    pub data16: [u16; 10usize],
    pub data32: [u32; 5usize],
    _bindgen_union_align: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_client_message_data_t>())).data8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_t>())).data16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_t>())).data32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_data_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_data_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_client_message_data_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_data_iterator_t>())).index as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_client_message_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_client_message_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).format as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_client_message_event_t>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_client_message_event_t>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(data)
        )
    );
}
pub const xcb_mapping_t_XCB_MAPPING_MODIFIER: xcb_mapping_t = 0;
pub const xcb_mapping_t_XCB_MAPPING_KEYBOARD: xcb_mapping_t = 1;
pub const xcb_mapping_t_XCB_MAPPING_POINTER: xcb_mapping_t = 2;
pub type xcb_mapping_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_mapping_notify_event_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_mapping_notify_event_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).request as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).first_keycode as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).count as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_mapping_notify_event_t>())).pad1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ge_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ge_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).extension as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).event_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ge_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_request_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_request_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_request_error_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_request_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_value_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_value_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).response_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).minor_opcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).major_opcode as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_value_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_COPY_FROM_PARENT: xcb_window_class_t = 0;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_OUTPUT: xcb_window_class_t = 1;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_ONLY: xcb_window_class_t = 2;
pub type xcb_window_class_t = ::std::os::raw::c_uint;
pub const xcb_cw_t_XCB_CW_BACK_PIXMAP: xcb_cw_t = 1;
pub const xcb_cw_t_XCB_CW_BACK_PIXEL: xcb_cw_t = 2;
pub const xcb_cw_t_XCB_CW_BORDER_PIXMAP: xcb_cw_t = 4;
pub const xcb_cw_t_XCB_CW_BORDER_PIXEL: xcb_cw_t = 8;
pub const xcb_cw_t_XCB_CW_BIT_GRAVITY: xcb_cw_t = 16;
pub const xcb_cw_t_XCB_CW_WIN_GRAVITY: xcb_cw_t = 32;
pub const xcb_cw_t_XCB_CW_BACKING_STORE: xcb_cw_t = 64;
pub const xcb_cw_t_XCB_CW_BACKING_PLANES: xcb_cw_t = 128;
pub const xcb_cw_t_XCB_CW_BACKING_PIXEL: xcb_cw_t = 256;
pub const xcb_cw_t_XCB_CW_OVERRIDE_REDIRECT: xcb_cw_t = 512;
pub const xcb_cw_t_XCB_CW_SAVE_UNDER: xcb_cw_t = 1024;
pub const xcb_cw_t_XCB_CW_EVENT_MASK: xcb_cw_t = 2048;
pub const xcb_cw_t_XCB_CW_DONT_PROPAGATE: xcb_cw_t = 4096;
pub const xcb_cw_t_XCB_CW_COLORMAP: xcb_cw_t = 8192;
pub const xcb_cw_t_XCB_CW_CURSOR: xcb_cw_t = 16384;
pub type xcb_cw_t = ::std::os::raw::c_uint;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_NONE: xcb_back_pixmap_t = 0;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_PARENT_RELATIVE: xcb_back_pixmap_t = 1;
pub type xcb_back_pixmap_t = ::std::os::raw::c_uint;
pub const xcb_gravity_t_XCB_GRAVITY_BIT_FORGET: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_WEST: xcb_gravity_t = 1;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH: xcb_gravity_t = 2;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_EAST: xcb_gravity_t = 3;
pub const xcb_gravity_t_XCB_GRAVITY_WEST: xcb_gravity_t = 4;
pub const xcb_gravity_t_XCB_GRAVITY_CENTER: xcb_gravity_t = 5;
pub const xcb_gravity_t_XCB_GRAVITY_EAST: xcb_gravity_t = 6;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_WEST: xcb_gravity_t = 7;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH: xcb_gravity_t = 8;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_EAST: xcb_gravity_t = 9;
pub const xcb_gravity_t_XCB_GRAVITY_STATIC: xcb_gravity_t = 10;
pub type xcb_gravity_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_value_list_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).background_pixmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).background_pixel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).border_pixmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).border_pixel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).bit_gravity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).win_gravity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_store as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_planes as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).backing_pixel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).override_redirect as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).save_under as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).event_mask as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).do_not_propogate_mask
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).colormap as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_value_list_t>())).cursor as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_window_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).wid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(wid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_window_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).border_width as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>()))._class as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).visual as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_window_request_t>())).value_mask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_value_list_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixel
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixmap
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).bit_gravity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).win_gravity
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_store
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_planes
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_pixel
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).override_redirect
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).save_under
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).event_mask
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>()))
                .do_not_propogate_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).colormap
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_value_list_t>())).cursor as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_window_attributes_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_window_attributes_request_t>())).value_mask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
pub const xcb_map_state_t_XCB_MAP_STATE_UNMAPPED: xcb_map_state_t = 0;
pub const xcb_map_state_t_XCB_MAP_STATE_UNVIEWABLE: xcb_map_state_t = 1;
pub const xcb_map_state_t_XCB_MAP_STATE_VIEWABLE: xcb_map_state_t = 2;
pub type xcb_map_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_window_attributes_reply_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_window_attributes_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_store as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).visual as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>()))._class as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).bit_gravity as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).win_gravity as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_planes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_pixel as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).save_under as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).map_is_installed
                as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_is_installed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).map_state as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).override_redirect
                as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).colormap as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).all_event_masks
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).your_event_mask
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).do_not_propagate_mask
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_window_attributes_reply_t>())).pad0 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_destroy_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_destroy_subwindows_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_destroy_subwindows_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_destroy_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_set_mode_t_XCB_SET_MODE_INSERT: xcb_set_mode_t = 0;
pub const xcb_set_mode_t_XCB_SET_MODE_DELETE: xcb_set_mode_t = 1;
pub type xcb_set_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_save_set_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_save_set_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_save_set_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_reparent_window_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_reparent_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_reparent_window_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_window_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_map_window_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_map_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_map_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_map_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_unmap_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_unmap_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_unmap_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_X: xcb_config_window_t = 1;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_Y: xcb_config_window_t = 2;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_WIDTH: xcb_config_window_t = 4;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_HEIGHT: xcb_config_window_t = 8;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_BORDER_WIDTH: xcb_config_window_t = 16;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_SIBLING: xcb_config_window_t = 32;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_STACK_MODE: xcb_config_window_t = 64;
pub type xcb_config_window_t = ::std::os::raw::c_uint;
pub const xcb_stack_mode_t_XCB_STACK_MODE_ABOVE: xcb_stack_mode_t = 0;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BELOW: xcb_stack_mode_t = 1;
pub const xcb_stack_mode_t_XCB_STACK_MODE_TOP_IF: xcb_stack_mode_t = 2;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BOTTOM_IF: xcb_stack_mode_t = 3;
pub const xcb_stack_mode_t_XCB_STACK_MODE_OPPOSITE: xcb_stack_mode_t = 4;
pub type xcb_stack_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_value_list_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_window_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_configure_window_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).border_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).sibling as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_value_list_t>())).stack_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_configure_window_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_configure_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).value_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_configure_window_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_circulate_t_XCB_CIRCULATE_RAISE_LOWEST: xcb_circulate_t = 0;
pub const xcb_circulate_t_XCB_CIRCULATE_LOWER_HIGHEST: xcb_circulate_t = 1;
pub type xcb_circulate_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_circulate_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_circulate_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_circulate_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(drawable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_geometry_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_geometry_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).height as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_geometry_reply_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_tree_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_tree_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).parent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).children_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(children_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_tree_reply_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).only_if_exists as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(only_if_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_request_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_intern_atom_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_intern_atom_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_intern_atom_reply_t>())).atom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_request_t>())).atom as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_atom_name_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_atom_name_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_atom_name_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_prop_mode_t_XCB_PROP_MODE_REPLACE: xcb_prop_mode_t = 0;
pub const xcb_prop_mode_t_XCB_PROP_MODE_PREPEND: xcb_prop_mode_t = 1;
pub const xcb_prop_mode_t_XCB_PROP_MODE_APPEND: xcb_prop_mode_t = 2;
pub type xcb_prop_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).format as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).pad0 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_property_request_t>())).data_len as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(data_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_delete_property_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_delete_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_delete_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_get_property_type_t_XCB_GET_PROPERTY_TYPE_ANY: xcb_get_property_type_t = 0;
pub type xcb_get_property_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>()))._delete as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(_delete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).long_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_request_t>())).long_length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_property_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_property_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).bytes_after as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(bytes_after)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_property_reply_t>())).value_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_property_reply_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_properties_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_properties_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).atoms_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_properties_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_selection_owner_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_set_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).owner as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_selection_owner_request_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_request_t>())).selection as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_selection_owner_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_selection_owner_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_selection_owner_reply_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(owner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_convert_selection_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_convert_selection_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).requestor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).target as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).property as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_convert_selection_request_t>())).time as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_POINTER_WINDOW: xcb_send_event_dest_t = 0;
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_ITEM_FOCUS: xcb_send_event_dest_t = 1;
pub type xcb_send_event_dest_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_send_event_request_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_send_event_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).propagate as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_send_event_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).destination as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_send_event_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_send_event_request_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event)
        )
    );
}
pub const xcb_grab_mode_t_XCB_GRAB_MODE_SYNC: xcb_grab_mode_t = 0;
pub const xcb_grab_mode_t_XCB_GRAB_MODE_ASYNC: xcb_grab_mode_t = 1;
pub type xcb_grab_mode_t = ::std::os::raw::c_uint;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_SUCCESS: xcb_grab_status_t = 0;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_ALREADY_GRABBED: xcb_grab_status_t = 1;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_INVALID_TIME: xcb_grab_status_t = 2;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_NOT_VIEWABLE: xcb_grab_status_t = 3;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_FROZEN: xcb_grab_status_t = 4;
pub type xcb_grab_status_t = ::std::os::raw::c_uint;
pub const xcb_cursor_enum_t_XCB_CURSOR_NONE: xcb_cursor_enum_t = 0;
pub type xcb_cursor_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).pointer_mode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).keyboard_mode as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_request_t>())).time as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_pointer_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).status as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_pointer_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_pointer_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_button_index_t_XCB_BUTTON_INDEX_ANY: xcb_button_index_t = 0;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_1: xcb_button_index_t = 1;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_2: xcb_button_index_t = 2;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_3: xcb_button_index_t = 3;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_4: xcb_button_index_t = 4;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_5: xcb_button_index_t = 5;
pub type xcb_button_index_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_button_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).pointer_mode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).keyboard_mode as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).button as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_button_request_t>())).pad0 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_button_request_t>())).modifiers as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_button_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).button as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_button_request_t>())).pad0 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).cursor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).time as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).event_mask
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad1 as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).owner_events as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).pointer_mode as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).keyboard_mode as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_keyboard_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_keyboard_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_keyboard_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_keyboard_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_keyboard_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_grab_t_XCB_GRAB_ANY: xcb_grab_t = 0;
pub type xcb_grab_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_key_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).key as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).pointer_mode as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_key_request_t>())).keyboard_mode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_key_request_t>())).pad0 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_key_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).key as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_ungrab_key_request_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_allow_t_XCB_ALLOW_ASYNC_POINTER: xcb_allow_t = 0;
pub const xcb_allow_t_XCB_ALLOW_SYNC_POINTER: xcb_allow_t = 1;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_POINTER: xcb_allow_t = 2;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_KEYBOARD: xcb_allow_t = 3;
pub const xcb_allow_t_XCB_ALLOW_SYNC_KEYBOARD: xcb_allow_t = 4;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_KEYBOARD: xcb_allow_t = 5;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_BOTH: xcb_allow_t = 6;
pub const xcb_allow_t_XCB_ALLOW_SYNC_BOTH: xcb_allow_t = 7;
pub type xcb_allow_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_allow_events_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_allow_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_allow_events_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_allow_events_request_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_allow_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_allow_events_request_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_grab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_grab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_server_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_grab_server_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_grab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_ungrab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_ungrab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_ungrab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_pointer_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).same_screen as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).child as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root_x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).root_y as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).win_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).win_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_pointer_reply_t>())).pad0 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_t>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_timecoord_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_timecoord_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_timecoord_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_request_t>())).stop as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_motion_events_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_motion_events_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).events_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(events_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_motion_events_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).dst_window as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_x as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_request_t>())).src_y as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_translate_coordinates_reply_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_translate_coordinates_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).same_screen as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).child as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_warp_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_warp_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).src_height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_warp_pointer_request_t>())).dst_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_y)
        )
    );
}
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_NONE: xcb_input_focus_t = 0;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_POINTER_ROOT: xcb_input_focus_t = 1;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_PARENT: xcb_input_focus_t = 2;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_FOLLOW_KEYBOARD: xcb_input_focus_t = 3;
pub type xcb_input_focus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_input_focus_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_input_focus_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).revert_to as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).focus as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_input_focus_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_input_focus_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_input_focus_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).revert_to as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_input_focus_reply_t>())).focus as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(focus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_keymap_reply_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_keymap_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_keymap_reply_t>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_open_font_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_open_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_open_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).fid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_open_font_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_open_font_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_close_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_close_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_close_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_close_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
pub const xcb_font_draw_t_XCB_FONT_DRAW_LEFT_TO_RIGHT: xcb_font_draw_t = 0;
pub const xcb_font_draw_t_XCB_FONT_DRAW_RIGHT_TO_LEFT: xcb_font_draw_t = 1;
pub type xcb_font_draw_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fontprop_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fontprop_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fontprop_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_charinfo_t>())).left_side_bearing as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(left_side_bearing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_charinfo_t>())).right_side_bearing as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(right_side_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).character_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(character_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_t>())).attributes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_charinfo_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_charinfo_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_charinfo_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_font_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_font_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_bounds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_bounds as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_font_reply_t>())).pad2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_char_or_byte2 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_char_or_byte2 as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).default_char as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).properties_len as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).draw_direction as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).min_byte1 as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).max_byte1 as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).all_chars_exist as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).font_ascent as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).font_descent as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_font_reply_t>())).char_infos_len as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(char_infos_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_query_text_extents_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).odd_length as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(odd_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_request_t>())).font as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_text_extents_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_text_extents_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).draw_direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).font_ascent as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).font_descent as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_ascent as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_descent as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_left as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_text_extents_reply_t>())).overall_right as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_str_t>(),
        1usize,
        concat!("Size of: ", stringify!(xcb_str_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_str_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_t>())).name_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_t),
            "::",
            stringify!(name_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_str_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_str_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_str_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).max_names as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_request_t>())).pattern_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).names_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_fonts_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).max_names as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_request_t>())).pattern_len as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).name_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_bounds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad0 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_bounds as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_char_or_byte2
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_char_or_byte2
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).default_char as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).properties_len as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).draw_direction as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_byte1 as *const _
                as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_byte1 as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).all_chars_exist as *const _
                as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_ascent as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_descent as *const _
                as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_fonts_with_info_reply_t>())).replies_hint as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(replies_hint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_font_path_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).font_qty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(font_qty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_font_path_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_font_path_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_font_path_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).path_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(path_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_font_path_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_pixmap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_pixmap_request_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_pixmap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_pixmap_request_t>())).pixmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pixmap)
        )
    );
}
pub const xcb_gc_t_XCB_GC_FUNCTION: xcb_gc_t = 1;
pub const xcb_gc_t_XCB_GC_PLANE_MASK: xcb_gc_t = 2;
pub const xcb_gc_t_XCB_GC_FOREGROUND: xcb_gc_t = 4;
pub const xcb_gc_t_XCB_GC_BACKGROUND: xcb_gc_t = 8;
pub const xcb_gc_t_XCB_GC_LINE_WIDTH: xcb_gc_t = 16;
pub const xcb_gc_t_XCB_GC_LINE_STYLE: xcb_gc_t = 32;
pub const xcb_gc_t_XCB_GC_CAP_STYLE: xcb_gc_t = 64;
pub const xcb_gc_t_XCB_GC_JOIN_STYLE: xcb_gc_t = 128;
pub const xcb_gc_t_XCB_GC_FILL_STYLE: xcb_gc_t = 256;
pub const xcb_gc_t_XCB_GC_FILL_RULE: xcb_gc_t = 512;
pub const xcb_gc_t_XCB_GC_TILE: xcb_gc_t = 1024;
pub const xcb_gc_t_XCB_GC_STIPPLE: xcb_gc_t = 2048;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_X: xcb_gc_t = 4096;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_Y: xcb_gc_t = 8192;
pub const xcb_gc_t_XCB_GC_FONT: xcb_gc_t = 16384;
pub const xcb_gc_t_XCB_GC_SUBWINDOW_MODE: xcb_gc_t = 32768;
pub const xcb_gc_t_XCB_GC_GRAPHICS_EXPOSURES: xcb_gc_t = 65536;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_X: xcb_gc_t = 131072;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_Y: xcb_gc_t = 262144;
pub const xcb_gc_t_XCB_GC_CLIP_MASK: xcb_gc_t = 524288;
pub const xcb_gc_t_XCB_GC_DASH_OFFSET: xcb_gc_t = 1048576;
pub const xcb_gc_t_XCB_GC_DASH_LIST: xcb_gc_t = 2097152;
pub const xcb_gc_t_XCB_GC_ARC_MODE: xcb_gc_t = 4194304;
pub type xcb_gc_t = ::std::os::raw::c_uint;
pub const xcb_gx_t_XCB_GX_CLEAR: xcb_gx_t = 0;
pub const xcb_gx_t_XCB_GX_AND: xcb_gx_t = 1;
pub const xcb_gx_t_XCB_GX_AND_REVERSE: xcb_gx_t = 2;
pub const xcb_gx_t_XCB_GX_COPY: xcb_gx_t = 3;
pub const xcb_gx_t_XCB_GX_AND_INVERTED: xcb_gx_t = 4;
pub const xcb_gx_t_XCB_GX_NOOP: xcb_gx_t = 5;
pub const xcb_gx_t_XCB_GX_XOR: xcb_gx_t = 6;
pub const xcb_gx_t_XCB_GX_OR: xcb_gx_t = 7;
pub const xcb_gx_t_XCB_GX_NOR: xcb_gx_t = 8;
pub const xcb_gx_t_XCB_GX_EQUIV: xcb_gx_t = 9;
pub const xcb_gx_t_XCB_GX_INVERT: xcb_gx_t = 10;
pub const xcb_gx_t_XCB_GX_OR_REVERSE: xcb_gx_t = 11;
pub const xcb_gx_t_XCB_GX_COPY_INVERTED: xcb_gx_t = 12;
pub const xcb_gx_t_XCB_GX_OR_INVERTED: xcb_gx_t = 13;
pub const xcb_gx_t_XCB_GX_NAND: xcb_gx_t = 14;
pub const xcb_gx_t_XCB_GX_SET: xcb_gx_t = 15;
pub type xcb_gx_t = ::std::os::raw::c_uint;
pub const xcb_line_style_t_XCB_LINE_STYLE_SOLID: xcb_line_style_t = 0;
pub const xcb_line_style_t_XCB_LINE_STYLE_ON_OFF_DASH: xcb_line_style_t = 1;
pub const xcb_line_style_t_XCB_LINE_STYLE_DOUBLE_DASH: xcb_line_style_t = 2;
pub type xcb_line_style_t = ::std::os::raw::c_uint;
pub const xcb_cap_style_t_XCB_CAP_STYLE_NOT_LAST: xcb_cap_style_t = 0;
pub const xcb_cap_style_t_XCB_CAP_STYLE_BUTT: xcb_cap_style_t = 1;
pub const xcb_cap_style_t_XCB_CAP_STYLE_ROUND: xcb_cap_style_t = 2;
pub const xcb_cap_style_t_XCB_CAP_STYLE_PROJECTING: xcb_cap_style_t = 3;
pub type xcb_cap_style_t = ::std::os::raw::c_uint;
pub const xcb_join_style_t_XCB_JOIN_STYLE_MITER: xcb_join_style_t = 0;
pub const xcb_join_style_t_XCB_JOIN_STYLE_ROUND: xcb_join_style_t = 1;
pub const xcb_join_style_t_XCB_JOIN_STYLE_BEVEL: xcb_join_style_t = 2;
pub type xcb_join_style_t = ::std::os::raw::c_uint;
pub const xcb_fill_style_t_XCB_FILL_STYLE_SOLID: xcb_fill_style_t = 0;
pub const xcb_fill_style_t_XCB_FILL_STYLE_TILED: xcb_fill_style_t = 1;
pub const xcb_fill_style_t_XCB_FILL_STYLE_STIPPLED: xcb_fill_style_t = 2;
pub const xcb_fill_style_t_XCB_FILL_STYLE_OPAQUE_STIPPLED: xcb_fill_style_t = 3;
pub type xcb_fill_style_t = ::std::os::raw::c_uint;
pub const xcb_fill_rule_t_XCB_FILL_RULE_EVEN_ODD: xcb_fill_rule_t = 0;
pub const xcb_fill_rule_t_XCB_FILL_RULE_WINDING: xcb_fill_rule_t = 1;
pub type xcb_fill_rule_t = ::std::os::raw::c_uint;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN: xcb_subwindow_mode_t = 0;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS: xcb_subwindow_mode_t = 1;
pub type xcb_subwindow_mode_t = ::std::os::raw::c_uint;
pub const xcb_arc_mode_t_XCB_ARC_MODE_CHORD: xcb_arc_mode_t = 0;
pub const xcb_arc_mode_t_XCB_ARC_MODE_PIE_SLICE: xcb_arc_mode_t = 1;
pub type xcb_arc_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_x_origin as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_y_origin as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).font as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_gc_request_t>())).cid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_x_origin as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_y_origin as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).font as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_gc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_gc_request_t>())).value_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).src_gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(src_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).dst_gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(dst_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_dashes_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_dashes_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).dash_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_dashes_request_t>())).dashes_len as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dashes_len)
        )
    );
}
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_UNSORTED: xcb_clip_ordering_t = 0;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_Y_SORTED: xcb_clip_ordering_t = 1;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_SORTED: xcb_clip_ordering_t = 2;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_BANDED: xcb_clip_ordering_t = 3;
pub type xcb_clip_ordering_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_clip_rectangles_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_clip_rectangles_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_clip_rectangles_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_clip_rectangles_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).ordering as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).gc as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_x_origin as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_y_origin as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_gc_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_clear_area_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_clear_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_clear_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_clear_area_request_t>())).exposures as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(exposures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_clear_area_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_area_request_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_area_request_t>())).height as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_plane_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_plane_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).height as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_plane_request_t>())).bit_plane as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(bit_plane)
        )
    );
}
pub const xcb_coord_mode_t_XCB_COORD_MODE_ORIGIN: xcb_coord_mode_t = 0;
pub const xcb_coord_mode_t_XCB_COORD_MODE_PREVIOUS: xcb_coord_mode_t = 1;
pub type xcb_coord_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_point_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_point_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).coordinate_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_point_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_point_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_point_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_line_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_line_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).coordinate_mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_line_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_line_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_line_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_t>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_segment_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_segment_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_segment_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_segment_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_segment_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_segment_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_rectangle_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_rectangle_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).drawable as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_COMPLEX: xcb_poly_shape_t = 0;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_NONCONVEX: xcb_poly_shape_t = 1;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_CONVEX: xcb_poly_shape_t = 2;
pub type xcb_poly_shape_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_fill_poly_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_fill_poly_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).shape as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).coordinate_mode as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_fill_poly_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_rectangle_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_poly_fill_rectangle_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).drawable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_rectangle_request_t>())).gc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_fill_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_fill_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_fill_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_BITMAP: xcb_image_format_t = 0;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_PIXMAP: xcb_image_format_t = 1;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_Z_PIXMAP: xcb_image_format_t = 2;
pub type xcb_image_format_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_put_image_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_put_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).dst_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).dst_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_put_image_request_t>())).left_pad as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(left_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).depth as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_put_image_request_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_cookie_t>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_request_t>())).plane_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_image_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_image_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_image_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).visual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_get_image_reply_t>())).pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_poly_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_poly_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_poly_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_image_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_image_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_image_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_NONE: xcb_colormap_alloc_t = 0;
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_ALL: xcb_colormap_alloc_t = 1;
pub type xcb_colormap_alloc_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_colormap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).alloc as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).mid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_colormap_request_t>())).visual as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(visual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).mid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_copy_colormap_and_free_request_t>())).src_cmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(src_cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_install_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_install_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_install_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_uninstall_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_uninstall_colormap_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_uninstall_colormap_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_uninstall_colormap_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_uninstall_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).response_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).cmaps_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(cmaps_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad1 as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_alloc_color_reply_t>())).pixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).name_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_named_color_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_named_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_red as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_green as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_blue as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_red as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_green as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_blue as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).colors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_request_t>())).planes as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_cells_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_cells_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).masks_len as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(masks_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_alloc_color_planes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).colors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).reds as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(reds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).greens as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(greens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_request_t>())).blues as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(blues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_alloc_color_planes_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_alloc_color_planes_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).red_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).green_mask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).blue_mask as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad2 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_colors_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_colors_request_t>())).plane_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
pub const xcb_color_flag_t_XCB_COLOR_FLAG_RED: xcb_color_flag_t = 1;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_GREEN: xcb_color_flag_t = 2;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_BLUE: xcb_color_flag_t = 4;
pub type xcb_color_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).red as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).green as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_coloritem_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_coloritem_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_coloritem_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_store_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_store_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_store_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_store_named_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_store_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).flags as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).name_len as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_store_named_color_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rgb_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rgb_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_rgb_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_colors_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_colors_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).colors_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(colors_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_query_colors_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_lookup_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_lookup_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).exact_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_green as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_lookup_color_reply_t>())).visual_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
pub const xcb_pixmap_enum_t_XCB_PIXMAP_NONE: xcb_pixmap_enum_t = 0;
pub type xcb_pixmap_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).cid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).source as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_red as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_green as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).fore_blue as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_red as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_green as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).back_blue as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_create_cursor_request_t>())).y as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_font_enum_t_XCB_FONT_NONE: xcb_font_enum_t = 0;
pub type xcb_font_enum_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_create_glyph_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_glyph_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_create_glyph_cursor_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_create_glyph_cursor_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).cid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_font as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_font as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_char as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_char as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_red as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_green as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_blue as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_red as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_green as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_blue as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_free_cursor_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_free_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_free_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_recolor_cursor_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_recolor_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).fore_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_green as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_recolor_cursor_request_t>())).back_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_LARGEST_CURSOR: xcb_query_shape_of_t = 0;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_TILE: xcb_query_shape_of_t = 1;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE: xcb_query_shape_of_t = 2;
pub type xcb_query_shape_of_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>()))._class as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_request_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_best_size_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_best_size_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_best_size_reply_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_query_extension_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_query_extension_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).present as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).major_opcode as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).first_event as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_query_extension_reply_t>())).first_error as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_extensions_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_extensions_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).names_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_extensions_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keycode_count
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keycode_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).first_keycode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_mapping_request_t>())).pad0 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>(),
        6usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).first_keycode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_request_t>())).count as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_kb_t_XCB_KB_KEY_CLICK_PERCENT: xcb_kb_t = 1;
pub const xcb_kb_t_XCB_KB_BELL_PERCENT: xcb_kb_t = 2;
pub const xcb_kb_t_XCB_KB_BELL_PITCH: xcb_kb_t = 4;
pub const xcb_kb_t_XCB_KB_BELL_DURATION: xcb_kb_t = 8;
pub const xcb_kb_t_XCB_KB_LED: xcb_kb_t = 16;
pub const xcb_kb_t_XCB_KB_LED_MODE: xcb_kb_t = 32;
pub const xcb_kb_t_XCB_KB_KEY: xcb_kb_t = 64;
pub const xcb_kb_t_XCB_KB_AUTO_REPEAT_MODE: xcb_kb_t = 128;
pub type xcb_kb_t = ::std::os::raw::c_uint;
pub const xcb_led_mode_t_XCB_LED_MODE_OFF: xcb_led_mode_t = 0;
pub const xcb_led_mode_t_XCB_LED_MODE_ON: xcb_led_mode_t = 1;
pub type xcb_led_mode_t = ::std::os::raw::c_uint;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_OFF: xcb_auto_repeat_mode_t = 0;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_ON: xcb_auto_repeat_mode_t = 1;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_DEFAULT: xcb_auto_repeat_mode_t = 2;
pub type xcb_auto_repeat_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_value_list_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key_click_percent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_percent
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_pitch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_duration
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led_mode
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_value_list_t>())).auto_repeat_mode
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_keyboard_control_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_keyboard_control_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_keyboard_control_request_t>())).value_mask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_keyboard_control_reply_t>(),
        52usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_keyboard_control_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).global_auto_repeat
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).led_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).key_click_percent
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_percent as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_pitch as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_duration as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).pad0 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_keyboard_control_reply_t>())).auto_repeats as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_bell_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_bell_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).major_opcode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).percent as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_bell_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_pointer_control_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).acceleration_numerator
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>()))
                .acceleration_denominator as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).threshold as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).do_acceleration
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_acceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_pointer_control_request_t>())).do_threshold
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_threshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_control_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_control_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_numerator
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_denominator
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).threshold as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_control_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_blanking_t_XCB_BLANKING_NOT_PREFERRED: xcb_blanking_t = 0;
pub const xcb_blanking_t_XCB_BLANKING_PREFERRED: xcb_blanking_t = 1;
pub const xcb_blanking_t_XCB_BLANKING_DEFAULT: xcb_blanking_t = 2;
pub type xcb_blanking_t = ::std::os::raw::c_uint;
pub const xcb_exposures_t_XCB_EXPOSURES_NOT_ALLOWED: xcb_exposures_t = 0;
pub const xcb_exposures_t_XCB_EXPOSURES_ALLOWED: xcb_exposures_t = 1;
pub const xcb_exposures_t_XCB_EXPOSURES_DEFAULT: xcb_exposures_t = 2;
pub type xcb_exposures_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_screen_saver_request_t>(),
        10usize,
        concat!("Size of: ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).timeout as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).interval as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).prefer_blanking as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_screen_saver_request_t>())).allow_exposures as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(allow_exposures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_screen_saver_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_screen_saver_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).interval as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).prefer_blanking as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).allow_exposures as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(allow_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_screen_saver_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_host_mode_t_XCB_HOST_MODE_INSERT: xcb_host_mode_t = 0;
pub const xcb_host_mode_t_XCB_HOST_MODE_DELETE: xcb_host_mode_t = 1;
pub type xcb_host_mode_t = ::std::os::raw::c_uint;
pub const xcb_family_t_XCB_FAMILY_INTERNET: xcb_family_t = 0;
pub const xcb_family_t_XCB_FAMILY_DECNET: xcb_family_t = 1;
pub const xcb_family_t_XCB_FAMILY_CHAOS: xcb_family_t = 2;
pub const xcb_family_t_XCB_FAMILY_SERVER_INTERPRETED: xcb_family_t = 5;
pub const xcb_family_t_XCB_FAMILY_INTERNET_6: xcb_family_t = 6;
pub type xcb_family_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_change_hosts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_change_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).family as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).pad0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_change_hosts_request_t>())).address_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_host_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_host_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_host_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_t>())).address_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: ::std::os::raw::c_int,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_host_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_host_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_host_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_list_hosts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_list_hosts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).hosts_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(hosts_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_list_hosts_reply_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_DISABLE: xcb_access_control_t = 0;
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_ENABLE: xcb_access_control_t = 1;
pub type xcb_access_control_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_access_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_access_control_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_access_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_access_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_access_control_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_close_down_t_XCB_CLOSE_DOWN_DESTROY_ALL: xcb_close_down_t = 0;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_PERMANENT: xcb_close_down_t = 1;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_TEMPORARY: xcb_close_down_t = 2;
pub type xcb_close_down_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_close_down_mode_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_close_down_mode_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_close_down_mode_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_close_down_mode_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_close_down_mode_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_kill_t_XCB_KILL_ALL_TEMPORARY: xcb_kill_t = 0;
pub type xcb_kill_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_kill_client_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_kill_client_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_kill_client_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_kill_client_request_t>())).resource as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(resource)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_rotate_properties_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_rotate_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).atoms_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_rotate_properties_request_t>())).delta as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(delta)
        )
    );
}
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_RESET: xcb_screen_saver_t = 0;
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_ACTIVE: xcb_screen_saver_t = 1;
pub type xcb_screen_saver_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_force_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_force_screen_saver_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_force_screen_saver_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_force_screen_saver_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_force_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_SUCCESS: xcb_mapping_status_t = 0;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_BUSY: xcb_mapping_status_t = 1;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_FAILURE: xcb_mapping_status_t = 2;
pub type xcb_mapping_status_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).map_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).map_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_pointer_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_map_index_t_XCB_MAP_INDEX_SHIFT: xcb_map_index_t = 0;
pub const xcb_map_index_t_XCB_MAP_INDEX_LOCK: xcb_map_index_t = 1;
pub const xcb_map_index_t_XCB_MAP_INDEX_CONTROL: xcb_map_index_t = 2;
pub const xcb_map_index_t_XCB_MAP_INDEX_1: xcb_map_index_t = 3;
pub const xcb_map_index_t_XCB_MAP_INDEX_2: xcb_map_index_t = 4;
pub const xcb_map_index_t_XCB_MAP_INDEX_3: xcb_map_index_t = 5;
pub const xcb_map_index_t_XCB_MAP_INDEX_4: xcb_map_index_t = 6;
pub const xcb_map_index_t_XCB_MAP_INDEX_5: xcb_map_index_t = 7;
pub type xcb_map_index_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_set_modifier_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_get_modifier_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_no_operation_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_no_operation_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_operation_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_no_operation_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xcb_no_operation_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t) -> xcb_visualtype_iterator_t;
}
extern "C" {
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t) -> xcb_depth_iterator_t;
}
extern "C" {
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(
        R: *const xcb_setup_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(
        R: *const xcb_setup_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(
        R: *const xcb_setup_authenticate_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(
        R: *const xcb_setup_authenticate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(
        R: *const xcb_setup_authenticate_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_next(i: *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    pub fn xcb_setup_authenticate_end(
        i: xcb_setup_authenticate_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t) -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t) -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t) -> xcb_screen_iterator_t;
}
extern "C" {
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_client_message_data_next(i: *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    pub fn xcb_client_message_data_end(
        i: xcb_client_message_data_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_window_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(
        R: *const xcb_create_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_window_attributes_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(
        R: *const xcb_change_window_attributes_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_window_attributes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    pub fn xcb_destroy_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *const xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
        _aux: *mut xcb_configure_window_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_configure_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(
        R: *const xcb_configure_window_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_circulate_window_checked(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_circulate_window(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_unchecked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_geometry_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t) -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(
        R: *const xcb_query_tree_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_tree_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_tree_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_intern_atom(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_unchecked(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_intern_atom_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_unchecked(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(
        R: *const xcb_get_atom_name_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(
        R: *const xcb_get_atom_name_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(
        R: *const xcb_get_atom_name_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_atom_name_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_atom_name_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_property_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(
        R: *const xcb_change_property_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(
        R: *const xcb_change_property_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(
        R: *const xcb_change_property_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_delete_property_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_delete_property(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_unchecked(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(
        R: *const xcb_get_property_reply_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(
        R: *const xcb_get_property_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_property_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_property_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(
        R: *const xcb_list_properties_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(
        R: *const xcb_list_properties_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_properties_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_properties_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    pub fn xcb_set_selection_owner_checked(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_selection_owner(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_unchecked(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_selection_owner_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    pub fn xcb_convert_selection_checked(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_convert_selection(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event_checked(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button_checked(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_keyboard_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key_checked(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(
        R: *const xcb_get_motion_events_reply_t,
    ) -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(
        R: *const xcb_get_motion_events_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(
        R: *const xcb_get_motion_events_reply_t,
    ) -> xcb_timecoord_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_motion_events_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    pub fn xcb_translate_coordinates(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_unchecked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_translate_coordinates_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    pub fn xcb_warp_pointer_checked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_warp_pointer(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus_checked(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_input_focus_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    pub fn xcb_query_keymap(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_keymap_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_open_font_checked(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t) -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(
        R: *const xcb_query_font_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_charinfo_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_font_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        string_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_text_extents(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_text_extents_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const ::std::os::raw::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_with_info_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_checked(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(
        R: *const xcb_set_font_path_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(
        R: *const xcb_set_font_path_request_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(
        R: *const xcb_get_font_path_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(
        R: *const xcb_get_font_path_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_font_path_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    pub fn xcb_create_pixmap_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_pixmap(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap_checked(
        c: *mut xcb_connection_t,
        pixmap: xcb_pixmap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_create_gc_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(
        R: *const xcb_create_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_gc_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_gc_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(
        R: *const xcb_change_gc_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_copy_gc_checked(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_gc(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(
        R: *const xcb_set_dashes_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_checked(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area_checked(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_point_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(
        R: *const xcb_poly_point_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(
        R: *const xcb_poly_point_request_t,
    ) -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_line_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    pub fn xcb_segment_end(i: xcb_segment_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        segments_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t) -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(
        R: *const xcb_poly_segment_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(
        R: *const xcb_poly_segment_request_t,
    ) -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(
        R: *const xcb_poly_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(
        R: *const xcb_poly_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(
        R: *const xcb_poly_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        points_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        rectangles_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        arcs_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        data_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_put_image_checked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_unchecked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_image_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(
        R: *const xcb_poly_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(
        R: *const xcb_poly_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(
        R: *const xcb_poly_text_16_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(
        R: *const xcb_image_text_8_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(
        R: *const xcb_image_text_8_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(
        R: *const xcb_image_text_8_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t) -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(
        R: *const xcb_image_text_16_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(
        R: *const xcb_image_text_16_request_t,
    ) -> xcb_char2b_iterator_t;
}
extern "C" {
    pub fn xcb_create_colormap_checked(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_colormap(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free_checked(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_installed_colormaps_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_named_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_named_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cells_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R: *const xcb_alloc_color_planes_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_planes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_free_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(
        R: *const xcb_free_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(
        R: *const xcb_free_colors_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        items_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t) -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(
        R: *const xcb_store_colors_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(
        R: *const xcb_store_colors_request_t,
    ) -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_checked(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(
        R: *const xcb_store_named_color_request_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(
        R: *const xcb_store_named_color_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(
        R: *const xcb_store_named_color_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        pixels_len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t) -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(
        R: *const xcb_query_colors_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(
        R: *const xcb_query_colors_reply_t,
    ) -> xcb_rgb_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_colors_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_lookup_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_lookup_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    pub fn xcb_create_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_unchecked(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_best_size_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_extension(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_unchecked(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const ::std::os::raw::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_extension_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(
        R: *const xcb_list_extensions_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(
        R: *const xcb_list_extensions_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_extensions_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_extensions_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_checked(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_unchecked(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(
        _buffer: *mut *mut ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *const xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_keyboard_control_value_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(
        _buffer: *const ::std::os::raw::c_void,
        value_mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const ::std::os::raw::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(
        R: *const xcb_change_keyboard_control_request_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control_checked(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    pub fn xcb_set_screen_saver_checked(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_screen_saver(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_screen_saver_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(
        R: *const xcb_change_hosts_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(
        R: *const xcb_change_hosts_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t) -> xcb_host_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_hosts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(
        R: *const xcb_rotate_properties_request_t,
    ) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(
        R: *const xcb_rotate_properties_request_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(
        R: *const xcb_rotate_properties_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_pointer_mapping(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R: *const xcb_get_pointer_mapping_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_set_modifier_mapping(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(
        _buffer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_auth_info_t {
    pub namelen: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub datalen: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(
        ::std::mem::size_of::<xcb_auth_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<xcb_auth_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).namelen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).datalen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xcb_auth_info_t>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn xcb_flush(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event {
    _unused: [u8; 0],
}
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    pub fn xcb_poll_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_wait_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn xcb_register_for_special_xge(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
        eid: u32,
        stamp: *mut u32,
    ) -> *mut xcb_special_event_t;
}
extern "C" {
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t, se: *mut xcb_special_event_t);
}
extern "C" {
    pub fn xcb_request_check(
        c: *mut xcb_connection_t,
        cookie: xcb_void_cookie_t,
    ) -> *mut xcb_generic_error_t;
}
extern "C" {
    pub fn xcb_discard_reply(c: *mut xcb_connection_t, sequence: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    pub fn xcb_get_extension_data(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
    ) -> *const xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t, ext: *mut xcb_extension_t);
}
extern "C" {
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connect_to_fd(
        fd: ::std::os::raw::c_int,
        auth_info: *mut xcb_auth_info_t,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_parse_display(
        name: *const ::std::os::raw::c_char,
        host: *mut *mut ::std::os::raw::c_char,
        display: *mut ::std::os::raw::c_int,
        screen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_connect(
        displayname: *const ::std::os::raw::c_char,
        screenp: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_connect_to_display_with_auth_info(
        display: *const ::std::os::raw::c_char,
        auth: *mut xcb_auth_info_t,
        screen: *mut ::std::os::raw::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_total_read(c: *mut xcb_connection_t) -> u64;
}
extern "C" {
    pub fn xcb_total_written(c: *mut xcb_connection_t) -> u64;
}
pub type VkXcbSurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkXcbSurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkXcbSurfaceCreateFlagsKHR,
    pub connection: *mut xcb_connection_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_VkXcbSurfaceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkXcbSurfaceCreateInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkXcbSurfaceCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkXcbSurfaceCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkXcbSurfaceCreateInfoKHR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkXcbSurfaceCreateInfoKHR>())).sType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXcbSurfaceCreateInfoKHR),
            "::",
            stringify!(sType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkXcbSurfaceCreateInfoKHR>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXcbSurfaceCreateInfoKHR),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VkXcbSurfaceCreateInfoKHR>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXcbSurfaceCreateInfoKHR),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkXcbSurfaceCreateInfoKHR>())).connection as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXcbSurfaceCreateInfoKHR),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VkXcbSurfaceCreateInfoKHR>())).window as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VkXcbSurfaceCreateInfoKHR),
            "::",
            stringify!(window)
        )
    );
}
pub type PFN_vkCreateXcbSurfaceKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkXcbSurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        connection: *mut xcb_connection_t,
        visual_id: xcb_visualid_t,
    ) -> VkBool32,
>;
extern "C" {
    pub fn vkCreateXcbSurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkXcbSurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceXcbPresentationSupportKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        connection: *mut xcb_connection_t,
        visual_id: xcb_visualid_t,
    ) -> VkBool32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
